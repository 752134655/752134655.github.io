<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>陈sis的博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-06-15T02:51:20.931Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>陈sis</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>服务器搭建遇到的问题</title>
    <link href="http://yoursite.com/2020/06/05/%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2020/06/05/%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/</id>
    <published>2020-06-05T01:05:22.000Z</published>
    <updated>2020-06-15T02:51:20.931Z</updated>
    
    <content type="html"><![CDATA[<h3>Linux 系统服务器做开发几个常用命令</h3><ul><li>ssh 用户名 @ip，连接服务器的命令。</li><li>cd 绝对路径 / 相对路径，跳转到路径对应的目录下。</li><li>rm 文件名，删除文件。</li><li>rm -rf 目录路径，删除目录以及目录下的所有文件，谨慎操作 !</li><li>ls [-a]，查看当前目录下的文件和目录，加-a 参数可以查看所有文件，包括隐藏文件（.开头的文件是隐藏文件，默认是看不见的）。</li><li>ll，查看当前目录下的文件详情，可以文件的权限，遇到没有权限执行的情况下可以使用这个命令查看。</li><li>pwd，查看当前路径的完整路径，不知道自己在哪儿的时候可以使用这个命令查看。</li><li>which 名字，在几个默认位置查找改名字，比如查找pm2安装在哪个地方了。</li><li>mkdir 目录名，创建一个空目录。</li><li>cat 相对 / 绝对文件路径，查看文件的内容，多为查看日志或者其他文本文件。</li><li>cp 文件路径  目标路径，复制一个文件到另外一个地方。</li><li>mv 文件路径  目标路径，移动一个文件到另外一个地方，也可以重命名。</li><li>ps -aux，显示当前进程，有时候需要用这个查看进程是否存活。</li><li>kill -9 进程 id，结束进程，进程 id 就是上一条命令查到的 pid。</li><li>tar -zxvf(也有xvf) 文件，解压缩文件。</li><li>tar -zcvf 压缩后的文件 要压缩的文件 / 目录，压缩文件。</li><li>vi 文件路径，使用 vim 进入文件的编辑模式。</li><li>vi 退出文件，按下 esc 键保证退出编辑模式，输入:q或者:q!强制退出。</li><li>vi 编辑，按下i左下角会提示进入编辑模式，然后就是正常的输入文字，再按esc键退出编辑模式。</li><li>vi 保存编辑结果，按下 esc 键保证退出编辑模式，输入:x保存并退出。</li></ul><h3>安装node.js</h3><p>解压node之后,配置node和npm<br>ln -sf(sf是覆盖更新，如果没有配置过，直接f就行) /root/soft/node-v12.18.0-linux-x64/bin/node(该路径要绝对路径) /usr/local/bin/node,<br>ln -sf(sf是覆盖更新，如果没有配置过，直接f就行) /root/soft/node-v12.18.0-linux-x64/bin/npm(该路径要绝对路径) /usr/local/bin/npm,</p><h3>配置nginx</h3>./configure --prefix=/usr/local/nginx]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3&gt;Linux 系统服务器做开发几个常用命令&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;ssh 用户名 @ip，连接服务器的命令。&lt;/li&gt;
&lt;li&gt;cd 绝对路径 / 相对路径，跳转到路径对应的目录下。&lt;/li&gt;
&lt;li&gt;rm 文件名，删除文件。&lt;/li&gt;
&lt;li&gt;rm -rf 目录路
      
    
    </summary>
    
    
    
      <category term="问题" scheme="http://yoursite.com/tags/%E9%97%AE%E9%A2%98/"/>
    
      <category term="服务器" scheme="http://yoursite.com/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>vuex</title>
    <link href="http://yoursite.com/2020/05/21/vuex/"/>
    <id>http://yoursite.com/2020/05/21/vuex/</id>
    <published>2020-05-21T02:28:32.000Z</published>
    <updated>2020-05-21T10:03:43.375Z</updated>
    
    <content type="html"><![CDATA[<p>关于全局对象和 Vuex 之间的区别，官方写得还是比较通俗易懂的：<br>Vuex 和单纯的全局对象有以下两点不同：<br>Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。<br>你不能直接改变 store 中的状态。改变 store 中状态的唯一途径就是显式地提交 (commit) mutation。这样使得我们可以方便地跟踪每一个状态的变化，从而让我们能够实现一些工具帮助我们更好地了解我们的应用。<br>简单示例<br>// 如果在模块化构建系统中，请确保在开头调用了 Vue.use(Vuex)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs plain">const store &#x3D; new Vuex.Store(&#123;<br>  state: &#123;<br>    count: 0<br>  &#125;,<br>  mutations: &#123;<br>    increment (state) &#123;<br>      state.count++<br>    &#125;<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>每一个 Vuex 应用的核心就是 store（仓库）。store 基本上就是一个容器，它包含着你的应用中大部分的状态 (state)。<br>注意：如果 mutations 不知道是什么，没关系，后面会专门讲解到，可以单纯的理解为只能用它里面的方法来修改 state 中的数据。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">store.commit(&#39;increment&#39;) &#x2F;* 调用 mutations 中的方法 *&#x2F;<br>console.log(store.state.count) &#x2F;&#x2F; -&gt; 1<br></code></pre></td></tr></table></figure><h3>State</h3><p>我们再回过头来看一下之前那个简单的 Store 示例代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs plain">import Vue from &#39;vue&#39;<br>import Vuex from &#39;vuex&#39;<br><br>Vue.use(Vuex)<br><br>const store &#x3D; new Vuex.Store(&#123;<br>  state: &#123;<br>    count: 0<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>那么我们如何在 Vue 组件中展示状态呢？由于 Vuex 的状态存储是响应式的，从 store 实例中读取状态最简单的方法就是在计算属性中返回某个状态，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs plain">&#x2F;* 创建一个 Counter 组件 *&#x2F;<br>const Counter &#x3D; &#123;<br>  data() &#123; return &#123;&#125; &#125;,<br>  template: &#96;&lt;div&gt;&#123;&#123; count &#125;&#125;&lt;&#x2F;div&gt;&#96;,<br>  computed: &#123;<br>    count () &#123;<br>      return store.state.count<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>/*  每当 store.state.count 变化的时候, 都会重新求取计算属性，并刷新界面。 */</p><p>需要注意的是，如果你把 store.state.count 放在 data 中， store.state.count 的变化是不会主动触发界面刷新的，当然，也不能直接这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">&lt;div&gt;&#123;&#123; store.state.count &#125;&#125;&lt;&#x2F;div&gt;<br></code></pre></td></tr></table></figure><p>因为在模板中是无法直接访问到 store 对象的，所以这样写无疑会报错。</p><p>这种模式依赖于全局的管理员 store，如果模块多了，意味着每个模块或者页面只要用到了这个 state 里面的数据，都得把 store 引入进来，这样的操作确实有点难受。当然，官方肯定是不允许有这样令人抓狂的操作出现的：</p><p>Vuex 通过 store 选项，提供了一种机制将状态从根组件 “注入” 到每一个子组件中（需调用 Vue.use(Vuex)）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs plain">const app &#x3D; new Vue(&#123;<br>  el: &#39;#app&#39;,<br>  &#x2F;&#x2F; 把 store 对象提供给 “store” 选项，<br>  &#x2F;&#x2F; 这可以把 store 的实例注入所有的子组件<br>  store,<br>  &#x2F;&#x2F; 子组件<br>  components: &#123; Counter &#125;,<br>  template: &#39;&lt;div class&#x3D;&quot;app&quot;&gt;<br>      &lt;counter&gt;&lt;&#x2F;counter&gt;<br>    &lt;&#x2F;div&gt;&#39;<br>&#125;)<br></code></pre></td></tr></table></figure><p>通过在根实例中注册 store 选项，该 store 实例会注入到根组件下的所有子组件中，且子组件能通过 this.$store 访问到。让我们更新下 Counter 的实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs plain">const Counter &#x3D; &#123;<br>  template: &#96;&lt;div&gt;&#123;&#123; count &#125;&#125;&lt;&#x2F;div&gt;&#96;,<br>  computed: &#123;<br>    count () &#123;<br>      return this.$store.state.count<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Vuex 的状态固然好用，但是也不要滥用：</p><p>使用 Vuex 并不意味着你需要将所有的状态放入 Vuex。虽然将所有的状态放到 Vuex 会使状态变化更显式和易调试，但也会使代码变得冗长和不直观。如果有些状态严格属于单个组件，最好还是作为组件的局部状态。你应该根据你的应用开发需要进行权衡和确定。</p><h3>Getter</h3><p>有时候，我们会发现 State 中的数据，并不是我们直接想要的，而是需要经过相应的处理后，才能满足我们的需求。<br>比如在一个组件中，我们需要把 state 中的日期 date 转换成星期几来展示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plain">computed: &#123;<br>  weekDate () &#123;<br>    return moment(this.$store.state.date).format(&#39;dddd&#39;); <br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果只有一个组件需要这样做还好，但如果在很多组件中，都需要这么转换的话，那就得在每一个组件中都需要把这个函数复制过去。而且，一旦产品经理心情不好，不想用星期几来显示，想直接用 2018-10-30 11:12:23 这种方式来显示日期，那你就得在所有用到它的组件中去更改日期格式化的方法，岂不难受至极。就算你把它单独抽取出来作为一个公共的函数，各种导入也麻烦，最重要的是不好统一管理。</p><p>所以，这个时候，Vuex 又引入了一个牛逼的玩意儿，Getter。我们可以把它当成 store 中的计算属性（computed）。</p><p>就像计算属性一样，getter 的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算。</p><p>我们看看这两个例子，着重注意下里面的注释：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs plain">const store &#x3D; new Vuex.Store(&#123;<br>  state: &#123;<br>    date: new Date()<br>  &#125;,<br>  getters: &#123;<br>    &#x2F;* Getter 接受 state 作为其第一个参数 *&#x2F;<br>    weekDate: state &#x3D;&gt; &#123;<br>      return moment(state.date).format(&#39;dddd&#39;); <br>    &#125;<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plain">getters: &#123;<br>  &#x2F;* Getter 还也可以接收 getters 作为第二个参数 *&#x2F;<br>  dateLength: (state, getters) &#x3D;&gt; &#123;<br>    return getters.weekDate.length;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>不但如此，Getter 还会将 store.getters 对象暴露出去，你可以以属性的形式访问这些值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">console.log(store.getters.weekDate)<br></code></pre></td></tr></table></figure><p>我们可以很容易地在任何组件中使用它：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plain">computed: &#123;<br>  weekDate () &#123;<br>    return this.$store.getters.weekDate<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在需求又变了，每个模块要显示的 weekDate 的格式不一样，有的显示全部日期，有的需要显示星期几，怎么办？</p><p>好办，那就给 Getter 传参呗，但是怎么传呢？</p><p>因为 Getter 在通过属性访问时是作为 Vue 的响应式系统的一部分缓存其中的，所以是不能直接 store.getters.weekDate(‘MM Do YY’)，因为 weekDate 并不是一个函数，它仅仅只是一个属性而已。</p><p>那么既然属性不能传参，怎么办呢？那我们就想办法把这个属性变成一个函数不就行了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plain">getters: &#123;<br>  &#x2F;&#x2F; 返回一个函数，就可以传参了<br>  weekDate: (state) &#x3D;&gt; (fm) &#x3D;&gt; &#123;<br>    return moment(state.date).format(fm ? fm : &#39;dddd&#39;); <br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">store.getters.weekDate(&#39;MM Do YY&#39;)<br></code></pre></td></tr></table></figure><h3>只有 mutation 能动 State</h3><p>更改 Vuex 的 store 中的状态的唯一方法是提交 mutation。Vuex 中的 mutation 非常类似于事件：每个 mutation 都有一个字符串的 事件类型 (type) 和 一个 回调函数 (handler)。这个回调函数就是我们实际进行状态更改的地方，并且它会接受 state 作为第一个参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs plain">const store &#x3D; new Vuex.Store(&#123;<br>  state: &#123;<br>    count: 1<br>  &#125;,<br>  mutations: &#123;<br>    &#x2F;&#x2F; 事件类型 type 为 increment<br>    increment (state) &#123;<br>      &#x2F;&#x2F; 变更状态<br>      state.count++<br>    &#125;<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>注意，我们不能直接 store.mutations.increment() 来调用，Vuex 规定必须使用 store.commit 来触发对应 type 的方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">store.commit(&#39;increment&#39;)<br></code></pre></td></tr></table></figure><h3>传参</h3><p>我们还可以向 store.commit 传入额外的参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plain">mutations: &#123;<br>  increment (state, n) &#123;<br>    state.count +&#x3D; n<br>  &#125;<br>&#125;<br>调用<br>store.commit(&#39;increment&#39;, 10)<br></code></pre></td></tr></table></figure><p>mutation 中的这个额外的参数，官方给它还取了一个高大上的名字：载荷（payload）。说实话，第一次在文档中看到这个标题「提交载荷」，真的就不想往下看了。<br>我们往往不是败给了这些生涩的概念，而是败给了自己内心的恐惧。<br>大多数情况下，载荷是一个对象，能够让我们更加易读：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plain">mutations: &#123;<br>  increment (state, payload) &#123;<br>    state.count +&#x3D; payload.amount<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>关于提交的方式，有两种：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs plain">&#x2F;&#x2F; 1、把载荷和type分开提交<br>store.commit(&#39;increment&#39;, &#123;<br>  amount: 10<br>&#125;)<br><br>&#x2F;&#x2F; 2、整个对象都作为载荷传给 mutation 函数<br>store.commit(&#123;<br>  type: &#39;increment&#39;,<br>  amount: 10<br>&#125;)<br></code></pre></td></tr></table></figure><p>当然，使用哪种方式没有绝对的界限，纯看自己的喜好，就我个人而言，还是比较倾向于使用第二种姿势，放在一起更实在。</p><h3>修改规则</h3><p>简单修改基础类型的状态数据倒是简单，没什么限制，但是如果修改的是对象，那就要注意了。比如这个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs plain">const store &#x3D; new Vuex.Store(&#123;<br>  state: &#123;<br>    student: &#123;<br>      name: &#39;小明&#39;,<br>      sex: &#39;女&#39;<br>    &#125;<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>这个时候，我们如果想要给 student 添加一个年龄 age: 18 属性，怎么办呢？</p><p>是的，直接在 sex 下面把这个字段加上去不就行了，能这样当然最好了。但是如果我们要动态的修改呢？那就得遵循 Vue 的规则了。如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plain">mutations: &#123;<br>  addAge (state) &#123;<br>    Vue.set(state.student, &#39;age&#39;, 18)<br>    &#x2F;&#x2F; 或者：<br>    &#x2F;&#x2F; state.student &#x3D; &#123; ...state.student, age: 18 &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>以上就是给对象添加属性的两种方式，当然，对于已添加的对象，如果想修改具体值的话，直接更改就是，比如 state.student.age=20 即可。</p><p>至于为什么要这样，之前我们了解过，因为 store 中的状态是响应式的，当我们更改状态数据的时候，监视状态的 Vue 组件也会自动更新，所以 Vuex 中的 mutation 也需要与使用 Vue 一样遵守这些规则。</p><h3>使用常量</h3><p>就是使用常量来替代 mutation 事件的名字。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">&#x2F;* mutation-types.js *&#x2F;<br>export const SOME_MUTATION &#x3D; &#39;SOME_MUTATION&#39;<br></code></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs plain">&#x2F;* tore.js *&#x2F;<br>import Vuex from &#39;vuex&#39;<br>import &#123; SOME_MUTATION &#125; from &#39;.&#x2F;mutation-types&#39;<br><br>const store &#x3D; new Vuex.Store(&#123;<br>  state: &#123; ... &#125;,<br>  mutations: &#123;<br>    &#x2F;* 使用 ES2015 风格的计算属性命名功能来使用一个常量作为函数名 *&#x2F;<br>    [SOME_MUTATION] (state) &#123;<br>      &#x2F;* mutate state *&#x2F;<br>    &#125;<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>可能有人会有疑问啊，这样做到底有啥用，还得多创建个类型文件，用的时候还要导入进来，不嫌麻烦吗！</p><p>我们看看，mutation 是怎么调用的：store.commit(‘increment’)，可以发现，这里 commit 提交的方法 increment，是以字符串的形式代入的。如果项目小，一个人开发的话倒还好，但是项目大了，编写代码的人多了，那就麻烦了，因为需要 commit 的方法一多，就会显得特别混乱，而且以字符串形式代入的话，一旦出了错，很难排查。</p><p>所以，对于多人合作的大项目，最好还是用常量的形式来处理 mutation，对于小项目倒是无所谓，想偷懒的随意就好。</p><h3>必须是同步函数</h3><p>一定要记住，Mutation 必须是同步函数。为什么呢？</p><p>前面说了，我们之所以要通过提交 mutation 的方式来改变状态数据，是因为我们想要更明确地追踪到状态的变化。如果像下面这样异步的话：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plain">mutations: &#123;<br>  someMutation (state) &#123;<br>    api.callAsyncMethod(() &#x3D;&gt; &#123;<br>      state.count++<br>    &#125;)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们就不知道什么时候状态会发生改变，所以也就无法追踪了，这与 Mutation 的设计初心相悖，所以强制规定它必须是同步函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">store.commit(&#39;increment&#39;)<br></code></pre></td></tr></table></figure><h3>Action</h3><p>简单介绍<br>Action 类似于 mutation，不同在于：<br>1、Action 提交的是 mutation，而不是直接变更状态。<br>2、Action 可以包含任意异步操作。</p><p>看一个简单的 action 示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs plain">const store &#x3D; new Vuex.Store(&#123;<br>  state: &#123;<br>    count: 0<br>  &#125;,<br>  mutations: &#123;<br>    increment (state) &#123;<br>      state.count++<br>    &#125;<br>  &#125;,<br>  actions: &#123;<br>    increment (context) &#123;<br>      context.commit(&#39;increment&#39;)<br>    &#125;<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>可以看到，Action 函数接受一个 context 参数，注意，这个参数可不一般，它与 store 实例有着相同的方法和属性，但是他们并不是同一个实例，后面学习 Modules 的时候会介绍它们为什么不一样。</p><p>所以在这里可以使用 context.commit 来提交一个 mutation，或者通过 context.state 和 context.getters 来获取 state 和 getters。</p><p>当然，为了代码简化，我们可以使用 ES2015 的 参数解构 来直接展开，便于 commit、state 等多次调用。如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plain">actions: &#123;<br>  increment (&#123; commit &#125;) &#123;<br>    commit(&#39;increment&#39;)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3>分发 Action</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">store.dispatch(&#39;increment&#39;)<br></code></pre></td></tr></table></figure><p>Mutation 通过 store.commit 触发，那么 Action 则通过 store.dispatch 方法触发。</p><p>乍一眼看上去感觉多此一举，我们直接分发 mutation 岂不更方便？实际上并非如此，还记得 mutation 必须同步执行这个限制么？Action 就不受约束！我们可以在 action 内部执行异步操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plain">actions: &#123;<br>  incrementAsync (&#123; commit &#125;) &#123;<br>    setTimeout(() &#x3D;&gt; &#123;<br>      commit(&#39;increment&#39;)<br>    &#125;, 1000)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>和 Mutation 分发的方式异曲同工，这是注意这里是 dispatch：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs plain">&#x2F;* 以载荷形式分发 *&#x2F;<br>store.dispatch(&#39;incrementAsync&#39;, &#123;<br>  amount: 10<br>&#125;)<br><br>&#x2F;* 以对象形式分发 *&#x2F;<br>store.dispatch(&#123;<br>  type: &#39;incrementAsync&#39;,<br>  amount: 10<br>&#125;)<br></code></pre></td></tr></table></figure><p>来看一个更加实际的购物车示例，涉及到调用异步 API 和分发多重 mutation：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs plain">actions: &#123;<br>  checkout (&#123; commit, state &#125;, products) &#123;<br>    &#x2F;&#x2F; 把当前购物车的物品备份起来<br>    const savedCartItems &#x3D; [...state.cart.added]<br>    &#x2F;&#x2F; 发出结账请求，然后乐观地清空购物车<br>    commit(types.CHECKOUT_REQUEST)<br>    &#x2F;&#x2F; 购物 API 接受一个成功回调和一个失败回调<br>    shop.buyProducts(<br>      products,<br>      &#x2F;&#x2F; 成功操作<br>      () &#x3D;&gt; commit(types.CHECKOUT_SUCCESS),<br>      &#x2F;&#x2F; 失败操作<br>      () &#x3D;&gt; commit(types.CHECKOUT_FAILURE, savedCartItems)<br>    )<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意示例中正在进行一系列的异步操作，并且通过提交 mutation 来记录 action 产生的副作用（即状态变更）。</p><h3>组合 Action</h3><p>Action 通常是异步的，那么如何知道 action 什么时候结束呢？更重要的是，我们如何才能组合多个 action，以处理更加复杂的异步流程？</p><p>首先，你需要明白 store.dispatch 可以处理被触发的 action 的处理函数返回的 Promise，并且 store.dispatch 仍旧返回 Promise：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs plain">actions: &#123;<br>  actionA (&#123; commit &#125;) &#123;<br>    return new Promise((resolve, reject) &#x3D;&gt; &#123;<br>      setTimeout(() &#x3D;&gt; &#123;<br>        commit(&#39;someMutation&#39;)<br>        resolve()<br>      &#125;, 1000)<br>    &#125;)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>调用:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">store.dispatch(&#39;actionA&#39;).then(() &#x3D;&gt; &#123;<br>  &#x2F;&#x2F; ...<br>&#125;)<br></code></pre></td></tr></table></figure><p>当然，也可以这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs plain">actions: &#123;<br>  &#x2F;&#x2F; ...<br>  actionB (&#123; dispatch, commit &#125;) &#123;<br>    return dispatch(&#39;actionA&#39;).then(() &#x3D;&gt; &#123;<br>      commit(&#39;someOtherMutation&#39;)<br>    &#125;)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们还可以利用 async / await 的方式组合 action ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs plain">&#x2F;* 假设 getData() 和 getOtherData() 返回的是 Promise *&#x2F;<br>actions: &#123;<br>  async actionA (&#123; commit &#125;) &#123;<br>    commit(&#39;gotData&#39;, await getData())<br>  &#125;,<br>  async actionB (&#123; dispatch, commit &#125;) &#123;<br>    await dispatch(&#39;actionA&#39;) &#x2F;&#x2F; 等待 actionA 完成<br>    commit(&#39;gotOtherData&#39;, await getOtherData())<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>一个 store.dispatch 在不同模块中可以触发多个 action 函数。在这种情况下，只有当所有触发函数完成后，返回的 Promise 才会执行。</p><p>我们在实际项目中经常的会遇到这种情况，比如说你现在想要处理 B 事件，但是 B 事件需要一种资源才能进行，而这种资源必须通过 A 事件来获得。这个时候，我们就需要组合 Action 来处理这些事件了。</p><h3>mapState</h3><p>通过前面的学习，我们知道，从 store 实例中读取状态最简单的方法就是在计算属性中返回某个状态。</p><p>那么，当一个组件需要获取多个状态的时候，怎么办？是不是这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs plain">export default &#123;<br>  ...<br>  computed: &#123;<br>      a () &#123;<br>        return store.state.a<br>      &#125;,<br>      b () &#123;<br>        return store.state.b<br>      &#125;,<br>      c () &#123;<br>        return store.state.c<br>      &#125;,<br>      ...<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当然，这样是没问题的，但是总感觉写起来很难受，看起来更难受是吧！既然这么容易我们就感受到了，Vuex 能感受不到吗，能忍得了吗？</p><p>绝对不能忍，所以 mapState 辅助函数被创造了出来，用来搞定这个人人为之咬牙切齿的痛点。</p><p>/* 在单独构建的版本中辅助函数为 Vuex.mapState */</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs plain">import &#123; mapState &#125; from &#39;vuex&#39;<br><br>export default &#123;<br>  computed: mapState(&#123;<br>    &#x2F;* 箭头函数可使代码更简练 *&#x2F;<br>    a: state &#x3D;&gt; state.a,<br>    b: state &#x3D;&gt; state.b,<br>    c: state &#x3D;&gt; state.c,<br><br>    &#x2F;* 传字符串参数 &#39;b&#39; *&#x2F;<br>    &#x2F;* 等同于 &#96;state &#x3D;&gt; state.b&#96; *&#x2F;<br>    bAlias: &#39;b&#39;,<br><br>    &#x2F;* 为了能够使用 &#96;this&#96; 获取局部状态 *&#x2F;<br>    &#x2F;* 必须使用常规函数 *&#x2F;<br>    cInfo (state) &#123;<br>      return state.c + this.info<br>    &#125;<br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>通过上面的示例，可以了解到，我们可以直接把需要用到的状态全部存放在 mapState 里面进行统一管理，而且还可以取别名，做额外的操作等等。</p><p>如果所映射的计算属性名称与 state 的子节点名称相同时，我们还可以更加简化，给 mapState 传一个字符串数组：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plain">computed: mapState([<br>  &#x2F;* 映射 this.a 为 store.state.a *&#x2F;<br>  &#39;a&#39;,<br>  &#39;b&#39;,<br>  &#39;c&#39;<br>])<br></code></pre></td></tr></table></figure><p>因为 computed 这个计算属性接收的是一个对象，所以由上面的示例代码可以看出，mapState 函数返回的是一个对象，现在如果想要和局部的计算属性混合使用的话，可以使用 ES6 的语法这样写来大大简化：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs plain">computed: &#123;<br>  localComputed () &#123; <br>    ...<br>  &#125;,<br>  &#x2F;* 使用对象展开运算符将此对象混入到外部对象中 *&#x2F;<br>  ...mapState(&#123;<br>    <br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>了解了 mapState 辅助函数后，接下来的几个辅助函数的用法也基本上都差不多了，我们继续往下看。</p><h3>mapGetters</h3><p>这个和 mapState 基本上没啥区别，简单看下官方的例子，就懂了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs plain">import &#123; mapGetters &#125; from &#39;vuex&#39;<br><br>export default &#123;<br>  computed: &#123;<br>    ...mapGetters([<br>      &#39;doneTodosCount&#39;,<br>      &#39;anotherGetter&#39;,<br>    ])<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>取个别名，那就用对象的形式，以下示例的意思就是把 this.doneCount 映射为 this.$store.getters.doneTodosCount。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">mapGetters(&#123;<br>  doneCount: &#39;doneTodosCount&#39;<br>&#125;)<br></code></pre></td></tr></table></figure><h3>mapMutations</h3><p>直接看示例代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs plain">import &#123; mapMutations &#125; from &#39;vuex&#39;<br><br>export default &#123;<br>  methods: &#123;<br>    ...mapMutations([<br>      &#x2F;&#x2F; 将 &#96;this.increment()&#96; 映射为 <br>      &#x2F;&#x2F; &#96;this.$store.commit(&#39;increment&#39;)&#96;<br>      &#39;increment&#39;, <br>      &#x2F;&#x2F; &#96;mapMutations&#96; 也支持载荷：<br>      &#x2F;&#x2F; 将 &#96;this.incrementBy(amount)&#96; 映射为 <br>      &#x2F;&#x2F; &#96;this.$store.commit(&#39;incrementBy&#39;, amount)&#96;<br>      &#39;incrementBy&#39; <br>    ]),<br>    ...mapMutations(&#123;<br>      &#x2F;&#x2F; 将 &#96;this.add()&#96; 映射为 <br>      &#x2F;&#x2F; &#96;this.$store.commit(&#39;increment&#39;)&#96;<br>      add: &#39;increment&#39; <br>    &#125;)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>简直不要太好用，连载荷也可以直接支持。</p><h3>mapActions</h3><p>和 mapMutations 用法一模一样，换个名字即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs plain">import &#123; mapActions &#125; from &#39;vuex&#39;<br><br>export default &#123;<br>  &#x2F;&#x2F; ...<br>  methods: &#123;<br>    ...mapActions([<br>      &#x2F;&#x2F; 将 &#96;this.increment()&#96; 映射为 <br>      &#x2F;&#x2F; &#96;this.$store. dispatch(&#39;increment&#39;)&#96;<br>      &#39;increment&#39;, <br>      &#x2F;&#x2F; &#96;mapActions&#96; 也支持载荷：<br>      &#x2F;&#x2F; 将 &#96;this.incrementBy(amount)&#96; 映射为 <br>      &#x2F;&#x2F; &#96;this.$store. dispatch(&#39;incrementBy&#39;, amount)&#96;<br>      &#39;incrementBy&#39; <br>    ]),<br>    ...mapActions(&#123;<br>      &#x2F;&#x2F; 将 &#96;this.add()&#96; 映射为 <br>      &#x2F;&#x2F; &#96;this.$store. dispatch(&#39;increment&#39;)&#96;<br>      add: &#39;increment&#39; <br>    &#125;)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>想要在组件中调用，直接 this.xxx 就完了。</p><h3>Module</h3><p>首先还是得先了解下 Module 的背景。我们知道，Vuex 使用的是单一状态树，应用的所有状态会集中到一个对象中。如果项目比较大，那么相应的状态数据肯定就会更多，这样的话，store 对象就会变得相当的臃肿，非常难管理。</p><p>这就好比一家公司只有老板一个人来管理一样。如果小公司倒还好，公司要是稍微大一点，那就麻烦了。这个时候，老板就会成立各大部门，并给各大部门安排一个主管，把管理的任务分派下去，然后有什么事情需要处理的话，只需要跟这几个主管沟通，由主管再把任务分配下去就行了，这就大大提高了工作效率，也减轻了老板的负担。</p><p>那么同样的道理，Module 其实就承担了部门管理员的角色，而 store 就是老板。理解了这一层，那么后面就好办多了，接下来，咱们就一步一步动起手来开始实践。</p><p>我们已经了 Module 的基本职责，那么具体如何使用呢？</p><p>Vuex 允许我们将 store 分割成大大小小的对象，每个对象也都拥有自己的 state、getter、mutation、action，这个对象我们把它叫做 module（模块），在模块中还可以继续嵌套子模块、子子模块 ……</p><p>现在在 src 里面建个文件夹，命名为 module，然后再里面新建一个 moduleA.js 文件，并编写如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs plain">export default &#123;<br>    state: &#123;<br>        text: &#39;moduleA&#39;<br>    &#125;,<br>    getters: &#123;&#125;,<br>    mutations: &#123;&#125;,<br>    actions: &#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如上，再建一个 moduleB.js 文件，这里就不重复了。</p><p>然后打开 store.js 文件，导入这两个 module ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs plain">import moduleA from &#39;.&#x2F;module&#x2F;moduleA&#39;;<br>import moduleB from &#39;.&#x2F;module&#x2F;moduleB&#39;;<br><br>export default new Vuex.Store(&#123;<br>    modules: &#123;<br>        moduleA, moduleB,<br>    &#125;,<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>这个时候，store 中已经注入了两个子模块 moduleA moduleB，我们可以在 App.vue 中通过 this.$store.state.moduleA.text 这种方式来直接访问模块中的 state 数据。如下修改：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plain">computed: &#123;<br>    ...mapState(&#123;<br>        name: state &#x3D;&gt; state.moduleA.text<br>    &#125;),<br>&#125;,<br></code></pre></td></tr></table></figure><p>由此可知，模块内部的 state 是局部的，只属于模块本身所有，所以外部必须通过对应的模块名进行访问。</p><p>但是注意了：</p><p>模块内部的 action、mutation 和 getter 默认可是注册在全局命名空间的，这样使得多个模块能够对同一 mutation 或 action 作出响应。</p><p>这里以 mutation 的响应为例，给 moduleA 和 moduleB 分别新增一个 mutations，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plain">mutations: &#123;<br>    setText(state) &#123;<br>        state.text &#x3D; &#39;A&#39;<br>    &#125;<br>&#125;,<br></code></pre></td></tr></table></figure><p>moduleB 和上面一样，把文本名称修改一下即可，这里就不重复了。然后回到 App.vue 中，修改如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs plain">&lt;script&gt;<br>    import &#123;mapState, mapMutations&#125; from &#39;vuex&#39;;<br>    export default &#123;<br>        computed: &#123;<br>            ...mapState(&#123;<br>                name: state &#x3D;&gt; (state.moduleA.text + &#39;和&#39; + state.moduleB.text)<br>            &#125;),<br>        &#125;,<br>        methods: &#123;<br>            ...mapMutations([&#39;setText&#39;]),<br>            modifyNameAction() &#123;<br>                this.setText();<br>            &#125;<br>        &#125;,<br>    &#125;<br>&lt;&#x2F;script&gt;<br></code></pre></td></tr></table></figure><p>运行然后点击修改，我们会发现模块 A 和 B 中的 text 值都改变了。当然，action 的用法一模一样，大家也可以试试。</p><p>如果模块之间的数据有交集的话，那么我们其实就可以通过这种方式，来同步更新模块之间的数据，虽然看起来非常的方便，但是用的时候可一定要谨慎，这种处理方式一旦没用好，遇到错误，排查起来还是比较有难度的。</p><h3>访问根节点</h3><p>我们已经知晓，模块内部的 state 是局部的，只属于模块本身所有。那么如果我们要想在模块中访问 store 根节点的数据 state，怎么办呢？<br>很简单，我们可以在模块内部的 getter 和 action 中，通过 rootState 这个参数来获取。接下来，我们给 modelA.js 文件添加一点代码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs plain">export default &#123;<br>    getters: &#123;<br>        &#x2F;* 注意:rootState必须是第三个参数 *&#x2F;<br>        detail(state, getters, rootState) &#123;<br>            return state.text + &#39;-&#39; + rootState.name;<br>        &#125;<br>    &#125;,<br>    actions: &#123;<br>        callAction(&#123;state, rootState&#125;) &#123;<br>            alert(state.text + &#39;-&#39; + rootState.name);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后修改 App.vue ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs plain">&lt;script&gt;<br>    import &#123;mapActions, mapGetters&#125; from &#39;vuex&#39;;<br>    export default &#123;<br>        computed: &#123;<br>            ...mapGetters(&#123;<br>                name: &#39;detail&#39;<br>            &#125;),<br>        &#125;,<br>        methods: &#123;<br>            ...mapActions([&#39;callAction&#39;]),<br>            modifyNameAction() &#123;<br>                this.callAction();<br>            &#125;<br>        &#125;,<br>    &#125;<br>&lt;&#x2F;script&gt;<br></code></pre></td></tr></table></figure><p>然后运行你会发现，根节点的数据已经被我们获取到了。这里需要注意的是在 getters 中，rootState 是以第三个参数暴露出来的，另外，还有第四个参数 rootGetters，用来获得根节点的 getters 信息，这里就不演示了，感兴趣自己可以去尝试。唯一要强调的就是千万不要弄错参数的位置了。</p><p>当然，action 中也能接收到 rootGetters，但是在 action 中，由于它接收过来的数据都被包在 context 对象中的，所以解包出来没有什么顺序的限制。</p><h3>命名空间</h3><p>前面我们已经知道了，模块内部的 action、mutation 和 getter 默认是注册在全局命名空间的。如果我们只想让他们在当前的模块中生效，应该怎么办呢？</p><p>通过添加 namespaced: true 的方式使其成为带命名空间的模块。当模块被注册后，它的所有 getter、action 及 mutation 都会自动根据模块注册的路径调整命名。</p><p>我们在 moduleA.js 中添加 namespaced: true。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">export default &#123;<br>    namespaced: true,<br>&#125;<br></code></pre></td></tr></table></figure><p>这个时候再去运行代码，你会发现如下错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">[vuex] unknown getter: detail<br></code></pre></td></tr></table></figure><p>在全局 getter 中已经找不到 detail 的这个方法了，因为它的路劲已经改变了，不再属于全局，仅仅只属于 moduleA 了。所以，这个时候，如果我们想要访问它，必须带上路劲才行。修改 App.vue 如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs plain">&lt;script&gt;<br>import &#123;mapActions, mapGetters&#125; from &#39;vuex&#39;;<br>export default &#123;<br>    computed: &#123;<br>        ...mapGetters(&#123;<br>            name: &#39;moduleA&#x2F;detail&#39;<br>        &#125;),<br>    &#125;,<br>    methods: &#123;<br>        ...mapActions(&#123;<br>            call: &#39;moduleA&#x2F;callAction&#39;<br>        &#125;),<br>        modifyNameAction() &#123;<br>            this.call();<br>        &#125;<br>    &#125;,<br>&#125;<br>&lt;&#x2F;script&gt;<br></code></pre></td></tr></table></figure><p>注意，如果一个模块启用了命名空间，那么它里面的 getter 和 action 中收到的 getter，dispatch 和 commit 也都是局部化的，不需要在同一模块内额外添加空间名前缀。也就是说，更改 namespaced 属性后不需要修改模块内的任何代码。</p><p>那么我们如何在带命名空间的模块内访问全局内容呢？</p><p>通过前面的学习，我们已经了解到：</p><p>如果你希望使用全局 state 和 getter，rootState 和 rootGetter 会作为第三和第四参数传入 getter，也会通过 context 对象的属性传入 action。</p><p>现在如果想要在全局命名空间内分发 action 或提交 mutation 的话，那么我们只需要将 将 { root: true } 作为第三参数传给 dispatch 或 commit 即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs plain">export default &#123;<br>    namespaced: true,<br>    actions: &#123;<br>        callAction(&#123;state, commit, rootState&#125;) &#123;<br>            commit(&#39;setName&#39;, &#39;改变&#39;, &#123;root: true&#125;);<br>            alert(state.text + &#39;-&#39; + rootState.name);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来看看如何在带命名空间的模块内注册全局 action。</p><p>若需要在带命名空间的模块注册全局 action，你可添加 root: true，并将这个 action 的定义放在函数 handler 中。</p><p>写法稍微有点变化，我们来看看，修改 moduleA.js，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs plain">export default &#123;<br>    namespaced: true,<br>    actions: &#123;<br>        callAction: &#123;<br>            root: true,<br>            handler (namespacedContext, payload) &#123;<br>                let &#123;state, commit&#125; &#x3D; namespacedContext;<br>                commit(&#39;setText&#39;);<br>                alert(state.text);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>简单解释下，这里的 namespacedContext 就相当于当前模块的上下文对象，payload 是调用的时候所传入的参数，当然也叫载荷。</p><p>示例就讲到这里，接下来看看带命名空间的绑定函数。</p><p>关于 mapState, mapGetters, mapActions 和 mapMutations 这些函数如何来绑定带命名空间的模块，上面示例代码中其实已经都写过了，这里再看看另外几种更简便的写法，先看看之前的写法。</p><p>这里就用官方的示例代码举例说明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs plain">computed: &#123;<br>    ...mapState(&#123;<br>        a: state &#x3D;&gt; state.some.nested.module.a,<br>        b: state &#x3D;&gt; state.some.nested.module.b<br>    &#125;)<br>&#125;,<br>methods: &#123;<br>    ...mapActions([<br>        &#x2F;&#x2F; -&gt; this[&#39;some&#x2F;nested&#x2F;module&#x2F;foo&#39;]()<br>        &#39;some&#x2F;nested&#x2F;module&#x2F;foo&#39;, <br>        &#x2F;&#x2F; -&gt; this[&#39;some&#x2F;nested&#x2F;module&#x2F;bar&#39;]()<br>        &#39;some&#x2F;nested&#x2F;module&#x2F;bar&#39; <br>    ])<br>&#125;<br></code></pre></td></tr></table></figure><p>更优雅的写法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs plain">computed: &#123;<br>    ...mapState(&#39;some&#x2F;nested&#x2F;module&#39;, &#123;<br>        a: state &#x3D;&gt; state.a,<br>        b: state &#x3D;&gt; state.b<br>    &#125;)<br>&#125;,<br>methods: &#123;<br>    ...mapActions(&#39;some&#x2F;nested&#x2F;module&#39;, [<br>        &#39;foo&#39;, &#x2F;* -&gt; this.foo() *&#x2F;<br>        &#39;bar&#39; &#x2F;* -&gt; this.bar() *&#x2F;<br>    ])<br>&#125;<br></code></pre></td></tr></table></figure><p>将模块的空间名称字符串作为第一个参数传递给上述函数，这样所有绑定都会自动将该模块作为上下文。</p><p>我们还可以通过使用 createNamespacedHelpers 创建基于某个命名空间辅助函数。它返回一个对象，对象里有新的绑定在给定命名空间值上的组件绑定辅助函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs plain">import &#123; createNamespacedHelpers &#125; from &#39;vuex&#39;<br><br>const &#123; mapState, mapActions &#125; &#x3D; createNamespacedHelpers(&#39;some&#x2F;nested&#x2F;module&#39;)<br><br>export default &#123;<br>  computed: &#123;<br>    &#x2F;* 在 &#96;some&#x2F;nested&#x2F;module&#96; 中查找 *&#x2F;<br>    ...mapState(&#123;<br>      a: state &#x3D;&gt; state.a,<br>      b: state &#x3D;&gt; state.b<br>    &#125;)<br>  &#125;,<br>  methods: &#123;<br>    &#x2F;* 在 &#96;some&#x2F;nested&#x2F;module&#96; 中查找 *&#x2F;<br>    ...mapActions([<br>      &#39;foo&#39;,<br>      &#39;bar&#39;<br>    ])<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3>模块的动态注册</h3><p>这一章节，官网讲得比较清楚，所以直接搬过来了。</p><p>在 store 创建之后，可以使用 store.registerModule 方法动态的注册模块：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs plain">注册模块 &#96;myModule&#96;<br>store.registerModule(&#39;myModule&#39;, &#123;<br>  <br>&#125;)<br>注册嵌套模块 &#96;nested&#x2F;myModule&#96;<br>store.registerModule([&#39;nested&#39;, &#39;myModule&#39;], &#123;<br>  <br>&#125;)<br></code></pre></td></tr></table></figure><p>之后就可以通过 store.state.myModule 和 store.state.nested.myModule 访问模块的状态。</p><p>模块动态注册功能使得其他 Vue 插件可以通过在 store 中附加新模块的方式来使用 Vuex 管理状态。例如，vuex-router-sync 插件就是通过动态注册模块将 vue-router 和 vuex 结合在一起，实现应用的路由状态管理。</p><p>你也可以使用 store.unregisterModule(moduleName) 来动态卸载模块。注意，你不能使用此方法卸载静态模块（即创建 store 时声明的模块）。</p><p>在注册一个新 module 时，你很有可能想保留过去的 state，例如从一个服务端渲染的应用保留 state。你可以通过 preserveState 选项将其归档：store.registerModule(‘a’, module, { preserveState: true })。</p><h3>模块重用</h3><p>就一点，重用会导致模块中的数据 state 被污染，所以和 Vue 中的 data 一样，也使用一个函数来申明 state 即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plain">const MyReusableModule &#x3D; &#123;<br>  state () &#123;<br>    return &#123;<br>      foo: &#39;bar&#39;<br>    &#125;<br>  &#125;,<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;关于全局对象和 Vuex 之间的区别，官方写得还是比较通俗易懂的：&lt;br&gt;Vuex 和单纯的全局对象有以下两点不同：&lt;br&gt;Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更
      
    
    </summary>
    
    
    
      <category term="vue" scheme="http://yoursite.com/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>vue面试题</title>
    <link href="http://yoursite.com/2020/05/15/vue%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>http://yoursite.com/2020/05/15/vue%E9%9D%A2%E8%AF%95%E9%A2%98/</id>
    <published>2020-05-15T02:17:38.000Z</published>
    <updated>2020-05-21T02:28:52.300Z</updated>
    
    <content type="html"><![CDATA[<h3>谈谈你对MVVM开发模式的理解</h3><p>MVVM分为Model、View、ViewModel三者。<br>Model：代表数据模型，数据和业务逻辑都在Model层中定义；<br>View：代表UI视图，负责数据的展示；<br>ViewModel：负责监听Model中数据的改变并且控制视图的更新，处理用户交互操作；<br>Model和View并无直接关联，而是通过ViewModel来进行联系的，Model和ViewModel之间有着双向数据绑定的联系。因此当Model中的数据改变时会触发View层的刷新，View中由于用户交互操作而改变的数据也会在Model中同步。<br>这种模式实现了Model和View的数据自动同步，因此开发者只需要专注对数据的维护操作即可，而不需要自己操作dom。</p><h3> Vue 有哪些指令？</h3><p>v-html、v-show、v-if、v-for、v-text等等。</p><h3>v-if 和 v-show 有什么区别？</h3><p>v-show 仅仅控制元素的显示方式，将 display 属性在 block 和 none 来回切换；而v-if会控制这个 DOM 节点的存在与否。当我们需要经常切换某个元素的显示/隐藏时，使用v-show会更加节省性能上的开销；当只需要一次显示或隐藏时，使用v-if更加合理。</p><h3>简述Vue的响应式原理</h3><p>当一个Vue实例创建时，vue会遍历data选项的属性，用 Object.defineProperty 将它们转为getter/setter并且在内部追踪相关依赖，在属性被访问和修改时通知变化。<br>每个组件实例都有相应的watcher程序实例，它会在组件渲染的过程中把属性记录为依赖，之后当依赖项的setter被调用时，会通知watcher重新计算，从而致使它关联的组件得以更新。<br><img src="/2020/05/15/vue%E9%9D%A2%E8%AF%95%E9%A2%98/01.png" alt></p><h3>子组件传值父组件</h3>一、子组件代码<p>template部分</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plain">&lt;template&gt;<br>  &lt;section&gt;<br>    &lt;input v-model&#x3D;&quot;message&quot;&#x2F;&gt;<br>  &lt;&#x2F;section&gt;<br>&lt;&#x2F;template&gt;<br></code></pre></td></tr></table></figure><p>js部分</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs plain">&lt;script&gt;<br>export default &#123;<br>  data()&#123;<br>    return &#123;<br>      message:&#39;请输入&#39;<br>    &#125;<br>  &#125;,<br>&#x2F;&#x2F;通过watch来监听message是否改变<br>  watch:&#123;<br>    &#39;message&#39;:function()&#123;<br>      this.$emit(&#39;getMessage&#39;,this.message);&#x2F;&#x2F;主要是通过$emit方法来实现传参的方式，第一个参数是自定义事件名称，第二个则是要传的数据<br>    &#125;<br>  &#125;<br>&#125;<br>&lt;&#x2F;script&gt;<br></code></pre></td></tr></table></figure><p>其实不一定要用wacth来监听数据变化，直接给input加个输入事件，也是可以的。</p><p>二、父组件代码</p><p>template部分</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs plain">&lt;template&gt;<br>  &lt;div id&#x3D;&quot;app&quot;&gt;<br>    &lt;!--getMessage是子组件那边定义的 自定义事件--&gt;<br>    &lt;test  @getMessage&#x3D;&quot;getVal&quot;&gt;&lt;&#x2F;test&gt;<br>    &lt;div&gt;<br>      子组件输入的值:&#123;&#123;chindVal&#125;&#125;<br>    &lt;&#x2F;div&gt;<br>  &lt;&#x2F;div&gt;<br>&lt;&#x2F;template&gt;<br></code></pre></td></tr></table></figure><p>js部分</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs plain">&lt;script&gt;<br>import test from &#39;.&#x2F;components&#x2F;header&#39;<br>export default &#123;<br>  data()&#123;<br>    return &#123;<br>      chindVal:&#39;&#39;,<br>    &#125;<br>  &#125;,<br>  components:&#123;<br>    test<br>  &#125;,<br>  methods:&#123;<br>    getVal(msg)&#123;&#x2F;&#x2F;msg就是传过来的数据了  这只是个形参  名字可以随意<br>      this.chindVal&#x3D;msg;&#x2F;&#x2F;然后将数据赋值给chindVal<br>    &#125;<br>  &#125;<br>&#125;<br>&lt;&#x2F;script&gt;<br></code></pre></td></tr></table></figure><p>总结：<br>1.子组件传参给父组件主要是通过$emit方法来实现的。<br>2.在子组件中使用$emit方法，一般它接受两个参数，第一个是自定义事件(这个事件在父组件中需要用到)，第二个参数就是需要传的数据了。<br>3.而在父组件里，在调用的标签上引用子组件定义的那个事件，然后事件绑定一个函数。在函数里面进行赋值即可。</p><h3>Vue中如何监控某个属性值的变化？</h3><p>比如现在需要监控data中， obj.a 的变化。Vue中监控对象属性的变化你可以这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs plain">watch: &#123;<br>    obj: &#123;<br>    handler (newValue, oldValue) &#123;<br>      console.log(&#39;obj changed&#39;)<br>    &#125;,<br>    deep: true<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>deep属性表示深层遍历，但是这么写会监控obj的所有属性变化，并不是我们想要的效果，所以做点修改：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plain">watch: &#123;<br> &#39;obj.a&#39;: &#123;<br>    handler (newName, oldName) &#123;<br>      console.log(&#39;obj.a changed&#39;)<br>    &#125;<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>还有一种方法，可以通过computed 来实现，只需要：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plain">computed: &#123;<br>    a1 () &#123;<br>      return this.obj.a<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>利用计算属性的特性来实现，当依赖改变时，便会重新计算一个新值。</p><h3>Vue中给data中的对象属性添加一个新的属性时会发生什么，如何解决？</h3><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs plain">&lt;template&gt;<br>&lt;div&gt;<br>  &lt;ul&gt;<br>    &lt;li v-for&#x3D;&quot;value in obj&quot; :key&#x3D;&quot;value&quot;&gt;<br>      &#123;&#123;value&#125;&#125;<br>    &lt;&#x2F;li&gt;<br>  &lt;&#x2F;ul&gt;<br>  &lt;button @click&#x3D;&quot;addObjB&quot;&gt;添加obj.b&lt;&#x2F;button&gt;<br>&lt;&#x2F;div&gt;<br>&lt;&#x2F;template&gt;<br>&lt;script&gt;<br>export default &#123;<br>  data () &#123;<br>    return &#123;<br>      obj: &#123;<br>        a: &#39;obj.a&#39;<br>      &#125;<br>    &#125;<br>  &#125;,<br>  methods: &#123;<br>    addObjB () &#123;<br>      this.obj.b &#x3D; &#39;obj.b&#39;<br>      console.log(this.obj)<br>    &#125;<br>  &#125;<br>&#125;<br>&lt;&#x2F;script&gt;<br></code></pre></td></tr></table></figure><p>点击button会发现， obj.b 已经成功添加，但是视图并未刷新：<br>原因在于在Vue实例创建时， obj.b 并未声明，因此就没有被Vue转换为响应式的属性，自然就不会触发视图的更新，这时就需要使用Vue的全局api—— $set()：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plain">addObjB () &#123;<br>  &#x2F;&#x2F; this.obj.b &#x3D; &#39;obj.b&#39;<br>  this.$set(this.obj, &#39;b&#39;, &#39;obj.b&#39;)<br>  console.log(this.obj)<br>&#125;<br></code></pre></td></tr></table></figure><p>$set() 方法相当于手动的去把 obj.b 处理成一个响应式的属性，此时视图也会跟着改变了.</p><h3>delete和Vue.delete删除数组的区别</h3><p>delete只是被删除的元素变成了 empty/undefined 其他的元素的键值还是不变。<br>Vue.delete 直接删除了数组 改变了数组的键值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plain">var a&#x3D;[1,2,3,4]<br>var b&#x3D;[1,2,3,4]<br>delete a[1]<br>console.log(a)<br>this.$delete(b,1)<br>console.log(b)<br></code></pre></td></tr></table></figure><p><img src="/2020/05/15/vue%E9%9D%A2%E8%AF%95%E9%A2%98/02.png" alt><br><img src="/2020/05/15/vue%E9%9D%A2%E8%AF%95%E9%A2%98/03.png" alt></p><h3>vue中组件的懒加载和路由懒加载</h3><ul><li>常用的懒加载方式有两种：即使用vue异步组件 和 ES中的import</li></ul><p>1.未用懒加载，vue中路由代码如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs plain">import Vue from &#39;vue&#39;<br>import Router from &#39;vue-router&#39;<br>import HelloWorld from &#39;@&#x2F;components&#x2F;HelloWorld&#39;<br>Vue.use(Router)<br>export default new Router(&#123;<br>  routes: [<br>    &#123;<br>      path: &#39;&#x2F;&#39;,<br>      name: &#39;HelloWorld&#39;,<br>      component:HelloWorld<br>    &#125;<br>  ]<br>&#125;)<br></code></pre></td></tr></table></figure><p>2.vue异步组件实现懒加载<br>方法如下：component：resolve=&gt;(require([‘需要加载的路由的地址’])，resolve)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs plain">import Vue from &#39;vue&#39;<br>import Router from &#39;vue-router&#39;<br>　　&#x2F;* 此处省去之前导入的HelloWorld模块 *&#x2F;<br>Vue.use(Router)<br><br>export default new Router(&#123;<br>  routes: [<br>    &#123;<br>      path: &#39;&#x2F;&#39;,<br>      name: &#39;HelloWorld&#39;,<br>      component: resolve&#x3D;&gt;(require([&quot;@&#x2F;components&#x2F;HelloWorld&quot;],resolve))<br>    &#125;<br>  ]<br>&#125;)<br></code></pre></td></tr></table></figure><p>3.ES 提出的import方法，（——最常用——）<br>方法如下：const HelloWorld = （）=&gt;import(‘需要加载的模块地址’)<br>（不加 { } ，表示直接return）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs plain">import Vue from &#39;vue&#39;<br>import Router from &#39;vue-router&#39;<br><br>Vue.use(Router)<br><br>const HelloWorld &#x3D; ()&#x3D;&gt;import(&quot;@&#x2F;components&#x2F;HelloWorld&quot;)<br>export default new Router(&#123;<br>  routes: [<br>    &#123;<br>      path: &#39;&#x2F;&#39;,<br>      name: &#39;HelloWorld&#39;,<br>      component:HelloWorld<br>    &#125;<br>  ]<br>&#125;)<br></code></pre></td></tr></table></figure><p>4.组件懒加载</p><p>与路由懒加载相同，<br>1)原来组件中写法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs plain">&lt;template&gt;<br>  &lt;div class&#x3D;&quot;hello&quot;&gt;<br>  &lt;One-com&gt;&lt;&#x2F;One-com&gt;<br>  1111<br>  &lt;&#x2F;div&gt;<br>&lt;&#x2F;template&gt;<br><br>&lt;script&gt;<br>import One from &#39;.&#x2F;one&#39;<br>export default &#123;<br>  components:&#123;<br>    &quot;One-com&quot;:One<br>  &#125;,<br>  data () &#123;<br>    return &#123;<br>      msg: &#39;Welcome to Your Vue.js App&#39;<br>    &#125;<br>  &#125;<br>&#125;<br>&lt;&#x2F;script&gt;<br></code></pre></td></tr></table></figure><p>2)const方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs plain">&lt;template&gt;<br>  &lt;div class&#x3D;&quot;hello&quot;&gt;<br>    &lt;One-com&gt;&lt;&#x2F;One-com&gt;<br>  &lt;&#x2F;div&gt;<br>&lt;&#x2F;template&gt;<br><br>&lt;script&gt;<br>const One &#x3D; ()&#x3D;&gt;import(&quot;.&#x2F;one&quot;);<br>export default &#123;<br>  components:&#123;<br>    &quot;One-com&quot;:One<br>  &#125;,<br>  data () &#123;<br>    return &#123;<br>      msg: &#39;Welcome to Your Vue.js App&#39;<br>    &#125;<br>  &#125;<br>&#125;<br>&lt;&#x2F;script&gt;<br></code></pre></td></tr></table></figure><p>3)异步方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs plain">&lt;template&gt;<br>  &lt;div class&#x3D;&quot;hello&quot;&gt;<br>    &lt;One-com&gt;&lt;&#x2F;One-com&gt;<br>  &lt;&#x2F;div&gt;<br>&lt;&#x2F;template&gt;<br><br>&lt;script&gt;<br>export default &#123;<br>  components:&#123;<br>    &quot;One-com&quot;:resolve&#x3D;&gt;([&#39;.&#x2F;one&#39;],resolve)<br>  &#125;,<br>  data () &#123;<br>    return &#123;<br>      msg: &#39;Welcome to Your Vue.js App&#39;<br>    &#125;<br>  &#125;<br>&#125;<br>&lt;&#x2F;script&gt;<br></code></pre></td></tr></table></figure><p>总结<br>路由和组件的常用两种懒加载方式：<br>1、vue异步组件实现路由懒加载<br>component：resolve=&gt;([‘需要加载的路由的地址’，resolve])<br>2、es提出的import(推荐使用这种方式)<br>const HelloWorld = （）=&gt;import(‘需要加载的模块地址’)</p><h3>如何优化SPA应用的首屏加载速度慢的问题？</h3><p>将公用的JS库通过script标签外部引入，减小 app.bundel 的大小，让浏览器并行下载资源文件，提高下载速度；<br>在配置 路由时，页面和组件使用懒加载的方式引入，进一步缩小 app.bundel 的体积，在调用某个组件时再加载对应的js文件；<br>加一个首屏loading图，提升用户体验；</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3&gt;谈谈你对MVVM开发模式的理解&lt;/h3&gt;

&lt;p&gt;MVVM分为Model、View、ViewModel三者。&lt;br&gt;Model：代表数据模型，数据和业务逻辑都在Model层中定义；&lt;br&gt;View：代表UI视图，负责数据的展示；&lt;br&gt;ViewModel：负责监听Mode
      
    
    </summary>
    
    
    
      <category term="vue" scheme="http://yoursite.com/tags/vue/"/>
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>面试题2</title>
    <link href="http://yoursite.com/2020/05/13/%E9%9D%A2%E8%AF%95%E9%A2%982/"/>
    <id>http://yoursite.com/2020/05/13/%E9%9D%A2%E8%AF%95%E9%A2%982/</id>
    <published>2020-05-13T01:41:38.000Z</published>
    <updated>2020-05-22T07:37:44.737Z</updated>
    
    <content type="html"><![CDATA[<h3>css实现图片自适应宽高</h3><p>img {<br>  max-width: 100%;<br>  max-height: 100%;<br>}</p><h3>什么是flex，写出常见属性，以及作用</h3><p>Flex即：Flexible Box，弹性布局，用来为盒状模型提供最大的灵活性。可以实现类似垂直居中布局。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs plain">.box&#123;<br>  display: flex;<br>&#125;<br><br>.box&#123;<br>  display: inline-flex;<br>&#125;<br><br>&lt;!-- Webkit内核的浏览器，必须加上-webkit前缀 --&gt;<br>.box&#123;<br>  display: -webkit-flex; &#x2F;* Safari *&#x2F;<br>  display: flex;<br>&#125;<br>设为Flex布局以后，子元素的float、clear和vertical-align属性将失效<br><br>采用Flex布局的元素，称为Flex容器（flex container）<br>所有子元素自动成为容器成员，称为Flex项目（flex item）<br>容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。<br></code></pre></td></tr></table></figure><p><img src="/2020/05/13/%E9%9D%A2%E8%AF%95%E9%A2%982/1.webp" alt></p><h3>容器有6个属性</h3>* flex-direction 决定主轴的方向<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plain">.box &#123;<br>  flex-direction: row | row-reverse | column | column-reverse;<br>&#125;<br>&#x2F;&#x2F; row（默认值）：主轴为水平方向，起点在左端<br>&#x2F;&#x2F; row-reverse：主轴为水平方向，起点在右端<br>&#x2F;&#x2F; column：主轴为垂直方向，起点在上沿<br>&#x2F;&#x2F; column-reverse：主轴为垂直方向，起点在下沿<br></code></pre></td></tr></table></figure><ul><li><p>flex-wrap 定义，如果一条轴线排不下，如何换行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plain">.box&#123;<br>  flex-wrap: nowrap | wrap | wrap-reverse;<br>&#125;<br>&#x2F;&#x2F; nowrap（默认）：不换行<br>&#x2F;&#x2F; wrap：换行，第一行在上方<br>&#x2F;&#x2F; wrap-reverse：换行，第一行在下方<br></code></pre></td></tr></table></figure></li><li><p>flex-flow 是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">.box &#123;<br>  flex-flow: &lt;flex-direction&gt; &lt;flex-wrap&gt;;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>justify-content 定义了项目在主轴上的对齐方式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs plain">.box &#123;<br>  justify-content: flex-start | flex-end | center | space-between | space-around;<br>&#125;<br>&#x2F;&#x2F; 具体对齐方式与轴的方向有关。下面假设主轴为从左到右<br>&#x2F;&#x2F; flex-start（默认值）：左对齐<br>&#x2F;&#x2F; flex-end：右对齐<br>&#x2F;&#x2F; center： 居中<br>&#x2F;&#x2F; space-between：两端对齐，项目之间的间隔都相等。<br>&#x2F;&#x2F; space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。<br></code></pre></td></tr></table></figure></li><li><p>align-items 定义项目在交叉轴上如何对齐</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs plain">.box &#123;<br>  align-items: flex-start | flex-end | center | baseline | stretch;<br>&#125;<br>&#x2F;&#x2F; 具体的对齐方式与交叉轴的方向有关，下面假设交叉轴从上到下<br>&#x2F;&#x2F; flex-start：交叉轴的起点对齐。<br>&#x2F;&#x2F; flex-end：交叉轴的终点对齐。<br>&#x2F;&#x2F; center：交叉轴的中点对齐。<br>&#x2F;&#x2F; baseline: 项目的第一行文字的基线对齐。<br>&#x2F;&#x2F; stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。<br></code></pre></td></tr></table></figure></li><li><p>align-content 定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs plain">.box &#123;<br>  align-content: flex-start | flex-end | center | space-between | space-around | stretch;<br>&#125;<br>&#x2F;&#x2F; flex-start：与交叉轴的起点对齐。<br>&#x2F;&#x2F; flex-end：与交叉轴的终点对齐。<br>&#x2F;&#x2F; center：与交叉轴的中点对齐。<br>&#x2F;&#x2F; space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。<br>&#x2F;&#x2F; space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。<br>&#x2F;&#x2F; stretch（默认值）：轴线占满整个交叉轴。<br></code></pre></td></tr></table></figure><h3>项目有6个属性</h3></li><li><p>order 定义项目的排列顺序。数值越小，排列越靠前，默认为0。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">.item &#123;<br>  order: &lt;integer&gt;;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">.item &#123;<br>  flex-grow: &lt;number&gt;; &#x2F;* default 0 *&#x2F;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>flex-shrink 定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。负值对该属性无效</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">.item &#123;<br>  flex-shrink: &lt;number&gt;; &#x2F;* default 1 *&#x2F;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>flex-basis 在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">.item &#123;<br>  flex-basis: &lt;length&gt; | auto; &#x2F;* default auto *&#x2F;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>flex 是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plain">.item &#123;<br>  flex: none | [ &lt;&#39;flex-grow&#39;&gt; &lt;&#39;flex-shrink&#39;&gt;? || &lt;&#39;flex-basis&#39;&gt; ]<br>&#125;<br>&#x2F;&#x2F; 该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)<br></code></pre></td></tr></table></figure></li><li><p>align-self 允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plain">.item &#123;<br>  align-self: auto | flex-start | flex-end | center | baseline | stretch;<br>&#125;<br>&#x2F;&#x2F; 除了auto，其他都与align-items属性完全一致<br></code></pre></td></tr></table></figure></li></ul><h3>BFC是什么？</h3><p>BFC 即 Block Formatting Contexts (块级格式化上下文)，它属于普通流，即：元素按照其在 HTML 中的先后位置至上而下布局，在这个过程中，行内元素水平排列，直到当行被占满然后换行，块级元素则会被渲染为完整的一个新行，除非另外指定，否则所有元素默认都是普通流定位，也可以说，普通流中元素的位置由该元素在 HTML 文档中的位置决定。<br>可以把 BFC 理解为一个封闭的大箱子，箱子内部的元素无论如何翻江倒海，都不会影响到外部。</p><p>只要元素满足下面任一条件即可触发 BFC 特性</p><ul><li>body 根元素</li><li>浮动元素：float 除 none 以外的值</li><li>绝对定位元素：position (absolute、fixed)</li><li>display 为 inline-block、table-cells、flex</li><li>overflow 除了 visible 以外的值 (hidden、auto、scroll)</li></ul><h3>前端鉴权是怎么实现的？</h3>参考下： https://segmentfault.com/a/1190000012675759<h3>什么是mvvm？</h3><p>MVVM分为Model、View、ViewModel三者。</p><p>Model 代表数据模型，数据和业务逻辑都在Model层中定义；</p><p>View 代表UI视图，负责数据的展示；<br>ViewModel 负责监听 Model 中数据的改变并且控制视图的更新，处理用户交互操作；<br>Model 和 View 并无直接关联，而是通过 ViewModel 来进行联系的，Model 和 ViewModel 之间有着双向数据绑定的联系。<br>这种模式实现了 Model 和 View 的数据自动同步，因此开发者只需要专注对数据的维护操作即可，而不需要自己操作 dom。</p><h3>写 React/Vue 项目时为什么要在组件中写 key，其作用是什么？</h3><p>key 的作用是为了在 diff 算法执行时更快的找到对应的节点，提高 diff 速度。</p><h3>解析 ['1', '2', '3'].map(parseInt)</h3><p>答案：[1, NaN, NaN]<br>这个 callback 一共可以接收三个参数，其中第一个参数代表当前被处理的元素，而第二个参数代表该元素的索引。<br>而 parseInt 则是用来解析字符串的，使字符串成为指定基数的整数。<br>parseInt(string, radix)接收两个参数，第一个表示被处理的值（字符串），第二个表示为解析时的基数。<br>了解这两个函数后，我们可以模拟一下运行情况；<br>parseInt(‘1’, 0) //radix 为 0 时，且 string 参数不以“0x”和“0”开头时，按照 10 为基数处理。这个时候返回 1；<br>parseInt(‘2’, 1) // 基数为 1（1 进制）表示的数中，最大值小于 2，所以无法解析，返回 NaN；<br>parseInt(‘3’, 2) // 基数为 2（2 进制）表示的数中，最大值小于 3，所以无法解析，返回 NaN。<br>map 函数返回的是一个数组，所以最后结果为 [1, NaN, NaN]。</p><h3>什么是防抖和节流？有什么区别？如何实现？</h3><p>1)防抖<br>触发高频事件后 n 秒内函数只会执行一次，如果 n 秒内高频事件再次被触发，则重新计算时间；<br>思路：每次触发事件时都取消之前的延时调用方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs plain">function debounce(fn) &#123;<br>  let timeout &#x3D; null; &#x2F;&#x2F; 创建一个标记用来存放定时器的返回值<br>  return function () &#123;<br>    clearTimeout(timeout); &#x2F;&#x2F; 每当用户输入的时候把前一个 setTimeout clear 掉<br>    timeout &#x3D; setTimeout(() &#x3D;&gt; &#123; &#x2F;&#x2F; 然后又创建一个新的 setTimeout, 这样就能保证输入字符后的 interval 间隔内如果还有字符输入的话，就不会执行 fn 函数<br>      fn.apply(this, arguments);<br>    &#125;, 500);<br>  &#125;;<br>&#125;<br>function sayHi() &#123;<br>  console.log(&#39;防抖成功&#39;);<br>&#125;<br>var inp &#x3D; document.getElementById(&#39;inp&#39;);<br>inp.addEventListener(&#39;input&#39;, debounce(sayHi)); &#x2F;&#x2F; 防抖<br></code></pre></td></tr></table></figure><p>2)节流</p><p>高频事件触发，但在 n 秒内只会执行一次，所以节流会稀释函数的执行频率。<br>思路：每次触发事件时都判断当前是否有等待执行的延时函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs plain">function throttle(fn) &#123;<br>  let canRun &#x3D; true; &#x2F;&#x2F; 通过闭包保存一个标记<br>  return function () &#123;<br>    if (!canRun) return; &#x2F;&#x2F; 在函数开头判断标记是否为 true，不为 true 则 return<br>    canRun &#x3D; false; &#x2F;&#x2F; 立即设置为 false<br>    setTimeout(() &#x3D;&gt; &#123; &#x2F;&#x2F; 将外部传入的函数的执行放在 setTimeout 中<br>      fn.apply(this, arguments);<br>      &#x2F;&#x2F; 最后在 setTimeout 执行完毕后再把标记设置为 true(关键) 表示可以执行下一次循环了。当定时器没有执行的时候标记永远是 false，在开头被 return 掉<br>      canRun &#x3D; true;<br>    &#125;, 500);<br>  &#125;;<br>&#125;<br>function sayHi(e) &#123;<br>  console.log(e.target.innerWidth, e.target.innerHeight);<br>&#125;<br>window.addEventListener(&#39;resize&#39;, throttle(sayHi));<br></code></pre></td></tr></table></figure><h3>介绍下 Set、Map、WeakSet 和 WeakMap 的区别？</h3><p>1)Set</p><p>成员唯一、无序且不重复；<br>[value, value]，键值与键名是一致的（或者说只有键值，没有键名）;<br>可以遍历，方法有：add、delete、has。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plain">const s &#x3D; new Set();<br>[2, 3, 5, 4, 5, 2, 2].forEach(x &#x3D;&gt; s.add(x));<br>for (let i of s) &#123;<br>  console.log(i);<br>&#125;<br>&#x2F;&#x2F; 2 3 5 4<br></code></pre></td></tr></table></figure><p>2)WeakSet</p><p>成员都是对象；<br>成员都是弱引用，可以被垃圾回收机制回收，可以用来保存 DOM 节点，不容易造成内存泄漏；<br>不能遍历，方法有 add、delete、has。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plain">const a &#x3D; [[1, 2], [3, 4]];<br>const ws &#x3D; new WeakSet(a);<br>&#x2F;* WeakSet &#123;[1, 2], [3, 4]&#125; *&#x2F;<br>const b &#x3D; [3, 4];<br>const ws &#x3D; new WeakSet(b);<br>&#x2F;&#x2F; Uncaught TypeError: Invalid value used in weak set(…)<br></code></pre></td></tr></table></figure><p>3)Map</p><p>本质上是键值对的集合，类似集合；<br>可以遍历，方法很多，可以跟各种数据格式转换。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plain">const m &#x3D; new Map();<br> <br>m.set(&#39;edition&#39;, 6)        &#x2F;&#x2F; 键是字符串<br>m.set(262, &#39;standard&#39;)     &#x2F;&#x2F; 键是数值<br>m.set(undefined, &#39;nah&#39;)    &#x2F;&#x2F; 键是 undefined<br></code></pre></td></tr></table></figure><p>4)WeakMap</p><p>只接受对象最为键名（null 除外），不接受其他类型的值作为键名；<br>键名是弱引用，键值可以是任意的，键名所指向的对象可以被垃圾回收，此时键名是无效的；<br>不能遍历，方法有 get、set、has、delete。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs plain">&#x2F;* WeakMap 可以使用 set 方法添加成员 *&#x2F;<br>const wm1 &#x3D; new WeakMap();<br>const key &#x3D; &#123;foo: 1&#125;;<br>wm1.set(key, 2);<br>wm1.get(key) &#x2F;* 2 *&#x2F;<br>&#x2F;* WeakMap 也可以接受一个数组 *&#x2F;<br>&#x2F;* 作为构造函数的参数 *&#x2F;<br>const k1 &#x3D; [1, 2, 3];<br>const k2 &#x3D; [4, 5, 6];<br>const wm2 &#x3D; new WeakMap([[k1, &#39;foo&#39;], [k2, &#39;bar&#39;]]);<br>wm2.get(k2) &#x2F;*  &quot;bar *&#x2F;<br><br>const map &#x3D; new WeakMap();<br>map.set(1, 2)<br>&#x2F;* TypeError: 1 is not an object! *&#x2F;<br>map.set(Symbol(), 2)<br>&#x2F;* TypeError: Invalid value used as weak map key *&#x2F;<br>map.set(null, 2)<br>&#x2F;* TypeError: Invalid value used as weak map key *&#x2F;<br></code></pre></td></tr></table></figure><h3>问题：下面输出的顺序</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs plain">async function async1() &#123;<br>   console.log(&#39;async1 start&#39;)<br>   await async2()<br>   console.log(&#39;async1 end&#39;)<br>&#125;<br>async function async2() &#123;<br>   console.log(&#39;async2&#39;)<br>&#125;<br><br>console.log(&#39;script start&#39;)<br>setTimeout(function () &#123;<br>   console.log(&#39;settimeout&#39;)<br>&#125;)<br>async1()<br>new Promise(function (resolve) &#123;<br>   console.log(&#39;promise1&#39;)<br>   resolve()<br>&#125;).then(function () &#123;<br>   console.log(&#39;promise2&#39;)<br>&#125;)<br>console.log(&#39;script end&#39;)<br><br>script start<br>async1 start<br>async2<br>promise1<br>script end<br>async1 end<br>promise2<br>settimeout<br></code></pre></td></tr></table></figure><h3>JS 异步解决方案的发展历程以及优缺点。</h3><p>1)回调函数（callback）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">setTimeout(() &#x3D;&gt; &#123;<br>     &#x2F;&#x2F; callback 函数体<br>&#125;, 1000)<br></code></pre></td></tr></table></figure><p>缺点：回调地狱，不能用 try catch 捕获错误，不能 return<br>回调地狱的根本问题在于：<br>缺乏顺序性： 回调地狱导致的调试困难，和大脑的思维方式不符；<br>嵌套函数存在耦合性，一旦有所改动，就会牵一发而动全身，即（控制反转）；<br>嵌套函数过多的多话，很难处理错误。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs plain">ajax(&#39;XXX1&#39;, () &#x3D;&gt; &#123;<br>     &#x2F;&#x2F; callback 函数体<br>   ajax(&#39;XXX2&#39;, () &#x3D;&gt; &#123;<br>         &#x2F;&#x2F; callback 函数体<br>       ajax(&#39;XXX3&#39;, () &#x3D;&gt; &#123;<br>             &#x2F;&#x2F; callback 函数体<br>       &#125;)<br>   &#125;)<br>&#125;)<br></code></pre></td></tr></table></figure><p>优点：解决了同步的问题（只要有一个任务耗时很长，后面的任务都必须排队等着，会拖延整个程序的执行）。</p><p>2)Promise</p><p>Promise 就是为了解决 callback 的问题而产生的。<br>Promise 实现了链式调用，也就是说每次 then 后返回的都是一个全新 Promise，如果我们在 then 中 return ，return 的结果会被 Promise.resolve() 包装。<br>优点：解决了回调地狱的问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs plain">ajax(&#39;XXX1&#39;)<br>.then(res &#x3D;&gt; &#123;<br>      &#x2F;&#x2F; 操作逻辑<br>    return ajax(&#39;XXX2&#39;)<br>&#125;).then(res &#x3D;&gt; &#123;<br>      &#x2F;&#x2F; 操作逻辑<br>    return ajax(&#39;XXX3&#39;)<br>&#125;).then(res &#x3D;&gt; &#123;<br>      &#x2F;&#x2F; 操作逻辑<br>&#125;)<br></code></pre></td></tr></table></figure><p>缺点：无法取消 Promise ，错误需要通过回调函数来捕获。</p><p>3)Generator</p><p>特点：可以控制函数的执行，可以配合 co 函数库使用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs plain">function *fetch() &#123;<br>   yield ajax(&#39;XXX1&#39;, () &#x3D;&gt; &#123;&#125;)<br>   yield ajax(&#39;XXX2&#39;, () &#x3D;&gt; &#123;&#125;)<br>   yield ajax(&#39;XXX3&#39;, () &#x3D;&gt; &#123;&#125;)<br>&#125;<br>let it &#x3D; fetch()<br>let result1 &#x3D; it.next()<br>let result2 &#x3D; it.next()<br>let result3 &#x3D; it.next()<br></code></pre></td></tr></table></figure><p>4)Async/await</p><p>async、await 是异步的终极解决方案。<br>优点是：代码清晰，不用像 Promise 写一大堆 then 链，处理了回调地狱的问题；<br>缺点：await 将异步代码改造成同步代码，如果多个异步操作没有依赖性而使用 await 会导致性能上的降低。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plain">async function test() &#123;<br> &#x2F;&#x2F; 以下代码没有依赖性的话，完全可以使用 Promise.all 的方式<br> &#x2F;&#x2F; 如果有依赖性的话，其实就是解决回调地狱的例子了<br> await fetch(&#39;XXX1&#39;)<br> await fetch(&#39;XXX2&#39;)<br> await fetch(&#39;XXX3&#39;)<br>&#125;<br></code></pre></td></tr></table></figure><p>下面来看一个使用 await 的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs plain">let a &#x3D; 0<br>let b &#x3D; async () &#x3D;&gt; &#123;<br>   a &#x3D; a + await 10<br>   console.log(&#39;2&#39;, a) &#x2F;* -&gt; &#39;2&#39; 10 *&#x2F;<br>&#125;<br>b()<br>a++<br>console.log(&#39;1&#39;, a) &#x2F;&#x2F; -&gt; &#39;1&#39; 1<br></code></pre></td></tr></table></figure><p>对于以上代码你可能会有疑惑，让我来解释下原因：<br>首先函数 b 先执行，在执行到 await 10 之前变量 a 还是 0，因为 await 内部实现了 generator ，generator 会保留堆栈中东西，所以这时候 a = 0 被保存了下来；<br>因为 await 是异步操作，后来的表达式不返回 Promise 的话，就会包装成 Promise.reslove(返回值)，然后会去执行函数外的同步代码；<br>同步代码执行完毕后开始执行异步代码，将保存下来的值拿出来使用，这时候 a = 0 + 10。<br>上述解释中提到了 await 内部实现了 generator，其实 await 就是 generator 加上 Promise的语法糖，且内部实现了自动执行 generator。如果你熟悉 co 的话，其实自己就可以实现这样的语法糖。</p><h3>谈谈你对 TCP 三次握手和四次挥手的理解</h3><p><img src="/2020/05/13/%E9%9D%A2%E8%AF%95%E9%A2%982/01.png" alt></p><h3>前端如何优化网站性能？</h3><p>1、减少 HTTP 请求数量</p><p>在浏览器与服务器进行通信时，主要是通过 HTTP 进行通信。浏览器与服务器需要经过三次握手，每次握手需要花费大量时间。而且不同浏览器对资源文件并发请求数量有限（不同浏览器允许并发数），一旦 HTTP 请求数量达到一定数量，资源请求就存在等待状态，这是很致命的，因此减少 HTTP 的请求数量可以很大程度上对网站性能进行优化。</p><p>CSS Sprites</p><p>国内俗称CSS精灵，这是将多张图片合并成一张图片达到减少HTTP请求的一种解决方案，可以通过CSS的background属性来访问图片内容。这种方案同时还可以减少图片总字节数。</p><p>合并 CSS 和 JS 文件</p><p>现在前端有很多工程化打包工具，如：grunt、gulp、webpack等。为了减少 HTTP 请求数量，可以通过这些工具再发布前将多个CSS或者多个JS合并成一个文件。</p><p>采用 lazyLoad</p><p>俗称懒加载，可以控制网页上的内容在一开始无需加载，不需要发请求，等到用户操作真正需要的时候立即加载出内容。这样就控制了网页资源一次性请求数量。</p><p>2、控制资源文件加载优先级</p><p>浏览器在加载HTML内容时，是将HTML内容从上至下依次解析，解析到link或者script标签就会加载href或者src对应链接内容，为了第一时间展示页面给用户，就需要将CSS提前加载，不要受 JS 加载影响。</p><p>一般情况下都是CSS在头部，JS在底部。</p><p>3、利用浏览器缓存</p><p>浏览器缓存是将网络资源存储在本地，等待下次请求该资源时，如果资源已经存在就不需要到服务器重新请求该资源，直接在本地读取该资源。</p><p>4、减少重排（Reflow）</p><p>基本原理：重排是DOM的变化影响到了元素的几何属性（宽和高），浏览器会重新计算元素的几何属性，会使渲染树中受到影响的部分失效，浏览器会验证 DOM 树上的所有其它结点的visibility属性，这也是Reflow低效的原因。如果Reflow的过于频繁，CPU使用率就会急剧上升。</p><p>减少Reflow，如果需要在DOM操作时添加样式，尽量使用 增加class属性，而不是通过style操作样式。</p><p>5、减少 DOM 操作</p><p>6、图标使用 IconFont 替换</p><h3>网页从输入网址到渲染完成经历了哪些过程？</h3><p>大致可以分为如下7步：</p><p>输入网址；</p><p>发送到DNS服务器，并获取域名对应的web服务器对应的ip地址；</p><p>与web服务器建立TCP连接；</p><p>浏览器向web服务器发送http请求；</p><p>web服务器响应请求，并返回指定url的数据（或错误信息，或重定向的新的url地址）；</p><p>浏览器下载web服务器返回的数据及解析html源文件；</p><p>生成DOM树，解析css和js，渲染页面，直至显示完成；</p><h3>jQuery获取的dom对象和原生的dom对象有何区别？</h3><p>js原生获取的dom是一个对象，jQuery对象就是一个数组对象，其实就是选择出来的元素的数组集合，所以说他们两者是不同的对象类型不等价。</p><p>原生DOM对象转jQuery对象：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">var box &#x3D; document.getElementById(&#39;box&#39;);<br>var $box &#x3D; $(box);<br></code></pre></td></tr></table></figure><p>jQuery对象转原生DOM对象：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">var $box &#x3D; $(&#39;#box&#39;);<br>var box &#x3D; $box[0];<br></code></pre></td></tr></table></figure><h3>jQuery如何扩展自定义方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs plain">(jQuery.fn.myMethod&#x3D;function () &#123;<br>      alert(&#39;myMethod&#39;);<br>&#125;)<br>&#x2F;&#x2F; 或者：<br>(function ($) &#123;<br>       $.fn.extend(&#123;<br>            myMethod : function () &#123;<br>                 alert(&#39;myMethod&#39;);<br>            &#125;<br>       &#125;)<br>&#125;)(jQuery)<br></code></pre></td></tr></table></figure><h3>使以下代码正常运行</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plain">JavaScript 代码:<br>const a &#x3D; [1, 2, 3, 4, 5];<br>a.multiply();<br>console.log(a); &#x2F;&#x2F; [1, 2, 3, 4, 5, 1, 4, 9, 16, 25]<br></code></pre></td></tr></table></figure><p>答案：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plain">Araay.protitype.multiply &#x3D; function() &#123;<br>  this.forEach((ele) &#x3D;&gt; &#123;<br>    this.push(Math.pow(ele, 2));<br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><h3>使以下代码正常运行</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3&gt;css实现图片自适应宽高&lt;/h3&gt;

&lt;p&gt;img {&lt;br&gt;  max-width: 100%;&lt;br&gt;  max-height: 100%;&lt;br&gt;}&lt;/p&gt;
&lt;h3&gt;什么是flex，写出常见属性，以及作用&lt;/h3&gt;

&lt;p&gt;Flex即：Flexible Box，弹性
      
    
    </summary>
    
    
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>JS模块规范：AMD，CMD，CommonJS</title>
    <link href="http://yoursite.com/2020/04/27/JS%E6%A8%A1%E5%9D%97%E8%A7%84%E8%8C%83%EF%BC%9AAMD%EF%BC%8CCMD%EF%BC%8CCommonJS/"/>
    <id>http://yoursite.com/2020/04/27/JS%E6%A8%A1%E5%9D%97%E8%A7%84%E8%8C%83%EF%BC%9AAMD%EF%BC%8CCMD%EF%BC%8CCommonJS/</id>
    <published>2020-04-27T08:53:03.000Z</published>
    <updated>2020-04-28T01:39:51.683Z</updated>
    
    <content type="html"><![CDATA[<h1>浅析JS模块规范</h1><p>随着JS模块化编程的发展，处理模块之间的依赖关系成为了维护的关键。<br>AMD,CMD,CommonJS是目前最常用的三种模块化书写规范。</p><h3>CommonJS</h3><p>CommonJS规范是诞生比较早的。NodeJS就采用了CommonJS。是这样加载模块：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">var modA&#x3D; require(&#39;modA&#39;);<br>modA.start();<br></code></pre></td></tr></table></figure><p>这种写法适合服务端，因为在服务器读取模块都是在本地磁盘，加载速度很快。但是如果在客户端，加载模块的时候有可能出现“假死”状况。比如上面的例子中clock的调用必须等待clock.js请求成功，加载完毕。那么，能不能异步加载模块呢？</p><h3>AMD</h3><p>AMD，即 (Asynchronous Module Definition)，这种规范是异步的加载模块，requireJs应用了这一规范。先定义所有依赖，然后在加载完成后的回调函数中执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">require([module], callback);<br></code></pre></td></tr></table></figure><p>用AMD写上一个模块：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">require([&#39;modA&#39;],function(modA)&#123;<br>  modA.start();<br>&#125;);<br></code></pre></td></tr></table></figure><p>AMD虽然实现了异步加载，但是开始就把所有依赖写出来是不符合书写的逻辑顺序的，能不能像commonJS那样用的时候再require，而且还支持异步加载后再执行呢？</p><h3>CMD</h3><p>CMD (Common Module Definition), 是seajs推崇的规范，CMD则是依赖就近，用的时候再require。它写起来是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plain">define(function(require, exports, module) &#123;<br>   var modA&#x3D; require(&#39;modA&#39;);<br>   modA.start();<br>&#125;);<br></code></pre></td></tr></table></figure><p>AMD和CMD最大的区别是对依赖模块的执行时机处理不同，而不是加载的时机或者方式不同，二者皆为异步加载模块。<br>AMD依赖前置，js可以方便知道依赖模块是谁，立即加载；而CMD就近依赖，需要使用把模块变为字符串解析一遍才知道依赖了那些模块，这也是很多人诟病CMD的一点，牺牲性能来带来开发的便利性，实际上解析模块用的时间短到可以忽略。</p><h1>深入解析JS模块规范</h1><h3>无模块时代</h3><p>在ajax还未提出之前，js还只是一种“玩具语言”，由Brendan Eich花了不到十天时间发明，用来在网页上进行表单校验、实现简单的动画效果等等，你可以回想一下那个网页上到处有公告块飘来飘去的时代。<br>这个时候并没有前端工程师，服务端工程师只需在页面上随便写写js就能搞定需求。那个时候的前端代码大概像这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs plain">if(xx)&#123;<br>     &#x2F;&#x2F;.......<br>&#125;<br>else&#123;<br>     &#x2F;&#x2F;xxxxxxxxxxx<br>&#125;<br>for(var i&#x3D;0; i&lt;10; i++)&#123;<br>     &#x2F;&#x2F;........<br>&#125;<br>element.onclick &#x3D; function()&#123;<br>     &#x2F;&#x2F;.......<br>&#125;<br></code></pre></td></tr></table></figure><p>代码简单的堆在一起，只要能从上往下依次执行就可以了。</p><h3>模块萌芽时代</h3><p>2006年，ajax的概念被提出，前端拥有了主动向服务端发送请求并操作返回数据的能力，随着Google将此概念的发扬光大，传统的网页慢慢的向“富客户端”发展。前端的业务逻辑越来越多，代码也越来越多，于是一些问题就暴漏了出来：</p><h5>1. 全局变量的灾难</h5><p>小明定义了 i=1<br>小刚在后续的代码里：i=0<br>小明在接下来的代码里：if(i==1){…} //悲剧</p><h5>2. 函数命名冲突</h5><p>项目中通常会把一些通用的函数封装成一个文件，常见的名字有utils.js、common.js…<br>小明定义了一个函数：function formatData(){   }<br>小刚想实现类似功能，于是这么写：function formatData2(){   }<br>小光又有一个类似功能，于是：function formatData3(){   }<br>……<br>避免命名冲突就只能这样靠丑陋的方式人肉进行。</p><h5>3. 依赖关系不好管理</h5><p>b.js依赖a.js，标签的书写顺序必须是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;a.js&quot;&gt;&lt;&#x2F;script&gt;<br>&lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;b.js&quot;&gt;&lt;&#x2F;script&gt;<br></code></pre></td></tr></table></figure><p>顺序不能错，也不能漏写某个。在多人开发的时候很难协调。</p><h3>萌芽时代的解决方案：</h3><h5>1. 用自执行函数来包装代码</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs plain">modA &#x3D; function()&#123;<br>     var a,b; &#x2F;*变量a、b外部不可见*&#x2F;<br>     return &#123;<br>          add : function(c)&#123;<br>               a + b + c;<br>          &#125;,<br>          format: function()&#123;<br>               ......<br>          &#125;<br>     &#125;<br>&#125;()<br></code></pre></td></tr></table></figure><p>这样function内部的变量就对全局隐藏了，达到是封装的目的。但是这样还是有缺陷的，modA这个变量还是暴漏到全局了，随着模块的增多，全局变量还是会越来越多。</p><h5>2. java风格的命名空间</h5><p>为了避免全局变量造成的冲突，人们想到或许可以用多级命名空间来进行管理，于是，代码就变成了这个风格：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">app.util.modA &#x3D; xxx;<br>app.tools.modA &#x3D; xxx;<br>app.tools.modA.format &#x3D; xxx;<br></code></pre></td></tr></table></figure><p>Yahoo的YUI早期就是这么做的，调用的时候不得不这么写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">app.tools.modA.format();<br></code></pre></td></tr></table></figure><p>这样调用函数，写写都会觉得恶心，所以这种方式并没有被很多人采用，YUI后来也不用这种方式了。</p><h5>3. jQuery风格的匿名自执行函数</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plain">(function(window)&#123;<br>    &#x2F;*代码*&#x2F;<br><br>    window.jQuery &#x3D; window.$ &#x3D; jQuery;&#x2F;*通过给window添加属性而暴漏到全局*&#x2F;<br>&#125;)(window);<br></code></pre></td></tr></table></figure><p>jQuery的封装风格曾经被很多框架模仿，通过匿名函数包装代码，所依赖的外部变量传给这个函数，在函数内部可以使用这些依赖，然后在函数的最后把模块自身暴漏给window。<br>如果需要添加扩展，则可以作为jQuery的插件，把它挂载到$上。<br>这种风格虽然灵活了些，但并未解决根本问题：所需依赖还是得外部提前提供、还是增加了全局变量。</p><h3>模块化面临什么问题</h3><p>从以上的尝试中，可以归纳出js模块化需要解决那些问题：</p><ol><li>如何安全的包装一个模块的代码？（不污染模块外的任何代码）</li><li>如何唯一标识一个模块？</li><li>如何优雅的把模块的API暴漏出去？（不能增加全局变量）</li><li>如何方便的使用所依赖的模块？<br>围绕着这些问题，js模块化开始了一段艰苦而曲折的征途。</li></ol><h3>源自nodejs的规范CommonJs</h3><p>2009年，nodejs横空出世，开创了一个新纪元，人们可以用js来编写服务端的代码了。如果说浏览器端的js即便没有模块化也可以忍的话，那服务端是万万不能的。<br>大牛云集的CommonJs社区发力，制定了Modules/1.0（<a href="http://wiki.commonjs.org/wiki/Modules/1.0）规范，首次定义了一个模块应该长啥样。具体来说，Modules/1.0规范包含以下内容：" target="_blank" rel="noopener">http://wiki.commonjs.org/wiki/Modules/1.0）规范，首次定义了一个模块应该长啥样。具体来说，Modules/1.0规范包含以下内容：</a></p><ol><li>模块的标识应遵循的规则（书写规范）</li><li>定义全局函数require，通过传入模块标识来引入其他模块，执行的结果即为别的模块暴漏出来的API</li><li>如果被require函数引入的模块中也包含依赖，那么依次加载这些依赖</li><li>如果引入模块失败，那么require函数应该报一个异常</li><li>模块通过变量exports来向往暴漏API，exports只能是一个对象，暴漏的API须作为此对象的属性。</li></ol><p>此规范一出，立刻产生了良好的效果，由于其简单而直接，在nodejs中，这种模块化方案立刻被推广开了。<br>遵循commonjs规范的代码看起来是这样的：（来自官方的例子）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs plain">&#x2F;&#x2F;math.js<br>exports.add &#x3D; function() &#123;<br>    var sum &#x3D; 0, i &#x3D; 0, args &#x3D; arguments, l &#x3D; args.length;<br>    while (i &lt; l) &#123;<br>        sum +&#x3D; args[i++];<br>    &#125;<br>    return sum;<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs plain">&#x2F;&#x2F;increment.js<br>var add &#x3D; require(&#39;math&#39;).add;<br>exports.increment &#x3D; function(val) &#123;<br>    return add(val, 1);<br>&#125;;<br>&#x2F;&#x2F;program.js<br>var inc &#x3D; require(&#39;increment&#39;).increment;<br>var a &#x3D; 1;<br>inc(a); &#x2F;&#x2F; 2<br></code></pre></td></tr></table></figure><h3>服务端向前端进军</h3><p>Modules/1.0规范源于服务端，无法直接用于浏览器端，原因表现为：</p><ol><li>外层没有function包裹，变量全暴漏在全局。如上面例子中increment.js中的add。</li><li>资源的加载方式与服务端完全不同。服务端require一个模块，直接就从硬盘或者内存中读取了，消耗的时间可以忽略。而浏览器则不同，需要从服务端来下载这个文件，然后运行里面的代码才能得到API，需要花费一个http请求，也就是说，require后面的一行代码，需要资源请求完成才能执行。由于浏览器端是以插入script标签的形式来加载资源的（ajax方式不行，有跨域问题），没办法让代码同步执行，所以像commonjs那样的写法会直接报错。</li></ol><p>所以，社区意识到，要想在浏览器环境中也能模块化，需要对规范进行升级。顺便说一句，CommonJs原来是叫ServerJs，从名字可以看出是专攻服务端的，为了统一前后端而改名CommonJs。（论起名的重要性~）<br>而就在社区讨论制定下一版规范的时候，内部发生了比较大的分歧，分裂出了三个主张，渐渐的形成三个不同的派别：</p><ol><li>Modules/1.x派<br>这一波人认为，在现有基础上进行改进即可满足浏览器端的需要，既然浏览器端需要function包装，需要异步加载，那么新增一个方案，能把现有模块转化为适合浏览器端的就行了，有点像“保皇派”。基于这个主张，制定了Modules/Transport（<a href="http://wiki.commonjs.org/wiki/Modules/Transport）规范，提出了先通过工具把现有模块转化为复合浏览器上使用的模块，然后再使用的方案。" target="_blank" rel="noopener">http://wiki.commonjs.org/wiki/Modules/Transport）规范，提出了先通过工具把现有模块转化为复合浏览器上使用的模块，然后再使用的方案。</a><br>browserify就是这样一个工具，可以把nodejs的模块编译成浏览器可用的模块。（Modules/Transport规范晦涩难懂，我也不确定browserify跟它是何关联，有知道的朋友可以讲一下）<br>目前的最新版是Modules/1.1.1（<a href="http://wiki.commonjs.org/wiki/Modules/1.1.1），增加了一些require的属性，以及模块内增加module变量来描述模块信息，变动不大。" target="_blank" rel="noopener">http://wiki.commonjs.org/wiki/Modules/1.1.1），增加了一些require的属性，以及模块内增加module变量来描述模块信息，变动不大。</a></li><li>Modules/Async派<br>这一波人有点像“革新派”，他们认为浏览器与服务器环境差别太大，不能沿用旧的模块标准。既然浏览器必须异步加载代码，那么模块在定义的时候就必须指明所依赖的模块，然后把本模块的代码写在回调函数里。模块的加载也是通过下载-回调这样的过程来进行，这个思想就是AMD的基础，由于“革新派”与“保皇派”的思想无法达成一致，最终从CommonJs中分裂了出去，独立制定了浏览器端的js模块化规范AMD（Asynchronous Module Definition）（<a href="https://github.com/amdjs/amdjs-api/wiki/AMD）" target="_blank" rel="noopener">https://github.com/amdjs/amdjs-api/wiki/AMD）</a><br>本文后续会继续讨论AMD规范的内容。</li><li>Modules/2.0派<br>这一波人有点像“中间派”，既不想丢掉旧的规范，也不想像AMD那样推到重来。他们认为，Modules/1.0固然不适合浏览器，但它里面的一些理念还是很好的，（如通过require来声明依赖），新的规范应该兼容这些，AMD规范也有它好的地方（例如模块的预先加载以及通过return可以暴漏任意类型的数据，而不是像commonjs那样exports只能为object），也应采纳。最终他们制定了一个Modules/Wrappings（<a href="http://wiki.commonjs.org/wiki/Modules/Wrappings）规范，此规范指出了一个模块应该如何“包装”，包含以下内容：" target="_blank" rel="noopener">http://wiki.commonjs.org/wiki/Modules/Wrappings）规范，此规范指出了一个模块应该如何“包装”，包含以下内容：</a></li></ol><ul><li>全局有一个module变量，用来定义模块</li><li>通过module.declare方法来定义一个模块</li><li>module.declare方法只接收一个参数，那就是模块的factory，次factory可以是函数也可以是对象，如果是对象，那么模块输出就是此对象。</li><li>模块的factory函数传入三个参数：require,exports,module，用来引入其他依赖和导出本模块API</li><li>如果factory函数最后明确写有return数据（js函数中不写return默认返回undefined），那么return的内容即为模块的输出。<br>使用该规范的例子看起来像这样：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs plain">&#x2F;&#x2F;可以使用exprots来对外暴漏API<br>module.declare(function(require, exports, module)<br>&#123;<br>    exports.foo &#x3D; &quot;bar&quot;;<br>&#125;);<br>&#x2F;&#x2F;也可以直接return来对外暴漏数据<br>module.declare(function(require)<br>&#123;<br>return &#123; foo: &quot;bar&quot; &#125;;<br>&#125;);<br></code></pre></td></tr></table></figure></li></ul><h3>AMD/RequireJs的崛起与妥协</h3> <p>AMD的思想正如其名，异步加载所需的模块，然后在回调函数中执行主逻辑。这正是我们在浏览器端开发所习惯了的方式，其作者亲自实现了符合AMD规范的requirejs，AMD/RequireJs迅速被广大开发者所接受。<br>AMD规范包含以下内容：</p><ol><li>用全局函数define来定义模块，用法为：define(id?, dependencies?, factory);</li><li>id为模块标识，遵从CommonJS Module Identifiers规范</li><li>dependencies为依赖的模块数组，在factory中需传入形参与之一一对应</li><li>如果dependencies的值中有”require”、”exports”或”module”，则与commonjs中的实现保持一致</li><li>如果dependencies省略不写，则默认为[“require”, “exports”, “module”]，factory中也会默认传入require,exports,module</li><li>如果factory为函数，模块对外暴漏API的方法有三种：return任意类型的数据、exports.xxx=xxx、module.exports=xxx</li><li>如果factory为对象，则该对象即为模块的返回值</li></ol><p>基于以上几点基本规范，我们便可以用这样的方式来进行模块化组织代码了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs plain">&#x2F;&#x2F;a.js<br>define(function()&#123;<br>     console.log(&#39;a.js执行&#39;);<br>     return &#123;<br>          hello: function()&#123;<br>               console.log(&#39;hello, a.js&#39;);<br>          &#125;<br>     &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs plain">&#x2F;&#x2F;b.js<br>define(function()&#123;<br>     console.log(&#39;b.js执行&#39;);<br>     return &#123;<br>          hello: function()&#123;<br>               console.log(&#39;hello, b.js&#39;);<br>          &#125;<br>     &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs plain">&#x2F;&#x2F;main.js<br>require([&#39;a&#39;, &#39;b&#39;], function(a, b)&#123;<br>     console.log(&#39;main.js执行&#39;);<br>     a.hello();<br>     $(&#39;#b&#39;).click(function()&#123;<br>          b.hello();<br>     &#125;);<br>&#125;)<br></code></pre></td></tr></table></figure><p>上面的main.js被执行的时候，会有如下的输出：<br>a.js执行<br>b.js执行<br>main.js执行<br>hello, a.js<br>在点击按钮后，会输出：<br>hello, b.js<br>这结局，如你所愿吗？大体来看，是没什么问题的，因为你要的两个hello方法都正确的执行了。<br>但是如果细细来看，b.js被预先加载并且预先执行了，（第二行输出），b.hello这个方法是在点击了按钮之后才会执行，如果用户压根就没点，那么b.js中的代码应不应该执行呢？<br>这其实也是AMD/RequireJs被吐槽的一点，预先下载没什么争议，由于浏览器的环境特点，被依赖的模块肯定要预先下载的。问题在于，是否需要预先执行？如果一个模块依赖了十个其他模块，那么在本模块的代码执行之前，要先把其他十个模块的代码都执行一遍，不管这些模块是不是马上会被用到。这个性能消耗是不容忽视的。<br>另一点被吐槽的是，在定义模块的时候，要把所有依赖模块都罗列一遍，而且还要在factory中作为形参传进去，要写两遍很大一串模块名称，像这样：`</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">define([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;, &#39;g&#39;], function(a, b, c, d, e, f, g)&#123;  ..... &#125;)<br></code></pre></td></tr></table></figure><p>编码过程略有不爽。<br>好的一点是，AMD保留了commonjs中的require、exprots、module这三个功能（上面提到的第4条）。你也可以不把依赖罗列在dependencies数组中。而是在代码中用require来引入，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs plain">define(function()&#123;<br>     console.log(&#39;main2.js执行&#39;);<br><br>     require([&#39;a&#39;], function(a)&#123;<br>          a.hello();    <br>     &#125;);<br><br>     $(&#39;#b&#39;).click(function()&#123;<br>          require([&#39;b&#39;], function(b)&#123;<br>               b.hello();<br>          &#125;);<br>     &#125;);<br>&#125;);<br></code></pre></td></tr></table></figure><p>我们在define的参数中未写明依赖，那么main2.js在执行的时候，就不会预先加载a.js和b.js，只是执行到require语句的时候才会去加载，上述代码的输出如下：<br>main2.js执行<br>a.js执行<br>hello, a.js<br>可以看到b.js并未执行，从网络请求中看，b.js也并未被下载。只有在按钮被点击的时候b.js才会被下载执行，并且在回调函数中执行模块中的方法。这就是名副其实的“懒加载”了。</p><p>这样的懒加载无疑会大大减轻初始化时的损耗（下载和执行都被省去了），但是弊端也是显而易见的，在后续执行a.hello和b.hello时，必须得实时下载代码然后在回调中才能执行，这样的用户体验是不好的，用户的操作会有明显的延迟卡顿。<br>但这样的现实并非是无法接受的，毕竟是浏览器环境，我们已经习惯了操作网页时伴随的各种loading。。。</p><p>但是话说过来，有没有更好的方法来处理问题呢？资源的下载阶段还是预先进行，资源执行阶段后置，等到需要的时候再执行。这样一种折衷的方式，能够融合前面两种方式的优点，而又回避了缺点。<br>这就是Modules/Wrappings规范，还记得前面提到的“中间派”吗？<br>在AMD的阵营中，也有一部分人提出这样的观点，代码里写一堆回调实在是太恶心了，他们更喜欢这样来使用模块：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plain">var a &#x3D; require(&#39;a&#39;);<br>a.hello();<br><br>$(&#39;#b&#39;).click(function()&#123;<br>        var b &#x3D; require(&#39;b&#39;);<br>        b.hello();<br>&#125;);<br></code></pre></td></tr></table></figure><p>于是，AMD也终于决定作妥协，兼容Modules/Wrappings的写法，但只是部分兼容，例如并没有使用module.declare来定义模块，而还是用define，模块的执行时机也没有改变，依旧是预先执行。因此，AMD将此兼容称为Simplified CommonJS wrapping，即并不是完整的实现Modules/Wrappings。<br>作了此兼容后，使用requirejs就可以这么写代码了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs plain">&#x2F;&#x2F;d.js<br>define(function(require, exports, module)&#123;<br>     console.log(&#39;d.js执行&#39;);<br>     return &#123;<br>          helloA: function()&#123;<br>               var a &#x3D; require(&#39;a&#39;);<br>               a.hello();<br>          &#125;,<br>          run: function()&#123;<br>               $(&#39;#b&#39;).click(function()&#123;<br>                    var b &#x3D; require(&#39;b&#39;);<br>                    b.hello();<br>               &#125;);<br>          &#125;<br>     &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p>注意定义模块时候的轻微差异，dependencies数组为空，但是factory函数的形参必须手工写上require,exports,module，（这不同于之前的dependencies和factory形参全不写），这样写即可使用Simplified CommonJS wrapping风格，与commonjs的格式一致了。<br>虽然使用上看起来简单，然而在理解上却给后人埋下了一个大坑。因为AMD只是支持了这样的语法，而并没有真正实现模块的延后执行。什么意思呢？上面的代码，正常来讲应该是预先下载a.js和b.js，然后在执行模块的helloA方法的时候开始执行a.js里面的代码，在点击按钮的时候开始执行b.js中的方法。实际却不是这样，只要此模块被别的模块引入，a.js和b.js中的代码还是被预先执行了。<br>我们把上面的代码命名为d.js，在别的地方使用它：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">require([&#39;d&#39;], function(d)&#123;<br>   <br>&#125;);<br></code></pre></td></tr></table></figure><p>上面的代码会输出<br>a.js执行<br>b.js执行<br>d.js执行<br>可以看出，尽管还未调用d模块的API，里面所依赖的a.js和b.js中的代码已经执行了。AMD的这种只实现语法却未真正实现功能的做法容易给人造成理解上的困难，被强烈吐槽。<br>（在requirejs2.0中，作者声明已经处理了此问题（<a href="https://github.com/jrburke/requirejs/wiki/Upgrading-to-RequireJS-2.0#delayed），但是我用2.1.20版测试的时候还是会预先执行，我有点不太明白原因，如果有懂的高手请指教）" target="_blank" rel="noopener">https://github.com/jrburke/requirejs/wiki/Upgrading-to-RequireJS-2.0#delayed），但是我用2.1.20版测试的时候还是会预先执行，我有点不太明白原因，如果有懂的高手请指教）</a></p><h3>兼容并包的CMD/seajs</h3><p>既然requirejs有上述种种不甚优雅的地方，所以必然会有新东西来完善它，这就是后起之秀seajs，seajs的作者是国内大牛淘宝前端步道者玉伯。seajs全面拥抱Modules/Wrappings规范，不用requirejs那样回调的方式来编写模块。而它也不是完全按照Modules/Wrappings规范，seajs并没有使用declare来定义模块，而是使用和requirejs一样的define，或许作者本人更喜欢这个名字吧。（然而这或多或少又会给人们造成理解上的混淆），用seajs定义模块的写法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs plain">&#x2F;&#x2F;a.js<br>define(function(require, exports, module)&#123;<br>     console.log(&#39;a.js执行&#39;);<br>     return &#123;<br>          hello: function()&#123;<br>               console.log(&#39;hello, a.js&#39;);<br>          &#125;<br>     &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs plain">&#x2F;&#x2F;b.js<br>define(function(require, exports, module)&#123;<br>     console.log(&#39;b.js执行&#39;);<br>     return &#123;<br>          hello: function()&#123;<br>               console.log(&#39;hello, b.js&#39;);<br>          &#125;<br>     &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs plain">&#x2F;&#x2F;main.js<br>define(function(require, exports, module)&#123;<br>     console.log(&#39;main.js执行&#39;);<br><br>     var a &#x3D; require(&#39;a&#39;);<br>     a.hello();    <br><br>     $(&#39;#b&#39;).click(function()&#123;<br>          var b &#x3D; require(&#39;b&#39;);<br>          b.hello();<br>     &#125;);<br>    <br>&#125;);<br></code></pre></td></tr></table></figure><p>定义模块时无需罗列依赖数组，在factory函数中需传入形参require,exports,module，然后它会调用factory函数的toString方法，对函数的内容进行正则匹配，通过匹配到的require语句来分析依赖，这样就真正实现了commonjs风格的代码。<br>上面的main.js执行会输出如下：<br>main.js执行<br>a.js执行<br>hello, a.js<br>a.js和b.js都会预先下载，但是b.js中的代码却没有执行，因为还没有点击按钮。当点击按钮的时候，会输出如下：<br>b.js执行<br>hello, b.js<br>可以看到b.js中的代码此时才执行。这样就真正实现了“就近书写，延迟执行“，不可谓不优雅。</p><p>如果你一定要挑出一点不爽的话，那就是b.js的预先下载了。你可能不太想一开始就下载好所有的资源，希望像requirejs那样，等点击按钮的时候再开始下载b.js。本着兼容并包的思想，seajs也实现了这一功能，提供require.async API，在点击按钮的时候，只需这样写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">var b &#x3D; require.async(&#39;b&#39;);<br>b.hello();<br></code></pre></td></tr></table></figure><p>b.js就不会在一开始的时候就加载了。这个API可以说是简单漂亮。</p><p>关于模块对外暴漏API的方式，seajs也是融合了各家之长，支持commonjs的exports.xxx = xxx和module.exports = xxx的写法，也支持AMD的return写法，暴露的API可以是任意类型。</p><p>你可能会觉得seajs无非就是一个抄，把别人家的优点都抄过来组合了一下。其实不然，seajs是commonjs规范在浏览器端的践行者，对于requirejs的优点也加以吸收。看人家的名字，就是海纳百川之意。（再论起名的重要性~），既然它的思想是海纳百川，讨论是不是抄就没意义了。<br>鉴于seajs融合了太多的东西，已经无法说它遵循哪个规范了，所以玉伯干脆就自立门户，起名曰CMD（Common Module Definition）规范，有了纲领，就不会再存在非议了</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;浅析JS模块规范&lt;/h1&gt;

&lt;p&gt;随着JS模块化编程的发展，处理模块之间的依赖关系成为了维护的关键。&lt;br&gt;AMD,CMD,CommonJS是目前最常用的三种模块化书写规范。&lt;/p&gt;
&lt;h3&gt;CommonJS&lt;/h3&gt;

&lt;p&gt;CommonJS规范是诞生比较早的。Nod
      
    
    </summary>
    
    
    
      <category term="js" scheme="http://yoursite.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>javascript继承的6种方法</title>
    <link href="http://yoursite.com/2020/04/27/javascript%E7%BB%A7%E6%89%BF%E7%9A%846%E7%A7%8D%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2020/04/27/javascript%E7%BB%A7%E6%89%BF%E7%9A%846%E7%A7%8D%E6%96%B9%E6%B3%95/</id>
    <published>2020-04-27T03:41:16.000Z</published>
    <updated>2020-04-27T03:56:39.577Z</updated>
    
    <content type="html"><![CDATA[<h3> 想要继承，就必须要提供个父类（继承谁，提供继承的属性）</h3><p><img src="/2020/04/27/javascript%E7%BB%A7%E6%89%BF%E7%9A%846%E7%A7%8D%E6%96%B9%E6%B3%95/1.png" alt>　　　　</p><h3>一、原型链继承</h3><p><img src="/2020/04/27/javascript%E7%BB%A7%E6%89%BF%E7%9A%846%E7%A7%8D%E6%96%B9%E6%B3%95/2.png" alt></p><ul><li>重点：让新实例的原型等于父类的实例。</li><li>特点：<br>1、实例可继承的属性有：实例的构造函数的属性，父类构造函数属性，父类原型的属性。（新实例不会继承父类实例的属性！）</li><li>缺点:<br>1、新实例无法向父类构造函数传参。<br>2、继承单一。<br>3、所有新实例都会共享父类实例的属性。（原型上的属性是共享的，一个实例修改了原型属性，另一个实例的原型属性也会被修改！）</li></ul><h3>二、借用构造函数继承</h3><p><img src="/2020/04/27/javascript%E7%BB%A7%E6%89%BF%E7%9A%846%E7%A7%8D%E6%96%B9%E6%B3%95/3.png" alt></p><ul><li>重点：用.call()和.apply()将父类构造函数引入子类函数（在子类函数中做了父类函数的自执行（复制））</li><li>特点：<br>1、只继承了父类构造函数的属性，没有继承父类原型的属性。<br>2、解决了原型链继承缺点1、2、3。<br>3、可以继承多个构造函数属性（call多个）。<br>4、在子实例中可向父实例传参。</li><li>缺点：<br>1、只能继承父类构造函数的属性。<br>2、无法实现构造函数的复用。（每次用每次都要重新调用）<br>3、每个新实例都有父类构造函数的副本，臃肿。</li></ul><h3>三、组合继承（组合原型链继承和借用构造函数继承）（常用）</h3><p><img src="/2020/04/27/javascript%E7%BB%A7%E6%89%BF%E7%9A%846%E7%A7%8D%E6%96%B9%E6%B3%95/4.png" alt></p><ul><li>重点：结合了两种模式的优点，传参和复用</li><li>特点：<br>1、可以继承父类原型上的属性，可以传参，可复用。<br>2、每个新实例引入的构造函数属性是私有的。</li><li>缺点：<br>1、调用了两次父类构造函数（耗内存），子类的构造函数会代替原型上的那个父类构造函数。</li></ul><h3>四、原型式继承</h3><p><img src="/2020/04/27/javascript%E7%BB%A7%E6%89%BF%E7%9A%846%E7%A7%8D%E6%96%B9%E6%B3%95/5.png" alt></p><ul><li>重点：用一个函数包装一个对象，然后返回这个函数的调用，这个函数就变成了个可以随意增添属性的实例或对象。object.create()就是这个原理。</li><li>特点：<br>1、类似于复制一个对象，用函数来包装。</li><li>缺点：<br>1、所有实例都会继承原型上的属性。<br>2、无法实现复用。（新实例属性都是后面添加的）</li></ul><h3>五、寄生式继承</h3><p><img src="/2020/04/27/javascript%E7%BB%A7%E6%89%BF%E7%9A%846%E7%A7%8D%E6%96%B9%E6%B3%95/6.png" alt></p><ul><li>重点：就是给原型式继承外面套了个壳子。</li><li>优点：没有创建自定义类型，因为只是套了个壳子返回对象（这个），这个函数顺理成章就成了创建的新对象。</li><li>缺点：没用到原型，无法复用。</li></ul><h3>六、寄生组合式继承（常用）</h3><ul><li>寄生：在函数内返回对象然后调用</li><li>组合：<br>1、函数的原型等于另一个实例。<br>2、在函数中用apply或者call引入另一个构造函数，可传参。<br><img src="/2020/04/27/javascript%E7%BB%A7%E6%89%BF%E7%9A%846%E7%A7%8D%E6%96%B9%E6%B3%95/7.png" alt><br>~~<br><img src="/2020/04/27/javascript%E7%BB%A7%E6%89%BF%E7%9A%846%E7%A7%8D%E6%96%B9%E6%B3%95/8.png" alt>　　　</li><li>重点：修复了组合继承的问题</li></ul><p>继承这些知识点与其说是对象的继承，更像是函数的功能用法，如何用函数做到复用，组合，这些和使用继承的思考是一样的。上述几个继承的方法都可以手动修复他们的缺点，但就是多了这个手动修复就变成了另一种继承模式。</p><p>这些继承模式的学习重点是学它们的思想，不然你会在coding书本上的例子的时候，会觉得明明可以直接继承为什么还要搞这么麻烦。就像原型式继承它用函数复制了内部对象的一个副本，这样不仅可以继承内部对象的属性，还能把函数（对象，来源内部对象的返回）随意调用，给它们添加属性，改个参数就可以改变原型对象，而这些新增的属性也不会相互影响。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3&gt; 想要继承，就必须要提供个父类（继承谁，提供继承的属性）&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/2020/04/27/javascript%E7%BB%A7%E6%89%BF%E7%9A%846%E7%A7%8D%E6%96%B9%E6%B3%95/1.png&quot; alt
      
    
    </summary>
    
    
    
      <category term="js" scheme="http://yoursite.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>js操纵导致的内存泄漏</title>
    <link href="http://yoursite.com/2020/04/26/js%E6%93%8D%E7%BA%B5%E5%AF%BC%E8%87%B4%E7%9A%84%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/"/>
    <id>http://yoursite.com/2020/04/26/js%E6%93%8D%E7%BA%B5%E5%AF%BC%E8%87%B4%E7%9A%84%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/</id>
    <published>2020-04-26T07:55:15.000Z</published>
    <updated>2020-04-27T08:53:26.953Z</updated>
    
    <content type="html"><![CDATA[<h3>什么是内存泄漏</h3>内存泄漏是指一块被分配的内存既不能使用，又不能回收，直到浏览器进程结束。在C++中，因为是手动管理内存，内存泄漏是经常出现的事情。而现在流行的C#和Java等语言采用了自动垃圾回收方法管理内存，正常使用的情况下几乎不会发生内存泄漏。浏览器中也是采用自动垃圾回收方法管理内存，但由于浏览器垃圾回收方法有bug，因此会产生内存泄漏。<h3>知识剖析</h3><ol><li><p>js的回收机制<br>垃圾回收机制—GC<br>Javascript具有自动垃圾回收机制(GC:Garbage Collecation)，也就是说，执行环境会负责管理代码执行过程中使用的内存。<br>JavaScript垃圾回收的机制很简单：找出不再使用的变量，然后释放掉其占用的内存，但是这个过程不是实时的，因为其开销比较大，所以垃圾回收系统（GC）会按照固定的时间间隔,周期性的执行。<br>到底哪个变量是没有用的？所以垃圾收集器必须跟踪到底哪个变量没用，对于不再有用的变量打上标记，以备将来收回其内存。用于标记的无用变量的策略可能因实现而有所区别，通常情况下有两种实现方式：标记清除和引用计数。引用计数不太常用，标记清除较为常用。</p></li><li><p>标记清除<br>js中最常用的垃圾回收方式就是标记清除。当变量进入环境时，例如，在函数中声明一个变量，就将这个变量标记为“进入环境”。从逻辑上讲，永远不能释放进入环境的变量所占用的内存，因为只要执行流进入相应的环境，就可能会用到它们。而当变量离开环境时，则将其标记为“离开环境”。<br><img src="/2020/04/26/js%E6%93%8D%E7%BA%B5%E5%AF%BC%E8%87%B4%E7%9A%84%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/1.webp" alt></p></li><li><p>引用计数<br>引用计数的含义是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型值（function object array）赋给该变量时，则这个值的引用次数就是1。如果同一个值又被赋给另一个变量，则该值的引用次数加1。相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数减1。当这个值的引用次数变成0时，则说明没有办法再访问这个值了，因而就可以将其占用的内存空间回收回来。这样，当垃圾回收器下次再运行时，它就会释放那些引用次数为0的值所占用的内存。<br><img src="/2020/04/26/js%E6%93%8D%E7%BA%B5%E5%AF%BC%E8%87%B4%E7%9A%84%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/2.webp" alt></p></li></ol><h3>常见问题和解决方案</h3><p>JS哪些操作会造成内存泄漏？<br>虽然JavaScript 会自动垃圾收集，但是如果我们的代码写法不当，会让变量一直处于“进入环境”的状态，无法被回收。下面列一下内存泄漏常见的几种情况。</p><ol><li>意外的全局变量引起的内存泄漏<br><img src="/2020/04/26/js%E6%93%8D%E7%BA%B5%E5%AF%BC%E8%87%B4%E7%9A%84%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/3.webp" alt><br>你可以通过加上 ‘use strict’ 启用严格模式来避免这类问题, 严格模式会阻止你创建意外的全局变量.</li><li>闭包引起的内存泄漏<br><img src="/2020/04/26/js%E6%93%8D%E7%BA%B5%E5%AF%BC%E8%87%B4%E7%9A%84%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/4.webp" alt><br>闭包可以维持函数内局部变量，使其得不到释放。 上例定义事件回调时，由于是函数内定义函数，并且内部函数–事件回调的引用外暴了，形成了闭包 解决之道，将事件处理函数定义在外部，解除闭包,或者在定义事件处理函数的外部函数中，删除对dom的引用<br><img src="/2020/04/26/js%E6%93%8D%E7%BA%B5%E5%AF%BC%E8%87%B4%E7%9A%84%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/5.webp" alt><br><img src="/2020/04/26/js%E6%93%8D%E7%BA%B5%E5%AF%BC%E8%87%B4%E7%9A%84%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/6.webp" alt></li><li>没有清理的DOM元素引用<br><img src="/2020/04/26/js%E6%93%8D%E7%BA%B5%E5%AF%BC%E8%87%B4%E7%9A%84%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/7.webp" alt><br>虽然我们用removeChild移除了button, 但是还在elements对象里保存着#button的引用，换言之, DOM元素还在内存里面</li><li>被遗忘的定时器或者回调<br><img src="/2020/04/26/js%E6%93%8D%E7%BA%B5%E5%AF%BC%E8%87%B4%E7%9A%84%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/8.webp" alt><br>这样的代码很常见, 如果 id 为 Node 的元素从 DOM 中移除, 该定时器仍会存在, 同时, 因为回调函数中包含对 someResource 的引用, 定时器外面的 someResource 也不会被释放.</li><li>子元素存在引用引起的内存泄漏<br><img src="/2020/04/26/js%E6%93%8D%E7%BA%B5%E5%AF%BC%E8%87%B4%E7%9A%84%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/9.webp" alt><br>黄色是指直接被 js变量所引用，在内存里，红色是指间接被 js变量所引用，如上图，refB 被 refA 间接引用，导致即使 refB 变量被清空，也是不会被回收的子元素 refB 由于 parentNode 的间接引用，只要它不被删除，它所有的父元素（图中红色部分）都不会被删除。</li></ol><h3>扩展思考</h3><p>IE7/8引用计数使用循环引用产生的问题。<br><img src="/2020/04/26/js%E6%93%8D%E7%BA%B5%E5%AF%BC%E8%87%B4%E7%9A%84%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/10.webp" alt><br>fn()执行完毕后，两个对象都已经离开环境，在标记清除方式下是没有问题的，但是在引用计数策略下，因为a和b的引用次数不为0，所以不会被垃圾回收器回收内存，如果fn函数被大量调用，就会造成内存泄漏。在IE7与IE8上，内存直线上升。<br>IE中有一部分对象并不是原生js对象。例如，其内存泄漏DOM和BOM中的对象就是使用C++以COM对象的形式实现的，而COM对象的垃圾回收机制采用的就是引用计数策略。因此，即使IE的js引擎采用标记清除策略来实现，但js访问的COM对象依然是基于引用计数策略的。换句话说，只要在IE中涉及COM对象，就会存在循环引用的问题。<br><img src="/2020/04/26/js%E6%93%8D%E7%BA%B5%E5%AF%BC%E8%87%B4%E7%9A%84%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/11.webp" alt><br>上面的例子在一个DOM元素（element)与一个原生js对象（myObject)之间创建了循环引用。其中，变量myObject有一个名为e的属性指向element对象；而变量element也有一个属性名为o回指myObject。由于存在这个循环引用，即使例子中的DOM从页面中移除，它也永远不会被回收。</p><ul><li><p>看上面的例子，有人会觉得太弱了，谁会做这样无聊的事情，但是其实我们经常会这样做<br><img src="/2020/04/26/js%E6%93%8D%E7%BA%B5%E5%AF%BC%E8%87%B4%E7%9A%84%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/12.webp" alt><br>这段代码看起来没什么问题，但是obj引用了document.getElementById(“element”)，而document.getElementById(“element”)的onclick方法会引用外部环境中的变量，自然也包括obj，是不是很隐蔽啊。</p></li><li><p>最简单的解决方式就是自己手工解除循环引用，比如刚才的函数可以这样<br><img src="/2020/04/26/js%E6%93%8D%E7%BA%B5%E5%AF%BC%E8%87%B4%E7%9A%84%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/13.webp" alt><br>将变量设置为null意味着切断变量与它此前引用的值之间的连接。当垃圾回收器下次运行时，就会删除这些值并回收它们占用的内存。 要注意的是，IE9+并不存在循环引用导致Dom内存泄漏问题，可能是微软做了优化，或者Dom的回收方式已经改变</p></li></ul><h3>更多讨论</h3><ol><li>如何分析JS内存使用情况<br>Google Chrome浏览器提供了非常强大的JS调试工具，Memory 视图<br>profiles 视图让你可以对 JavaScript 代码运行时的内存进行快照，并且可以比较这些内存快照。它还让你可以记录一段时间内的内存分配情况。在每一个结果视图中都可以展示不同类型的列表，但是对我们最有用的是 summary 列表和 comparison 列表。<br>summary 视图提供了不同类型的分配对象以及它们的合计大小：shallow size （一个特定类型的所有对象的总和）和 retained size （shallow size 加上保留此对象的其它对象的大小）。distance 显示了对象到达 GC 根（校者注：最初引用的那块内存，具体内容可自行搜索该术语）的最短距离。 comparison 视图提供了同样的信息但是允许对比不同的快照。这对于找到泄漏很有帮助。</li><li>Chrome开发者工具初窥-Profiles面板</li><li>你能想哪些避免内存泄漏的姿势<br> 1) 减少不必要的全局变量，或者生命周期较长的对象，及时对无用的数据进行垃圾回收<br> 2) 注意程序逻辑，避免“死循环”之类的<br> 3) 避免创建过多的对象</li></ol><p>原则：不用了的东西要及时归还。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3&gt;什么是内存泄漏&lt;/h3&gt;
内存泄漏是指一块被分配的内存既不能使用，又不能回收，直到浏览器进程结束。在C++中，因为是手动管理内存，内存泄漏是经常出现的事情。而现在流行的C#和Java等语言采用了自动垃圾回收方法管理内存，正常使用的情况下几乎不会发生内存泄漏。浏览器中也是采
      
    
    </summary>
    
    
    
      <category term="js" scheme="http://yoursite.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>前端面试题</title>
    <link href="http://yoursite.com/2020/04/24/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>http://yoursite.com/2020/04/24/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/</id>
    <published>2020-04-24T00:54:01.000Z</published>
    <updated>2020-05-15T09:50:02.230Z</updated>
    
    <content type="html"><![CDATA[<h1>存储</h1><h3>请你谈谈Cookie的弊端</h3><p>1.IE6或更低版本最多20个cookie<br>2.IE7和之后的版本最后可以有50个cookie。<br>3.Firefox最多50个cookie<br>4.chrome和Safari没有做硬性限制<br>Opera 会清理近期最少使用的Firefox会随机清理 4096字节，为了兼容性，一般不能超过 IE 提供了一种存储可以持久化用户数据，叫做IE5.0就开始支持。每个数据最多128K，每个域名下最多1M。这个持久化数据放在缓存中，如果缓存没有清理，那么会一直存在。</p><ol><li><p>优点：极高的扩展性和可用性<br>1) 通过良好的编程，控制保存在cookie中的session对象的大小。<br>2) 通过加密和安全传输技术（SSL），减少cookie被破解的可能性。<br>3) 只在cookie中存放不敏感数据，即使被盗也不会有重大损失。<br>4) 控制cookie的生命期，使之不会永远有效。偷盗者很可能拿到一个过期的cookie。</p></li><li><p>缺点:<br>1) <code>Cookie</code>数量和长度的限制。每个domain最多只能有20条cookie，每个cookie长度不能超过4KB，否则会被截掉。<br>2) 安全性问题。如果cookie被人拦截了，那人就可以取得所有的session信息。即使加密也与事无补，因为拦截者并不需要知道cookie的意义，他只要原样转发cookie就可以达到目的了。<br>3) 有些状态不可能保存在客户端。例如，为了防止重复提交表单，我们需要在服务器端保存一个计数器。如果我们把这个计数器保存在客户端，那么它起不到任何作用。</p></li></ol><h3>浏览器本地存储</h3><p>在较高版本的浏览器中，sessionStorage和HTML5中提供了globalStorage。<br>Web Storage包括了两种存储方式：localStorage和sessionStorage。<br>sessionStorage不是一种持久化的本地存储，仅仅是会话级别的存储。<br>localStorage生命周期是永久，除非主动清除localStorage信息，否则这些信息将永远存在，存放数据大小为一般为5MB。</p><h3>web storage和cookie的区别</h3><p>一、储存空间不同<br>1.Web Storage能提供5M的存储空间（不同浏览器不同），Cookie提供4K的空间<br>2.Web Storage每个域（包括子域）都有独立的存储空间，每个存储空间是完全独立的，因此不会造成数据混淆<br>二、与服务端交互<br>1.Web Storage中数据仅仅是本地存储，不会与服务器发生任何交互<br>2.Cookie的内容会随着请求一并发送到服务器（每请求一个新的页面时，Cookie都会被发送过去，无形中造成宽带浪费）<br>三、接口<br>1.Web Storage提供了许多丰富易用的接口，拥有setItem，removeItemgetItem，clear，key等方法，操作数据更简单<br>2.Cookie需要自己封装setCookie，getCookie等</p><h1>CSS 相关问题</h1><h3>display:none和visibility:hidden的区别？</h3><p>display:none 隐藏对应的元素，在文档布局中不再给它分配空间，它各边的元素会合拢，就当他从来不存在。<br>visibility:hidden 隐藏对应的元素，但是在文档布局中仍保留原来的空间。</p><h3>CSS中 link 和@import 的区别是？</h3><p>(1) link属于HTML标签，而@import是CSS提供的;<br>(2) 页面被加载的时，link会同时被加载，而@import引用的CSS会等到页面被加载完再加载;<br>(3) import只在IE5以上才能识别，而link是HTML标签，无兼容问题;<br>(4) link方式的样式的权重 高于@import的权重.</p><h3>position的absolute与fixed共同点与不同点</h3><p>A：共同点：<br>1.改变行内元素的呈现方式，display被置为block；<br>2.让元素脱离普通流，不占据空间；<br>3.默认会覆盖到非定位元素上</p><p>B：不同点：<br>absolute的”根元素“是可以设置的，而fixed的”根元素“固定为浏览器窗口。<br>当你滚动网页，fixed元素与浏览器窗口之间的距离是不变的。</p><h3>介绍一下CSS的盒子模型？</h3><p>1）有两种， IE 盒子模型、标准 W3C 盒子模型；IE的盒子模型content部分包含了 border 和 pading;<br>2）盒模型： 内容(content)、填充(padding)、边界(margin)、 边框(border).</p><h3>CSS 选择符有哪些？哪些属性可以继承？优先级算法如何计算？</h3><p>1.id选择器（ # myid）<br>2.类选择器（.myclassname）<br>3.标签选择器（div, h1, p）<br>4.相邻选择器（h1 + p）<br>5.子选择器（ul &gt; li）<br>6.后代选择器（li a）<br>7.通配符选择器（ * ）<br>8.属性选择器（a[rel = “external”]）<br>9.伪类选择器（a: hover, li:nth-child）</p><ul><li>可继承的样式： font-size font-family color, text-indent;</li><li>不可继承的样式：border padding margin width height ;</li><li>优先级就近原则，同权重情况下样式定义最近者为准;</li><li>载入样式以最后载入的定位为准;<br>优先级为:<br>!important &gt; id &gt; class &gt; tag<br>important 比 内联优先级高,但内联比 id 要高</li></ul><h3>CSS3新增伪类举例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plain">p:first-of-type 选择属于其父元素的首个 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。<br>p:last-of-type 选择属于其父元素的最后 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。<br>p:only-of-type 选择属于其父元素唯一的 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。<br>p:only-child 选择属于其父元素的唯一子元素的每个 &lt;p&gt; 元素。<br>p:nth-child(2) 选择属于其父元素的第二个子元素的每个 &lt;p&gt; 元素。<br>:enabled :disabled 控制表单控件的禁用状态。<br>:checked 单选框或复选框被选中。<br></code></pre></td></tr></table></figure><h3>列出display的值，说明他们的作用。position的值， relative和absolute分别是相对于谁进行定位的？</h3><p>block 象块类型元素一样显示。<br>inline 缺省值。象行内元素类型一样显示。<br>inline-block 象行内元素一样显示，但其内容象块类型元素一样显示。<br>list-item 象块类型元素一样显示，并添加样式列表标记。</p><p>*absolute<br>生成绝对定位的元素，相对于 static 定位以外的第一个祖先元素进行定位。</p><p>*fixed （老IE不支持）<br>生成绝对定位的元素，相对于浏览器窗口进行定位。</p><p>*relative<br>生成相对定位的元素，相对于其在普通流中的位置进行定位。</p><ul><li><p>static 默认值。没有定位，元素出现在正常的流中</p></li><li><p>（忽略 top, bottom, left, right z-index 声明）。</p></li><li><p>inherit 规定从父元素继承 position 属性的值。</p></li></ul><h3>CSS3有哪些新特性？</h3><p>圆角（border-radius），阴影（box-shadow），对文字加特效（text-shadow、），线性渐变（gradient），旋转（transform）<br>transform:rotate(9deg) scale(0.85,0.90) translate(0px,-30px) skew(-9deg,0deg);//旋转,缩放,定位,倾斜<br>增加了更多的CSS选择器 多背景 rgba<br>在CSS3中唯一引入的伪元素是::selection.<br>媒体查询，多栏布局，border-image</p><h3>为什么要初始化CSS样式。</h3><p>因为浏览器的兼容问题，不同浏览器对有些标签的默认值是不同的，如果没对CSS初始化往往会出现浏览器之间的页面显示差异。<br>当然，初始化样式会对SEO有一定的影响，但鱼和熊掌不可兼得，但力求影响最小的情况下初始化。<br>*最简单的初始化方法就是： * {padding: 0; margin: 0;} （不建议）<br>淘宝的样式初始化：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs plain">body, h1, h2, h3, h4, h5, h6, hr, p, blockquote, dl, dt, dd, ul, ol, li, pre, form, fieldset, legend, button, input, textarea, th, td &#123; margin:0; padding:0; &#125;<br>body, button, input, select, textarea &#123; font:12px&#x2F;1.5tahoma, arial, \5b8b\4f53; &#125;<br>h1, h2, h3, h4, h5, h6&#123; font-size:100%; &#125;<br>address, cite, dfn, em, var &#123; font-style:normal; &#125;<br>code, kbd, pre, samp &#123; font-family:couriernew, courier, monospace; &#125;<br>small&#123; font-size:12px; &#125;<br>ul, ol &#123; list-style:none; &#125;<br>a &#123; text-decoration:none; &#125;<br>a:hover &#123; text-decoration:underline; &#125;<br>sup &#123; vertical-align:text-top; &#125;<br>sub&#123; vertical-align:text-bottom; &#125;<br>legend &#123; color:#000; &#125;<br>fieldset, img &#123; border:0; &#125;<br>button, input, select, textarea &#123; font-size:100%; &#125;<br>table &#123; border-collapse:collapse; border-spacing:0; &#125;<br></code></pre></td></tr></table></figure><h3>对BFC规范的理解？</h3><p>BFC，块级格式化上下文，一个创建了新的BFC的盒子是独立布局的，盒子里面的子元素的样式不会影响到外面的元素。在同一个BFC中的两个毗邻的块级盒在垂直方向（和布局方向有关系）的margin会发生折叠。<br>（W3C CSS 2.1 规范中的一个概念，它决定了元素如何对其内容进行布局，以及与其他元素的关系和相互作用。）<br>形成BFC:<br>1.float的值不为none。<br>2.overflow的值不为visible。<br>3.display的值为table-cell, table-caption, inline-block中的任何一个。<br>4.position的值不为relative和static。<br>BFC的规则:<br>BFC中的元素的布局是不受外界的影响（我们往往利用这个特性来消除浮动元素对其非浮动的兄弟元素和其子元素带来的影响。）并且在一个BFC中，块盒与行盒（行盒由一行中所有的内联元素所组成）都会垂直的沿着其父元素的边框排列。</p><h3>解释下 CSS sprites，以及你要如何在页面或网站中使用它。</h3>CSS Sprites其实就是把网页中一些背景图片整合到一张图片文件中，再利用CSS的“background-image”，“background- repeat”，“background-position”的组合进行背景定位，background-position可以用数字能精确的定位出背景图片的位置。这样可以减少很多图片请求的开销，因为请求耗时比较长；请求虽然可以并发，但是也有限制，一般浏览器都是6个。对于未来而言，就不需要这样做了，因为有了`http2`。<h1>html部分<h1><h3>说说你对语义化的理解？</h3>1，去掉或者丢失样式的时候能够让页面呈现出清晰的结构2，有利于SEO：和搜索引擎建立良好沟通，有助于爬虫抓取更多的有效信息：爬虫依赖于标签来确定上下文和各个关键字的权重；3，方便其他设备解析（如屏幕阅读器、盲人阅读器、移动设备）以意义的方式来渲染网页；4，便于团队开发和维护，语义化更具可读性，是下一步网页的重要动向，遵循W3C标准的团队都遵循这个标准，可以减少差异化。<h3>Doctype作用? 严格模式与混杂模式如何区分？它们有何意义?</h3><p>（1）&lt;!DOCTYPE&gt; 声明位于文档中的最前面，处于 html 标签之前。告知浏览器以何种模式来渲染文档。<br>（2）严格模式的排版和 JS 运作模式是 以该浏览器支持的最高标准运行。<br>（3）在混杂模式中，页面以宽松的向后兼容的方式显示。模拟老式浏览器的行为以防止站点无法工作。<br>（4）DOCTYPE不存在或格式不正确会导致文档以混杂模式呈现。</p><h3>你知道多少种Doctype文档类型？</h3><p>该标签可声明三种 DTD 类型，分别表示严格版本、过渡版本以及基于框架的 HTML 文档。<br>HTML 4.01 规定了三种文档类型：Strict、Transitional 以及 Frameset。<br>XHTML 1.0 规定了三种 XML 文档类型：Strict、Transitional 以及 Frameset。<br>Standards （标准）模式（也就是严格呈现模式）用于呈现遵循最新标准的网页，而 Quirks（包容）模式（也就是松散呈现模式或者兼容模式）用于呈现为传统浏览器而设计的网页。</p><h3>HTML与XHTML——二者有什么区别</h3><p>区别：</p><ol><li>所有的标记都必须要有一个相应的结束标记</li><li>所有标签的元素和属性的名字都必须使用小写</li><li>所有的XML标记都必须合理嵌套</li><li>所有的属性必须用引号””括起来</li><li>把所有&lt;和&amp;特殊符号用编码表示</li><li>给所有属性赋一个值</li><li>不要在注释内容中使“–”</li><li>图片必须有说明文字</li></ol><h3>常见兼容性问题？</h3><ul><li><p>png24位的图片在iE6浏览器上出现背景，解决方案是做成PNG8.也可以引用一段脚本处理.</p></li><li><p>浏览器默认的margin和padding不同。解决方案是加一个全局的*{margin:0;padding:0;}来统一。</p></li><li><p>IE6双边距bug:块属性标签float后，又有横行的margin情况下，在ie6显示margin比设置的大。</p></li><li><p>浮动ie产生的双倍距离（IE6双边距问题：在IE6下，如果对元素设置了浮动，同时又设置了margin-left或margin-right，margin值会加倍。）<br>#box{ float:left; width:10px; margin:0 0 0 100px;}<br>这种情况之下IE会产生20px的距离，解决方案是在float的标签样式控制中加入 ——_display:inline;将其转化为行内属性。(_这个符号只有ie6会识别)</p></li><li><p>渐进识别的方式，从总体中逐渐排除局部。<br>首先，巧妙的使用“\9”这一标记，将IE游览器从所有情况中分离出来。<br>接着，再次使用“+”将IE8和IE7、IE6分离开来，这样IE8已经独立识别。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plain">css<br>.bb&#123;<br>background-color:#f1ee18;&#x2F;*所有识别*&#x2F;<br>.background-color:#00deff\9; &#x2F;*IE6、7、8识别*&#x2F;<br>+background-color:#a200ff;&#x2F;*IE6、7识别*&#x2F;<br>_background-color:#1e0bd1;&#x2F;*IE6识别*&#x2F;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>IE下,可以使用获取常规属性的方法来获取自定义属性,<br>也可以使用getAttribute()获取自定义属性;<br>Firefox下,只能使用getAttribute()获取自定义属性.<br>解决方法:统一通过getAttribute()获取自定义属性.</p></li><li><p>IE下,event对象有x,y属性,但是没有pageX,pageY属性;<br>Firefox下,event对象有pageX,pageY属性,但是没有x,y属性.</p></li><li><p>解决方法：（条件注释）缺点是在IE浏览器下可能会增加额外的HTTP请求数。</p></li><li><p>Chrome 中文界面下默认会将小于 12px 的文本强制按照 12px 显示,<br>可通过加入 CSS 属性 -webkit-text-size-adjust: none; 解决.</p></li><li><p>超链接访问过后hover样式就不出现了 被点击访问过的超链接样式不在具有hover和active了解决方法是改变CSS属性的排列顺序:<br>L-V-H-A : a:link {} a:visited {} a:hover {} a:active {}</p></li><li><p>怪异模式问题：漏写DTD声明，Firefox仍然会按照标准模式来解析网页，但在IE中会触发怪异模式。为避免怪异模式给我们带来不必要的麻烦，最好养成书写DTD声明的好习惯。现在可以使用<a href="http://www.w3.org/TR/html5/single-page.html" target="_blank" rel="noopener">html5</a>推荐的写法：<code>&lt;doctype html&gt;</code></p></li><li><p>上下margin重合问题<br>ie和ff都存在，相邻的两个div的margin-left和margin-right不会重合，但是margin-top和margin-bottom却会发生重合。<br>解决方法，养成良好的代码编写习惯，同时采用margin-top或者同时采用margin-bottom。</p></li><li><p>ie6对png图片格式支持不好(引用一段脚本处理)</p></li></ul><h3>解释下浮动和它的工作原理？清除浮动的技巧</h3><p>浮动元素脱离文档流，不占据空间。浮动元素碰到包含它的边框或者浮动元素的边框停留。<br>1 .使用空标签清除浮动。<br>这种方法是在所有浮动标签后面添加一个空标签 定义css clear:both. 弊端就是增加了无意义标签。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">&lt;div style&#x3D;&quot;clear:both;&quot;&gt;&lt;&#x2F;div&gt;<br></code></pre></td></tr></table></figure><p>2 .使用overflow。<br>给包含浮动元素的父标签添加css属性 overflow:auto; zoom:1; zoom:1用于兼容IE6。<br>3 .使用after伪对象清除浮动。<br>该方法只适用于非IE浏览器。具体写法可参照以下示例。使用中需注意以下几点。<br>一、该方法中必须为需要清除浮动元素的伪对象中设置 height:0，否则该元素会比实际高出若干像素；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plain">#parent:after&#123;<br>content:&quot;.&quot;;<br>height:0;<br>visibility:hidden;<br>display:block;<br>clear:both;<br>&#125;<br></code></pre></td></tr></table></figure><h3>浮动元素引起的问题和解决办法？</h3>浮动元素引起的问题：（1）父元素的高度无法被撑开，影响与父元素同级的元素（2）与浮动元素同级的非浮动元素会跟随其后（3）若非第一个元素浮动，则该元素之前的元素也需要浮动，否则会影响页面显示的结构解决方法：使用clear:both;属性来清除元素的浮动可解决2、3问题，对于问题1，添加如下样式，给父元素添加.clearfix:after{content: ".";display: block;height: 0;clear: both;visibility: hidden;} .clearfix{display: inline-block;} /* for IE/Mac */<h3>IE 8以下版本的浏览器中的盒模型有什么不同</h3>IE8以下浏览器的盒模型中定义的元素的宽高不包括内边距和边框<h3>DOM操作——怎样添加、移除、移动、复制、创建和查找节点。</h3><ol><li>创建新节点<br>createDocumentFragment() //创建一个DOM片段<br>createElement() //创建一个具体的元素<br>createTextNode() //创建一个文本节点</li><li>添加、移除、替换、插入<br>appendChild()<br>removeChild()<br>replaceChild()<br>insertBefore() //在已有的子节点前插入一个新的子节点</li><li>查找<br>getElementsByTagName() //通过标签名称<br>getElementsByName() //通过元素的Name属性的值(IE容错能力较强，会得到一个数组，其中包括id等于name值的)<br>getElementById() //通过元素Id，唯一性</li></ol><h3>html5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？如何区分 HTML 和 HTML5？</h3>* HTML5 现在已经不是 SGML 的子集，主要是关于图像，位置，存储，多任务等功能的增加。<ul><li>拖拽释放(Drag and drop) API<br>语义化更好的内容标签（header,nav,footer,aside,article,section）<br>音频、视频API(audio,video)<br>画布(Canvas) API<br>地理(Geolocation) API<br>本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失；<br>sessionStorage 的数据在浏览器关闭后自动删除;</li></ul><p>表单控件，calendar、date、time、email、url、search<br>新的技术webworker, websocket, Geolocation</p><ul><li>移除的元素<br>纯表现的元素：basefont，big，center，font, s,strike,tt,u；<br>对可用性产生负面影响的元素：frame，frameset，noframes；</li></ul><p>支持HTML5新标签：</p><ul><li>IE8/IE7/IE6支持通过document.createElement方法产生的标签，<br>可以利用这一特性让这些浏览器支持HTML5新标签，</li></ul><p>浏览器支持新标签后，还需要添加标签默认的样式：</p><ul><li>当然最好的方式是直接使用成熟的框架、使用最多的是html5shim框架<!--[if lt IE 9]><script> src="http://html5shim.googlecode.com/svn/trunk/html5.js"</script><![endif]--></li></ul><h3>iframe的优缺点？</h3><ol><li>iframe优点：<br>解决加载缓慢的第三方内容如图标和广告等的加载问题<br>Security sandbox<br>并行加载脚本</li><li>ifram的缺点：<br>iframe会阻塞主页面的Onload事件；<br>即使内容为空，加载也需要时间<br>没有语意</li></ol><h3>如何实现浏览器内多个标签页之间的通信?</h3><p>调用localstorge、cookies等本地存储方式</p><h3>webSocket如何兼容低浏览器？</h3>Adobe Flash Socket 、 ActiveX HTMLFile (IE) 、 基于 multipart 编码发送 XHR 、 基于长轮询的 XHR<h3>线程与进程的区别</h3><p>一个程序至少有一个进程,一个进程至少有一个线程.<br>线程的划分尺度小于进程，使得多线程程序的并发性高。<br>另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。<br>线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。<br>但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。<br>从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别。</p><h3>你如何对网站的文件和资源进行优化？</h3><p>文件合并<br>文件最小化/文件压缩<br>使用 CDN 托管<br>缓存的使用（多个域名来提供缓存）<br>其他</p><h3>请说出三种减少页面加载时间的方法。</h3><p>1.优化图片<br>2.图像格式的选择（GIF：提供的颜色较少，可用在一些对颜色要求不高的地方）<br>3.优化CSS（压缩合并css，如margin-top,margin-left…)<br>4.网址后加斜杠（如<a href="http://www.campr.com/目录，会判断这个“目录是什么文件类型，或者是目录。）" target="_blank" rel="noopener">www.campr.com/目录，会判断这个“目录是什么文件类型，或者是目录。）</a><br>5.标明高度和宽度（如果浏览器没有找到这两个参数，它需要一边下载图片一边计算大小，如果图片很多，浏览器需要不断地调整页面。这不但影响速度，也影响浏览体验。<br>当浏览器知道了高度和宽度参数后，即使图片暂时无法显示，页面上也会腾出图片的空位，然后继续加载后面的内容。从而加载时间快了，浏览体验也更好了。）<br>6.减少http请求（合并文件，合并图片）。</p><h3>什么是 FOUC（无样式内容闪烁）？你如何来避免 FOUC？</h3>FOUC - Flash Of Unstyled Content 文档样式闪烁<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">&lt;style type&#x3D;&quot;text&#x2F;css&quot; media&#x3D;&quot;all&quot;&gt;@import &quot;..&#x2F;fouc.css&quot;;&lt;&#x2F;style&gt;<br>而引用CSS文件的@import就是造成这个问题的罪魁祸首。IE会先加载整个HTML文档的DOM，然后再去导入外部的CSS文件，因此，在页面DOM加载完成到CSS导入完成中间会有一段时间页面上的内容是没有样式的，这段时间的长短跟网速，电脑速度都有关系。<br>解决方法简单的出奇，只要在&lt;head&gt;之间加入一个&lt;link&gt;或者&lt;script&gt;元素就可以了。<br></code></pre></td></tr></table></figure><h3>null和undefined的区别？</h3><p>undefined表示缺少值，即此处应该有值，但没有定义<br>（1）变量被声明了，但没有赋值时，就等于undefined。<br>（2) 调用函数时，应该提供的参数没有提供，该参数等于undefined。<br>（3）对象没有赋值的属性，该属性的值为undefined。<br>（4）函数没有返回值时，默认返回undefined。</p><p>null表示没有对象，即该处不应该有值<br>（1） 作为函数的参数，表示该函数的参数不是对象。<br>（2） 作为对象原型链的终点。</p><h3>new操作符具体干了什么呢?</h3><p>1、创建一个空对象，并且 this 变量引用该对象，同时还继承了该函数的原型。<br>2、属性和方法被加入到 this 引用的对象中。<br>3、新创建的对象由 this 所引用，并且最后隐式的返回 this 。</p><h3>JSON 的了解？</h3><p>JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式。<br>它是基于JavaScript的一个子集。数据格式简单, 易于读写, 占用带宽小<br>{‘age’:’12’, ‘name’:’back’}</p><h3>js延迟加载的方式有哪些？</h3><p>defer和async、动态创建DOM方式（创建script，插入到DOM中，加载完毕后callBack）、使用jquery的getScript方法、使用setTimeout延迟方法、让js最后加载</p><ul><li>defer:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain"> 明脚本在执行时不会影响页面的构造，浏览器会立即下载，但延迟执行，即脚本会被延迟到整个页面都解析完毕之后再执行。<br>&lt;script defer src&#x3D;&quot;js&#x2F;vendor&#x2F;jquery.js&quot;&gt;&lt;&#x2F;script&gt;<br></code></pre></td></tr></table></figure><ul><li>async:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">添加此属性后，脚本和HTML将一并加载（异步），代码将顺利运行<br>&lt;script async src&#x3D;&quot;js&#x2F;vendor&#x2F;jquery.js&quot;&gt;&lt;&#x2F;script&gt;<br></code></pre></td></tr></table></figure></li><li>defer和async相同：<br>加载文件时不会阻塞页面渲染<br>对于内部的js不起作用<br>使用这两个属性的脚本中不能调用document.write方法</li><li>defer和async区别：<br>如果脚本无需等待页面解析，且无依赖独立运行，那么应使用 async。也就是每一个async属性的脚本都在它下载结束之后立即执行，同时会在window的load事件之前执行。<br>如果脚本需要等待解析，且依赖于其它脚本，调用这些脚本时应使用 defer，将关联的脚本按所需顺序置于 HTML 中。</li><li>jquery的getScript方法:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plain">&#x2F;&#x2F;加载并执行 test.js：<br>$.getScript(&quot;test.js&quot;);<br>&#x2F;&#x2F;加载并执行 test.js ，成功后显示信息<br>$.getScript(&quot;test.js&quot;, function()&#123;<br>  alert(&quot;Script loaded and executed.&quot;);<br>&#125;);<br></code></pre></td></tr></table></figure></li></ul><h3>如何解决跨域问题?</h3><p>jsonp、 document.domain+iframe、window.name、window.postMessage、服务器上设置代理页面</p><ul><li>jsonp的原理是动态插入script标签</li><li>document.domain+iframe (只有在主域相同的时候才能使用该方法)<br>1) 在<a href="http://www.a.com/a.html中：" target="_blank" rel="noopener">www.a.com/a.html中：</a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs plain">document.domain &#x3D; &#39;a.com&#39;;<br>var ifr &#x3D; document.createElement(&#39;iframe&#39;);<br>ifr.src &#x3D; &#39;http:&#x2F;&#x2F;www.script.a.com&#x2F;b.html&#39;;<br>ifr.display &#x3D; none;<br>document.body.appendChild(ifr);<br>ifr.onload &#x3D; function()&#123;<br>    var doc &#x3D; ifr.contentDocument || ifr.contentWindow.document;<br>    &#x2F;* 在这里操作doc，也就是b.html *&#x2F;<br>    ifr.onload &#x3D; null;<br>&#125;;<br></code></pre></td></tr></table></figure>2) 在<a href="http://www.script.a.com/b.html中：" target="_blank" rel="noopener">www.script.a.com/b.html中：</a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">document.domain &#x3D; &#39;a.com&#39;;<br></code></pre></td></tr></table></figure></li><li>window.name 的美妙之处：name 值在不同的页面（甚至不同域名）加载后依旧存在，并且可以支持非常长的 name 值（2MB）。</li><li>postMessage（HTML5中的XMLHttpRequest Level 2中的API）<br>1) a.com/index.html中的代码：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs plain">&lt;iframe id&#x3D;&quot;ifr&quot; src&#x3D;&quot;b.com&#x2F;index.html&quot;&gt;&lt;&#x2F;iframe&gt;<br>&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;<br>window.onload &#x3D; function() &#123;<br>    var ifr &#x3D; document.getElementById(&#39;ifr&#39;);<br>    var targetOrigin &#x3D; &#39;http:&#x2F;&#x2F;b.com&#39;;  <br>    &#x2F;* 若写成&#39;http:&#x2F;&#x2F;b.com&#x2F;c&#x2F;proxy.html&#39;效果一样 *&#x2F;<br>    &#x2F;* 若写成&#39;http:&#x2F;&#x2F;c.com&#39;就不会执行postMessage了 *&#x2F;<br>    ifr.contentWindow.postMessage(&#39;I was there!&#39;, targetOrigin);<br>&#125;;<br>&lt;&#x2F;script&gt;<br></code></pre></td></tr></table></figure>2) b.com/index.html中的代码：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs plain">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;<br>    window.addEventListener(&#39;message&#39;, function(event)&#123;<br>        &#x2F;&#x2F; 通过origin属性判断消息来源地址<br>        if (event.origin &#x3D;&#x3D; &#39;http:&#x2F;&#x2F;a.com&#39;) &#123;<br>            alert(event.data);    &#x2F;&#x2F; 弹出&quot;I was there!&quot;<br>            alert(event.source);  &#x2F;&#x2F; 对a.com、index.html中window对象的引用<br>                                  &#x2F;&#x2F; 但由于同源策略，这里event.source不可以访问window对象<br>        &#125;<br>    &#125;, false);<br>&lt;&#x2F;script&gt;<br></code></pre></td></tr></table></figure></li></ul><h3>documen.write和 innerHTML的区别</h3><p>document.write只能重绘整个页面<br>innerHTML可以重绘页面的一部分</p><h3>.call() 和 .apply() 的区别和作用？</h3><p>作用：调用一个对象的一个方法，用另一个对象替换当前对象。<br>B.apply(A, arguments);<br>B.call(A, args1,args2);</p><ul><li>call 与 apply 的相同点：<br>方法的含义是一样的，即方法功能是一样的；<br>第一个参数的作用是一样的；</li><li>call 与 apply 的不同点：两者传入的列表形式不一样<br>call可以传入多个参数；<br>apply只能传入两个参数，所以其第二个参数往往是作为数组形式传入</li></ul><h3>哪些操作会造成内存泄漏？</h3><p>内存泄漏指任何对象在您不再拥有或需要它之后仍然存在。<br>垃圾回收器定期扫描对象，并计算引用了每个对象的其他对象的数量。如果一个对象的引用数量为 0（没有其他对象引用过该对象），或对该对象的惟一引用是循环的，那么该对象的内存即可回收。<br>setTimeout 的第一个参数使用字符串而非函数的话，会引发内存泄漏。<br>闭包、控制台日志、循环（在两个对象彼此引用且彼此保留时，就会产生一个循环）</p><h3>什么叫优雅降级和渐进增强？</h3><p>优雅降级：Web站点在所有新式浏览器中都能正常工作，如果用户使用的是老式浏览器，则代码会检查以确认它们是否能正常工作。由于IE独特的盒模型布局问题，针对不同版本的IE的hack实践过优雅降级了,为那些无法支持功能的浏览器增加候选方案，使之在旧式浏览器上以某种形式降级体验却不至于完全失效.</p><p>渐进增强：从被所有浏览器支持的基本功能开始，逐步地添加那些只有新式浏览器才支持的功能,向页面增加无害于基础浏览器的额外样式和功能的。当浏览器支持时，它们会自动地呈现出来并发挥作用。</p><h3>WEB应用从服务器主动推送Data到客户端有那些方式？</h3><ol><li>html5 websocket</li><li>WebSocket 通过 Flash</li><li>XHR长时间连接</li><li>XHR Multipart Streaming</li><li>不可见的Iframe</li><li>script标签的长时间连接(可跨域)</li></ol><h3>对Node的优点和缺点提出了自己的看法？</h3><ul><li><p>（优点）因为Node是基于事件驱动和无阻塞的，所以非常适合处理并发请求，<br>因此构建在Node上的代理服务器相比其他技术实现（如Ruby）的服务器表现要好得多。<br>此外，与Node代理服务器交互的客户端代码是由javascript语言编写的，<br>因此客户端和服务器端都用同一种语言编写，这是非常美妙的事情。</p></li><li><p>（缺点）Node是一个相对新的开源项目，所以不太稳定，它总是一直在变，<br>而且缺少足够多的第三方库支持。看起来，就像是Ruby/Rails当年的样子。</p></li></ul><h3>你有哪些性能优化的方法？</h3><ol><li>减少http请求次数：CSS Sprites, JS、CSS源码压缩、图片大小控制合适；网页Gzip，CDN托管，data缓存 ，图片服务器。</li><li>前端模板 JS+数据，减少由于HTML标签导致的带宽浪费，前端用变量保存AJAX请求结果，每次操作本地变量，不用请求，减少请求次数</li><li>用innerHTML代替DOM操作，减少DOM操作次数，优化javascript性能。</li><li>当需要设置的样式很多时设置className而不是直接操作style。</li><li>少用全局变量、缓存DOM节点查找的结果。减少IO读取操作。</li><li>避免使用CSS Expression（css表达式）又称Dynamic properties(动态属性)。</li><li>图片预加载，将样式表放在顶部，将脚本放在底部 加上时间戳。</li></ol><h3>http状态码有那些？分别代表是什么意思？</h3><p>100-199 用于指定客户端应相应的某些动作。<br>200-299 用于表示请求成功。<br>300-399 用于已经移动的文件并且常被包含在定位头信息中指定新的地址信息。<br>400-499 用于指出客户端的错误。400 1、语义有误，当前请求无法被服务器理解。401 当前请求需要用户验证 403 服务器已经理解请求，但是拒绝执行它。<br>500-599 用于支持服务器错误。 503 – 服务不可用</p><h3>一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？</h3><p>分为4个步骤：<br>（1），当发送一个URL请求时，不管这个URL是Web页面的URL还是Web页面上每个资源的URL，浏览器都会开启一个线程来处理这个请求，同时在远程DNS服务器上启动一个DNS查询。这能使浏览器获得请求对应的IP地址。<br>（2）， 浏览器与远程Web服务器通过TCP三次握手协商来建立一个TCP/IP连接。该握手包括一个同步报文，一个同步-应答报文和一个应答报文，这三个报文在 浏览器和服务器之间传递。该握手首先由客户端尝试建立起通信，而后服务器应答并接受客户端的请求，最后由客户端发出该请求已经被接受的报文。<br>（3），一旦TCP/IP连接建立，浏览器会通过该连接向远程服务器发送HTTP的GET请求。远程服务器找到资源并使用HTTP响应返回该资源，值为200的HTTP响应状态表示一个正确的响应。<br>（4），此时，Web服务器提供资源服务，客户端开始下载资源。</p><p>请求返回后，便进入了我们关注的前端模块<br>简单来说，浏览器会解析HTML生成DOM Tree，其次会根据CSS生成CSS Rule Tree，而javascript又可以根据DOM API操作DOM</p><h3>javascript对象的几种创建方式</h3><ol><li><p>工厂模式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs plain">function createPerson(name,age,job)&#123;<br>    var o &#x3D; new Object();<br>    o.name &#x3D; name;<br>    o.age &#x3D; age;<br>    o.job &#x3D; job;<br>    o.sayname &#x3D; function()&#123;<br>        alert(this.name);<br>    &#125;;<br>    return o;<br>&#125;<br>var person1 &#x3D; createPerson(&quot;a&quot;,29,&quot;cc&quot;);<br>var person2 &#x3D; createPerson(&quot;b&quot;,26,&quot;cc&quot;);<br></code></pre></td></tr></table></figure></li><li><p>构造函数模式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs plain">function Person(name,age,job)&#123;<br>    this.name &#x3D; name;<br>    this.age &#x3D; age;<br>    this.job &#x3D; job;<br>    this.sayname &#x3D; function()&#123;<br>        alert(this.name);<br>    &#125;;<br>&#125;<br>var person1 &#x3D; new Person(&quot;a&quot;,29,&quot;cc&quot;);<br>var person2 &#x3D; new Person(&quot;b&quot;,26,&quot;cc&quot;);<br></code></pre></td></tr></table></figure><p>使用自定义的构造函数，可以将它的实例标识为一种特定的类型，这正是构造函数模式胜过工厂模式的地方。<br>比如（instanceof用于检测对象类型）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">person1 instanceof Person  &#x2F;&#x2F;true    这里可以看到person1也是Person的实例，而工厂模式没有能具体检测对象类型的这一特定<br>person1 instanceof Object &#x2F;&#x2F;true    所有对象均继承自Object<br></code></pre></td></tr></table></figure><p>构造函数模式的主要问题，就是每个方法都要在每个实例对象上重新创建一遍，即使是同名方法或者两个方法的作用一样，而不同实例对象上的同名方法其实是不一样的，这样就造成了一种冗余，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">person1.sayname !&#x3D; person2.sayname<br></code></pre></td></tr></table></figure></li><li><p>原型模式</p></li></ol><p>使用原型对象的好处就是，可以让所有对象实例共享它所包含的属性和方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs plain">function Person()&#123;&#125;<br>Person.prototype.name&#x3D;&quot;a&quot;;<br>Person.prototype.age&#x3D;&quot;29&quot;;<br>Person.prototype.job&#x3D;&quot;cc&quot;;<br>Person.prototype.sayname &#x3D; function()&#123;<br>        alert(this.name);<br>&#125;;<br>var person1 &#x3D; new Person();<br>var person2 &#x3D; new Person();<br>这样person1.sayname &#x3D;&#x3D; person2.sayname<br></code></pre></td></tr></table></figure><ol start="4"><li>混合构造函数和原型模式<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs plain">function createPerson(name,age,job)&#123;<br>    var o &#x3D; new Object();<br>    o.name &#x3D; name;<br>    o.age &#x3D; age;<br>    o.job &#x3D; job;<br>    o.sayname &#x3D; function()&#123;<br>        alert(this.name);<br>    &#125;;<br>    return o;<br>&#125;<br>var person1 &#x3D; createPerson(&quot;a&quot;,29,&quot;cc&quot;);<br>var person2 &#x3D; createPerson(&quot;b&quot;,26,&quot;cc&quot;);<br></code></pre></td></tr></table></figure></li><li>动态原型模式</li><li>寄生构造函数模式</li><li>稳妥构造函数模式</li></ol><h3>ajax过程</h3><p>(1)创建XMLHttpRequest对象,也就是创建一个异步调用对象.<br>(2)创建一个新的HTTP请求,并指定该HTTP请求的方法、URL及验证信息.<br>(3)设置响应HTTP请求状态变化的函数.<br>(4)发送HTTP请求.<br>(5)获取异步调用返回的数据.<br>(6)使用JavaScript和DOM实现局部刷新.</p><h3>异步加载和延迟加载</h3><p>1.异步加载的方案： 动态插入script标签<br>2.通过ajax去获取js代码，然后通过eval执行<br>3.script标签上添加defer或者async属性<br>4.创建并插入iframe，让它异步执行js<br>5.延迟加载：有些 js 代码并不是页面初始化的时候就立刻需要的，而稍后的某些情况才需要的。</p><h3>前端安全问题？</h3><ol><li>SQL注入：<br>这个比较常见，可能大家也听说过，就是URL里面如果有对数据库进行操作的参数时，要做一下特殊的处理，<br>否则被别有用心的人利用的话就可能酿成大错，轻则用户信息泄露，重则数据库被删.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">(1) 防止系统敏感信息泄露。设置php.ini选项display_errors&#x3D;off，防止php脚本出错之后，在web页面输出敏感信息错误，让攻击者有机可乘。<br>(2) 数据转义。设置php.ini选项magic_quotes_gpc&#x3D;on，它会将提交的变量中所有的’(单引号)，”(双引号)，\(反斜杠)，空白字符等都在前面自动加上\。或者采用mysql_real_escape()函数或addslashes()函数进行输入参数的转义。<br>(3) 增加黑名单或者白名单验证。白名单验证一般指，检查用户输入是否是符合预期的类型、长度、数值范围或者其他格式标准。黑名单验证是指，若在用户输入中，包含明显的恶意内容则拒绝该条用户请求。在使用白名单验证时，一般会配合黑名单验证。<br></code></pre></td></tr></table></figure></li><li>XSS 全称跨站脚本攻击<br>这个大家都做过处理，但是并不一定知道名字，（Cross Site Scripting, 安全专家们通常将其缩写成XSS,原本应当是css，但为了和层叠样式表（Cascading Style Sheet,CSS ）有所区分，故称XSS）,<br>这种问题通常是由于对用户的输入没有严格的加以过滤导致的<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs plain">(1) 输入过滤。永远不要相信用户的输入，对用户输入的数据做一定的过滤。如输入的数据是否符合预期的格式，比如日期格式，Email格式，电话号码格式等等。这样可以初步对XSS漏洞进行防御。上面的措施只在web端做了限制，攻击者通抓包工具如Fiddler还是可以绕过前端输入的限制，修改请求注入攻击脚本。<br>因此，后台服务器需要在接收到用户输入的数据后，对特殊危险字符进行过滤或者转义处理，然后再存储到数据库中。<br><br>(2) 输出编码。服务器端输出到浏览器的数据，可以使用系统的安全函数来进行编码或转义来防范XSS攻击。在PHP中，有htmlentities()和htmlspecialchars()两个函数可以满足安全要求。相应的JavaScript的编码方式可以使用JavascriptEncode。<br><br>(3) 安全编码。开发需尽量避免Web客户端文档重写、重定向或其他敏感操作，同时要避免使用客户端数据，这些操作需尽量在服务器端使用动态页面来实现。<br><br>(4) HttpOnly Cookie。预防XSS攻击窃取用户cookie最有效的防御手段。Web应用程序在设置cookie时，将其属性设为HttpOnly，就可以避免该网页的cookie被客户端恶意JavaScript窃取，保护用户cookie信息。<br><br>(5)WAF(Web Application Firewall)，Web应用防火墙，主要的功能是防范诸如网页木马、XSS以及CSRF等常见的Web漏洞攻击。由第三方公司开发，在企业环境中深受欢迎<br></code></pre></td></tr></table></figure></li><li>CSRF （Cross-site request forgery）跨站请求伪造<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plain">(1) 验证码。应用程序和用户进行交互过程中，特别是账户交易这种核心步骤，强制用户输入验证码，才能完成最终请求。在通常情况下，验证码够很好地遏制CSRF攻击。但增加验证码降低了用户的体验，网站不能给所有的操作都加上验证码。所以只能将验证码作为一种辅助手段，在关键业务点设置验证码。<br><br>(2) Referer Check。HTTP Referer是header的一部分，当浏览器向web服务器发送请求时，一般会带上Referer信息告诉服务器是从哪个页面链接过来的，服务器籍此可以获得一些信息用于处理。可以通过检查请求的来源来防御CSRF攻击。正常请求的referer具有一定规律，如在提交表单的referer必定是在该页面发起的请求。所以通过检查http包头referer的值是不是这个页面，来判断是不是CSRF攻击。但在某些情况下如从https跳转到http，浏览器处于安全考虑，不会发送referer，服务器就无法进行check了。若与该网站同域的其他网站有XSS漏洞，那么攻击者可以在其他网站注入恶意脚本，受害者进入了此类同域的网址，也会遭受攻击。出于以上原因，无法完全依赖Referer Check作为防御CSRF的主要手段。但是可以通过Referer Check来监控CSRF攻击的发生。<br><br>(3) Anti CSRF Token。目前比较完善的解决方案是加入Anti-CSRF-Token，即发送请求时在HTTP 请求中以参数的形式加入一个随机产生的token，并在服务器建立一个拦截器来验证这个token。服务器读取浏览器当前域cookie中这个token值，会进行校验该请求当中的token和cookie当中的token值是否都存在且相等，才认为这是合法的请求。否则认为这次请求是违法的，拒绝该次服务。这种方法相比Referer检查要安全很多，token可以在用户登陆后产生并放于session或cookie中，然后在每次请求时服务器把token从session或cookie中拿出，与本次请求中的token 进行比对。由于token的存在，攻击者无法再构造出一个完整的URL实施CSRF攻击。但在处理多个页面共存问题时，当某个页面消耗掉token后，其他页面的表单保存的还是被消耗掉的那个token，其他页面的表单提交时会出现token错误<br></code></pre></td></tr></table></figure></li><li>文件上传漏洞<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plain">(1) 检查服务器是否判断了上传文件类型及后缀。<br><br>(2) 定义上传文件类型白名单，即只允许白名单里面类型的文件上传。<br><br>(3) 文件上传目录禁止执行脚本解析，避免攻击者进行二次攻击。  Info漏洞 Info漏洞就是CGI把输入的参数原样输出到页面，攻击者通过修改输入参数而达到欺骗用户的目的。<br></code></pre></td></tr></table></figure></li></ol><h3>ie各版本和chrome可以并行下载多少个资源</h3><p>IE6 两个并发，iE7升级之后的6个并发，之后版本也是6个<br>Firefox，chrome也是6个</p><h3>javascript里面的继承怎么实现，如何避免原型链上面的对象共享</h3><p>用构造函数和原型链的混合模式去实现继承，避免对象共享可以参考经典的extend()函数，很多前端框架都有封装的，就是用一个空函数当做中间变量<br>1.利用原型来继承,通过增加一个空的函数来避免原型链上的对象共享</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plain">var a &#x3D; &#123;name：“小明”&#125;；<br>var b &#x3D; cloneObj(a);<br> function cloneObj(obj)&#123;<br>        var f &#x3D; function(）&#123;&#125;；<br>        f.prototype &#x3D; obj;<br>        return new f();<br>&#125;<br></code></pre></td></tr></table></figure><p>2.使用extend，多用于插件封装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plain">示例：<br>Var item&#x3D;&#123;name:”olive”,age:23&#125;;<br>Var item1&#x3D;&#123;name:”Momo”,sex:”gril”&#125;;<br>Var result&#x3D;$.extend(&#123;&#125;,item,item1);<br>结果：<br>Result&#x3D;&#123;name:”Momo”,age:23,sex:”gril”&#125;;<br></code></pre></td></tr></table></figure><p>Flash、Ajax各自的优缺点，在使用中如何取舍？</p><h3>Flash ajax对比</h3><p>Flash适合处理多媒体、矢量图形、访问机器；对CSS、处理文本上不足，不容易被搜索。<br>Ajax对CSS、文本支持很好，支持搜索；多媒体、矢量图形、机器访问不足。<br>共同点：与服务器的无刷新传递消息、用户离线和在线状态、操作DOM</p><h3>请解释一下 JavaScript 的同源策略。</h3><p>概念:同源策略是客户端脚本（尤其是Netscape Navigator2.0，其目的是防止某个文档或脚本从多个不同源装载。<br>这里的同源策略指的是：协议，域名，端口相同，同源策略是一种安全协议。<br>指一段脚本只能读取来自同一来源的窗口和文档的属性。</p><p>为什么要有同源限制？<br>比如一个黑客程序，他利用Iframe把真正的银行登录页面嵌到他的页面上，当你使用真实的用户名，密码登录时，他的页面就可以通过Javascript读取到你的表单中input中的内容，这样用户名，密码就轻松到手了。</p><h3>什么是 "use strict"; ? 使用它的好处和坏处分别是什么？</h3><p>“use strict” =&gt; 严格模式”<br>是一种在JavaScript代码运行时自动实行更严格解析和错误处理的方法。这种模式使得Javascript在更严格的条件下运行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs plain">function doSomething() &#123; <br>&quot;use strict&quot;; <br> 严格模式下运行 <br>&#125;<br><br>function doSomethingElse() &#123; <br> 非严格模式下运行 <br>&#125;<br></code></pre></td></tr></table></figure><ul><li>设立”严格模式”的目的，主要有以下几个：</li></ul><ul><li>消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为;</li><li>消除代码运行的一些不安全之处，保证代码运行的安全；</li><li>提高编译器效率，增加运行速度；</li><li>为未来新版本的Javascript做好铺垫。<br>注：经过测试 ie6,7,8,9均不支持</li></ul><ul><li>缺点：<br>现在网站的 JS 都会进行压缩，一些文件用了严格模式，而另一些没有。这时这些本来是严格模式的文件，被 merge 后，这个串就到了文件的中间，不仅没有指示严格模式，反而在压缩后浪费了字节。</li></ul><h3>GET和POST的区别，何时使用POST？</h3><p>GET：一般用于信息获取，使用URL传递参数，对所发送信息的数量也有限制，一般在2000个字符<br>POST：一般用于修改服务器上的资源，对所发送的信息没有限制。</p><p>GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form来获取变量的值，<br>也就是说Get是通过地址栏来传值，而Post是通过提交表单来传值。</p><p>然而，在以下情况中，请使用 POST 请求：<br>无法使用缓存文件（更新服务器上的文件或数据库）<br>向服务器发送大量数据（POST 没有数据量限制）<br>发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠</p><h3>哪些地方会出现css阻塞，哪些地方会出现js阻塞？</h3><h5>1. js的阻塞特性：</h5><p>所有浏览器在下载JS的时候,会阻止一切其他活动,比如其他资源的下载,内容的呈现等等。<br>直到JS下载、解析、执行完毕后才开始继续并行下载其他资源并呈现内容。<br>为了提高用户体验,新一代浏览器都支持并行下载JS,但是JS下载仍然会阻塞其它资源的下载（例如.图片,css文件等）。</p><ul><li>由于浏览器为了防止出现JS修改DOM树,需要重新构建DOM树的情况,所以就会阻塞其他的下载和呈现。<br>嵌入JS会阻塞所有内容的呈现,而外部JS只会阻塞其后内容的显示,2种方式都会阻塞其后资源的下载。<br>也就是说外部样式不会阻塞外部脚本的加载,但会阻塞外部脚本的执行。</li></ul><h5>2. CSS怎么会阻塞加载了？</h5><p>CSS本来是可以并行下载的,在什么情况下会出现阻塞加载了(在测试观察中,IE6下CSS都是阻塞加载）</p><ul><li>当CSS后面跟着嵌入的JS的时候,该CSS就会出现阻塞后面资源下载的情况;</li><li>而当把嵌入JS放到CSS前面,就不会出现阻塞的情况了。</li><li>根本原因：因为浏览器会维持html中css和js的顺序,样式表必须在嵌入的JS执行前先加载、解析完。而嵌入的JS会阻塞后面的资源加载,所以就会出现上面CSS阻塞下载的情况。</li></ul><h5>3. 嵌入JS应该放在什么位置？</h5><p>1、放在底部,虽然放在底部照样会阻塞所有呈现,但不会阻塞资源下载。<br>2、如果嵌入JS放在head中,请把嵌入JS放在CSS头部。<br>3、使用defer（只支持IE）<br>4、不要在嵌入的JS中调用运行时间较长的函数,如果一定要用,可以用<code>setTimeout</code>来调用</p><h3>eval是做什么的？</h3><p>eval的功能是把字符串参数解析成JS代码并运行，并返回执行的结果；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">eval(&quot;2+3&quot;);&#x2F;&#x2F;执行加运算，并返回运算值。<br>eval(&quot;var age&#x3D;10&quot;);&#x2F;&#x2F;声明一个age变量<br></code></pre></td></tr></table></figure><p>eval的作用域在它所有的范围内容有效</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plain">functiona()&#123;<br> eval(&quot;var x&#x3D;1&quot;);&#x2F;* 等效于 var x&#x3D;1 *&#x2F;;<br><br> console.log(x);&#x2F;* 输出1 *&#x2F;<br>&#125;<br>a();<br>console.log(x);&#x2F;&#x2F;错误 x没有定<br></code></pre></td></tr></table></figure><p>应该避免使用eval，不安全，非常耗性能（2次，一次解析成js语句，一次执行）。<br>由JSON字符串转换为JSON对象的时候可以用eval，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">varjson&#x3D;&quot;&#123;name:&#39;Mr.CAO&#39;,age:30&#125;&quot;;<br>varjsonObj&#x3D;eval(&quot;(&quot;+json+&quot;)&quot;);<br>console.log(jsonObj);<br></code></pre></td></tr></table></figure><h3>JavaScript原型，原型链 ? 有什么特点？</h3><ul><li>原型对象也是普通的对象，是对象一个自带隐式的 <strong>proto</strong> 属性，原型也有可能有自己的原型，如果一个原型对象的原型不为null的话，我们就称之为原型链。</li><li>每个对象都会在其内部初始化一个属性，就是prototype(原型)，当我们访问一个对象的属性时，如果这个对象内部不存在这个属性，那么他就会去prototype里找这个属性，这个prototype又会有自己的prototype,于是就这样一直找下去，也就是我们平时所说的原型链的概念。</li><li>原型链是由一些用来继承和共享属性的对象组成的（有限的）对象链。</li></ul><h3>页面重构怎么操作？</h3><p>页面重构就是根据原有页面内容和结构的基础上，通过div+css写出符合web标准的页面结构。<br>具体实现要达到以下三点：</p><ol><li>结构完整，可通过标准验证</li><li>标签语义化，结构合理</li><li>充分考虑到页面在站点中的“作用和重要性”，并对其进行有针对性的优化</li></ol><p>事件、IE与火狐的事件机制有什么区别？ 如何阻止冒泡？</p><ol><li>我们在网页中的某个操作（有的操作对应多个事件）。例如：当我们点击一个按钮就会产生一个事件。是可以被 JavaScript 侦测到的行为。</li><li>事件处理机制：IE是事件冒泡、firefox同时支持两种事件模型，也就是：捕获型事件和冒泡型事件。；</li><li>ev.stopPropagation();注意旧ie的方法 ev.cancelBubble = true;</li></ol><h3>ajax 是什么?ajax 的交互模型?同步和异步的区别?如何解决跨域问题?</h3><h5>1. Ajax的优点是什么。</h5><p>1、通过异步模式，提升了用户体验<br>2、优化了浏览器和服务器之间的传输，减少不必要的数据往返，减少了带宽占用<br>3、Ajax在客户端运行，承担了一部分本来由服务器承担的工作，减少了大用户量下的服务器负载。</p><h5>2. Ajax的最大的特点是什么。</h5><p>Ajax可以实现动态不刷新（局部刷新）<br>readyState属性 状态 有5个可取值： 0=未初始化 ，1=启动 2=发送，3=接收，4=完成</p><h5>3. ajax的缺点</h5><p>1、ajax不支持浏览器back按钮。<br>2、安全问题 AJAX暴露了与服务器交互的细节。<br>3、对搜索引擎的支持比较弱。<br>4、破坏了程序的异常机制。<br>5、不容易调试。</p><h5>4. 解决跨域</h5><p>1、响应头添加Header允许访问<br>2、jsonp 只支持get请求不支持post请求<br>3、httpClient内部转发<br>4、使用接口网关——nginx、springcloud zuul   (互联网公司常规解决方案)</p><h3>js对象的深度克隆</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs plain">function clone(Obj) &#123;<br>    var buf;<br>    if (Obj instanceof Array) &#123;<br>        buf &#x3D; []; &#x2F;&#x2F;创建一个空的数组<br>        var i &#x3D; Obj.length;<br>        while (i--) &#123;<br>            buf[i] &#x3D; clone(Obj[i]);<br>        &#125;<br>        return buf;<br>    &#125;else if (Obj instanceof Object)&#123;<br>        buf &#x3D; &#123;&#125;; &#x2F;&#x2F;创建一个空对象<br>        for (var k in Obj) &#123; &#x2F;&#x2F;为这个对象添加新的属性<br>            buf[k] &#x3D; clone(Obj[k]);<br>        &#125;<br>        return buf;<br>    &#125;else&#123;<br>        return Obj;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></h1></h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;存储&lt;/h1&gt;
&lt;h3&gt;请你谈谈Cookie的弊端&lt;/h3&gt;

&lt;p&gt;1.IE6或更低版本最多20个cookie&lt;br&gt;2.IE7和之后的版本最后可以有50个cookie。&lt;br&gt;3.Firefox最多50个cookie&lt;br&gt;4.chrome和Safari没有做硬性限制
      
    
    </summary>
    
    
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>js优化细则整理</title>
    <link href="http://yoursite.com/2020/04/23/js%E4%BC%98%E5%8C%96%E7%BB%86%E5%88%99%E6%95%B4%E7%90%86/"/>
    <id>http://yoursite.com/2020/04/23/js%E4%BC%98%E5%8C%96%E7%BB%86%E5%88%99%E6%95%B4%E7%90%86/</id>
    <published>2020-04-23T01:31:47.000Z</published>
    <updated>2020-04-23T09:56:19.882Z</updated>
    
    <content type="html"><![CDATA[<p>DOM编程</p><h3>建议将对象进行缓存处理，特别是DOM访问是比较消耗资源的</h3>使用DocumentFragment优化多次append一旦需要更新DOM,请考虑使用文档碎片来构建DOM结构，然后再将其添加到现存的文档中。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs plain">for (var i &#x3D; 0; i &lt; 1000; i++) &#123;<br>      var el &#x3D; document.createElement(&#39;p&#39;);<br>      el.innerHTML &#x3D; i;<br>      document.body.appendChild(el);<br>    &#125;<br>&#x2F;*可以替换为⬇*&#x2F;<br>var frag &#x3D; document.createDocumentFragment();<br>for (var i &#x3D; 0; i &lt; 1000; i++) &#123;<br>  var el &#x3D; document.createElement(&#39;p&#39;);<br>  el.innerHTML &#x3D; i;<br>  frag.appendChild(el);<br>&#125;<br>document.body.appendChild(frag);<br></code></pre></td></tr></table></figure><h3>使用一次innerHTML赋值代替构建dom元素</h3>对于大的DOM更改，使用innerHTML要比使用标准的DOM方法创建同样的DOM结构快得多。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs plain">var frag &#x3D; document.createDocumentFragment();<br>for (var i &#x3D; 0; i &lt; 1000; i++) &#123;<br>  var el &#x3D; document.createElement(&#39;p&#39;);<br>  el.innerHTML &#x3D; i;<br>  frag.appendChild(el);<br>&#125;<br>document.body.appendChild(frag);<br>&#x2F;*可以替换为⬇*&#x2F;<br>var html &#x3D; [];<br>for (var i &#x3D; 0; i &lt; 1000; i++) &#123;<br>  html.push(&#39;&lt;p&gt;&#39; + i + &#39;&lt;&#x2F;p&gt;&#39;);<br>&#125;<br>document.body.innerHTML &#x3D; html.join(&#39;&#39;);<br></code></pre></td></tr></table></figure><h3>通过模板元素clone，替代createElement</h3>很多人喜欢在JavaScript中使用document.write来给页面生成内容。事实上这样的效率较低，如果需要直接插入HTML，可以找一个容器元素，比如指定一个div或者span，并设置他们的innerHTML来将自己的HTML代码插入到页面中。通常我们可能会使用字符串直接写HTML来创建节点，其实这样做，1无法保证代码的有效性2字符串操作效率低，所以应该是用document.createElement()方法，而如果文档中存在现成的样板节点，应该是用cloneNode()方法，因为使用createElement()方法之后，你需要设置多次元素的属性，使用cloneNode()则可以减少属性的设置次数——同样如果需要创建很多元素，应该先准备一个样板节点<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs plain">var frag &#x3D; document.createDocumentFragment();<br>for (var i &#x3D; 0; i &lt; 1000; i++) &#123;<br>  var el &#x3D; document.createElement(&#39;p&#39;);<br>  el.innerHTML &#x3D; i;<br>  frag.appendChild(el);<br>&#125;<br>document.body.appendChild(frag);<br>&#x2F;*可以替换为⬇*&#x2F;<br>var frag &#x3D; document.createDocumentFragment();<br>var pEl &#x3D; document.getElementsByTagName(&#39;p&#39;)[0];<br>for (var i &#x3D; 0; i &lt; 1000; i++) &#123;<br>  var el &#x3D; pEl.cloneNode(false);<br>  el.innerHTML &#x3D; i;<br>  frag.appendChild(el);<br>&#125;<br>document.body.appendChild(frag);<br></code></pre></td></tr></table></figure><h3>使用firstChild和nextSibling代替childNodes遍历dom元素</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs plain">var nodes &#x3D; element.childNodes;<br>for (var i &#x3D; 0, l &#x3D; nodes.length; i &lt; l; i++) &#123;<br>  var node &#x3D; nodes[i];<br>  ……<br>&#125;<br>&#x2F;*可以替换为⬇*&#x2F;<br>var node &#x3D; element.firstChild;<br>while (node) &#123;<br>……<br>node &#x3D; node.nextSibling;<br></code></pre></td></tr></table></figure><h3>删除DOM节点</h3>删除dom节点之前,一定要删除注册在该节点上的事件,不管是用observe方式还是用attachEvent方式注册的事件,否则将会产生无法回收的内存。另外，在removeChild和innerHTML=''二者之间,尽量选择后者. 因为在sIEve(内存泄露监测工具)中监测的结果是用removeChild无法有效地释放dom节点<h3>使用事件代理</h3>任何可以冒泡的事件都不仅仅可以在事件目标上进行处理，目标的任何祖先节点上也能处理，使用这个知识就可以将事件处理程序附加到更高的地方负责多个目标的事件处理，同样，对于内容动态增加并且子节点都需要相同的事件处理函数的情况，可以把事件注册提到父节点上，这样就不需要为每个子节点注册事件监听了。另外，现有的js库都采用observe方式来创建事件监听,其实现上隔离了dom对象和事件处理函数之间的循环引用,所以应该尽量采用这种方式来创建事件监听重复使用的调用结果，事先保存到局部变量<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plain">&#x2F;*避免多次取值的调用开销*&#x2F;<br>var h1 &#x3D; element1.clientHeight + num1;<br>var h2 &#x3D; element1.clientHeight + num2;<br>&#x2F;*可以替换为⬇*&#x2F;<br>var eleHeight &#x3D; element1.clientHeight;<br>var h1 &#x3D; eleHeight + num1;<br>var h2 &#x3D; eleHeight + num2;<br></code></pre></td></tr></table></figure><h3>注意NodeList</h3>最小化访问NodeList的次数可以极大的改进脚本的性能 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">var images &#x3D; document.getElementsByTagName(&#39;img&#39;);<br>for (var i &#x3D; 0, len &#x3D; images.length; i &lt; len; i++) &#123;<br>&#125;<br></code></pre></td></tr></table></figure>编写JavaScript的时候一定要知道何时返回NodeList对象，这样可以最小化对它们的访问<p>进行了对getElementsByTagName()的调用<br>获取了元素的childNodes属性<br>获取了元素的attributes属性<br>访问了特殊的集合，如document.forms、document.images等等</p><p>要了解了当使用NodeList对象时，合理使用会极大的提升代码执行速度<br>算法和流程控制,建议不要在函数内进行过深的嵌套判断<br>尽量不要用for-in 循环去访问数组，建议用 for 循环进行循环</p><h3>优化循环</h3>可以使用下面几种方式来优化循环<ol><li>倒序循环<br>大多数循环使用一个从0开始、增加到某个特定值的迭代器，在很多情况下，从最大值开始，在循环中不断减值的迭代器更加高效<br>参考文章：javascript for循环从入门到偏门(效率优化+奇特用法)<br>把减法操作放到控制条件中，例如：i–，这样只是比较“它是true吗？”速度更快。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plain">var i &#x3D; arr.length;<br>for(;i&gt;0;i--)&#123; <br>    alert(i); <br>&#125;<br></code></pre></td></tr></table></figure></li><li>简化终止条件<br>由于每次循环过程都会计算终止条件，所以必须保证它尽可能快，也就是说避免属性查找或者其它的操作，最好是将循环控制量保存到局部变量中，也就是说对数组或列表对象的遍历时，提前将length保存到局部变量中，避免在循环的每一步重复取值。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs plain">var list &#x3D; document.getElementsByTagName(&#39;p&#39;);<br>for (var i &#x3D; 0; i &lt; list.length; i++) &#123;<br>  ……<br>&#125;<br>&#x2F;*可以替换为⬇*&#x2F;<br>var list &#x3D; document.getElementsByTagName(&#39;p&#39;);<br>for (var i &#x3D; 0, l &#x3D; list.length; i &lt; l; i++) &#123;<br>  ……<br>&#125;<br></code></pre></td></tr></table></figure></li><li>简化循环体<br>循环体是执行最多的，所以要确保其被最大限度的优化<br>使用后测试循环<br>在JavaScript中，我们可以使用for(;;),while(),for(in)三种循环，事实上，这三种循环中for(in)的效率极差，因为他需要查询散列键，只要可以，就应该尽量少用。for(;;)和while循环，while循环的效率要优于for(;;)，可能是因为for(;;)结构的问题，需要经常跳转回去。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plain">var arr &#x3D; [1, 2, 3, 4, 5, 6, 7];var sum &#x3D; 0;for (var i &#x3D; 0, l &#x3D; arr.length; i &lt; l; i++) &#123;<br>  sum +&#x3D; arr[i];<br>&#125;<br>&#x2F;*可以替换为⬇*&#x2F;<br>var arr &#x3D; [1, 2, 3, 4, 5, 6, 7];var sum &#x3D; 0, l &#x3D; arr.length;while (l--) &#123;<br>  sum +&#x3D; arr[l];<br>&#125;<br></code></pre></td></tr></table></figure>最常用的for循环和while循环都是前测试循环，而如do-while这种后测试循环，可以避免最初终止条件的计算，因此运行更快。</li><li>展开循环<br>当循环次数是确定的，消除循环并使用多次函数调用往往会更快。</li><li>避免双重解释<br>如果要提高代码性能，尽可能避免出现需要按照JavaScript解释的字符串，也就是尽量少使用eval函数<br>使用eval相当于在运行时再次调用解释引擎对内容进行运行，需要消耗大量时间，而且使用Eval带来的安全性问题也是不容忽视的。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs plain">不要使用Function构造器,不要给setTimeout或者setInterval传递字符串参数<br>var num &#x3D; 0;<br>setTimeout(&#39;num++&#39;, 10);<br>&#x2F;*可以替换为⬇*&#x2F;<br>var num &#x3D; 0;<br>function addNum() &#123;<br>  num++;<br>&#125;<br>setTimeout(addNum, 10);<br></code></pre></td></tr></table></figure></li><li>缩短否定检测<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs plain">if (oTest !&#x3D; &#39;#ff0000&#39;) &#123;<br>  &#x2F;&#x2F;do something<br>&#125;if (oTest !&#x3D; null) &#123;<br>  &#x2F;&#x2F;do something<br>&#125;if (oTest !&#x3D; false) &#123;<br>  &#x2F;&#x2F;do something<br>&#125;<br>&#x2F;&#x2F;虽然这些都正确，但用逻辑非操作符来操作也有同样的效果<br>if (!oTest) &#123;<br>  &#x2F;&#x2F;do something<br>&#125;<br></code></pre></td></tr></table></figure></li><li>条件分支<br>将条件分支，按可能性顺序从高到低排列：可以减少解释器对条件的探测次数<br>在同一条件子的多（&gt;2）条件分支时，使用switch优于if：switch分支选择的效率高于if，在IE下尤为明显。4分支的测试，IE下switch的执行时间约为if的一半。<br>使用三目运算符替代条件分支<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plain">if (a &gt; b) &#123;<br>  num &#x3D; a;<br>&#125; else &#123;<br>  num &#x3D; b;<br>&#125;<br>&#x2F;*可以替换为⬇*&#x2F;<br>num &#x3D; a &gt; b ? a : b;<br></code></pre></td></tr></table></figure></li></ol><h3>数据存取</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs plain">使用直接量<br>var aTest &#x3D; new Array(); <br>&#x2F;*可以替换为⬇*&#x2F;<br>var aTest &#x3D; [];<br>var aTest &#x3D; new Object; <br>&#x2F;*可以替换为⬇*&#x2F;<br>var aTest &#x3D; &#123;&#125;;<br>var reg &#x3D; new RegExp(); <br>&#x2F;*可以替换为⬇*&#x2F;<br>var reg &#x3D; &#x2F;..&#x2F;;<br>&#x2F;*如果要创建具有一些特性的一般对象，也可以使用字面量，如下：*&#x2F;<br>var oFruit &#x3D; new O;<br>oFruit.color &#x3D; &quot;red&quot;;<br>oFruit.name &#x3D; &quot;apple&quot;;<br>&#x2F;*前面的代码可用对象字面量来改写成这样：*&#x2F;<br>var oFruit &#x3D; &#123; color: &quot;red&quot;, name: &quot;apple&quot; &#125;;<br></code></pre></td></tr></table></figure><h3>字符串连接</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs plain">如果要连接多个字符串，应该少使用+&#x3D;，如<br>s+&#x3D;a;s+&#x3D;b;s+&#x3D;c;<br>应该写成s+&#x3D;a + b + c；<br>而如果是收集字符串，比如多次对同一个字符串进行+&#x3D;操作的话,<br>最好使用一个缓存，使用JavaScript数组来收集，最后使用join方法连接起来<br>var buf &#x3D; [];<br>for(vari &#x3D; 0; i &lt; 100; i++) &#123;<br>    buf.push(i.toString());<br>&#125;<br>var all &#x3D; buf.join(&quot;&quot;);<br></code></pre></td></tr></table></figure><h3>避免with语句</h3>和函数类似 ，with语句会创建自己的作用域，因此会增加其中执行的代码的作用域链的长度，由于额外的作用域链的查找，在with语句中执行的代码肯定会比外面执行的代码要慢，在能不使用with语句的时候尽量不要使用with语句。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs plain">with(a.b.c.d) &#123;<br>    property1 &#x3D; 1;<br>    property2 &#x3D; 2;<br>&#125;<br>&#x2F;*可以替换为⬇*&#x2F;<br>var obj &#x3D; a.b.c.d;<br>obj.property1 &#x3D; 1;<br>obj.property2 &#x3D; 2;<br></code></pre></td></tr></table></figure><h3>数字转换成字符串</h3>一般最好用""来将数字转换成字符串，虽然看起来比较丑一点，但事实上这个效率是最高的，性能上来说：<p>(“”) &gt; String() &gt; .toString() &gt; newString()</p><h3>浮点数转换成整型</h3>很多人喜欢使用parseInt()，其实parseInt()是用于将字符串转换成数字，而不是浮点数和整型之间的转换，我们应该使用Math.floor()或者Math.round()<h3>各种类型转换</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs plain">var myVar &#x3D; &quot;3.14159&quot;,<br>str &#x3D; &quot;&quot; + myVar, &#x2F;&#x2F; to string <br>i_int &#x3D; ~ ~myVar, &#x2F;&#x2F; to integer <br>f_float &#x3D; 1 * myVar, &#x2F;&#x2F; to float <br>b_bool &#x3D; !!myVar, <br>&#x2F;* to boolean - any string with length *&#x2F;<br>&#x2F;* and any number except 0 are true *&#x2F;<br>array &#x3D; [myVar]; &#x2F;&#x2F; to array<br></code></pre></td></tr></table></figure>如果定义了toString()方法来进行类型转换的话，推荐显式调用toString()，因为内部的操作在尝试所有可能性之后，会尝试对象的toString()方法尝试能否转化为String，所以直接调用这个方法效率会更高<h3>多个类型声明</h3>在JavaScript中所有变量都可以使用单个var语句来声明，这样就是组合在一起的语句，以减少整个脚本的执行时间，就如上面代码一样，上面代码格式也挺规范，让人一看就明了。<h3>使用常量</h3>重复值:任何在多处用到的值都应该抽取为一个常量<p>用户界面字符串:任何用于显示给用户的字符串，都应该抽取出来以方便国际化<br>URLs:在Web应用中，资源位置很容易变更，所以推荐用一个公共地方存放所有的URL<br>任意可能会更改的值:每当你用到字面量值的时候，你都要问一下自己这个值在未来是不是会变化，如果答案是“是”，那么这个值就应该被提取出来作为一个常量。</p><h3>避免与null进行比较</h3>由于JavaScript是弱类型的，所以它不会做任何的自动类型检查，所以如果看到与null进行比较的代码，尝试使用以下技术替换如果值应为一个引用类型，使用instanceof操作符检查其构造函数如果值应为一个基本类型，作用typeof检查其类型如果是希望对象包含某个特定的方法名，则使用typeof操作符确保指定名字的方法存在于对象上<h3>避免全局量</h3>全局变量应该全部字母大写，各单词之间用_下划线来连接。尽可能避免全局变量和函数, 尽量减少全局变量的使用，因为在一个页面中包含的所有JavaScript都在同一个域中运行。所以如果你的代码中声明了全局变量或者全局函数的话，后面的代码中载入的脚本文件中的同名变量和函数会覆盖掉（overwrite）你的。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs plain">&#x2F;&#x2F;糟糕的全局变量和全局函数<br>var current &#x3D; null;<br>function init()&#123;&#x2F;&#x2F;...<br>&#125;<br>function change() &#123;<br>  &#x2F;&#x2F;...<br>&#125;<br>function verify() &#123;<br>  &#x2F;&#x2F;...<br>&#125;<br>&#x2F;*解决办法有很多，Christian Heilmann建议的方法是*&#x2F;<br>&#x2F;*如果变量和函数不需要在“外面”引用，那么就可以使用一个没有名字的方法将他们全都包起来*&#x2F;<br>(function()&#123;<br>var current &#x3D; null;<br>function init() &#123;<br>  &#x2F;&#x2F;...<br>&#125;<br>function change() &#123;<br>  &#x2F;&#x2F;...<br>&#125;<br>function verify() &#123;<br>  &#x2F;&#x2F;...<br>&#125;<br>&#125;)();<br>&#x2F;&#x2F;如果变量和函数需要在“外面”引用，需要把你的变量和函数放在一个“命名空间”中&#x2F;&#x2F;我们这里用一个function做命名空间而不是一个var，因为在前者中声明function更简单，而且能保护隐私数据<br>myNameSpace &#x3D; function() &#123;<br>  var current &#x3D; null;<br>  function init() &#123;<br>    &#x2F;&#x2F;...<br>  &#125;<br>  function change() &#123;<br>    &#x2F;&#x2F;...<br>  &#125;<br>  function verify() &#123;<br>    &#x2F;&#x2F;...<br>  &#125;&#x2F;&#x2F;所有需要在命名空间外调用的函数和属性都要写在return里面<br>  return &#123;<br>    init: init,<br>    &#x2F;&#x2F;甚至你可以为函数和属性命名一个别名<br>    set: change<br>  &#125;;<br>&#125;;<br></code></pre></td></tr></table></figure><h3>避免全局查找</h3>将全局变量存储到局部变量中：因为全局变量总是存在于执行环境作用域链的最末端，所以，访问全局变量是最慢的，访问局部变量是最快的。尤其是对于未优化过的JavaScript引擎。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs plain">function search() &#123;<br>    &#x2F;*当我要使用当前页面地址和主机域名*&#x2F;<br>    alert(window.location.href + window.location.host);<br>&#125;<br>&#x2F;*最好的方式是如下这样 先用一个简单变量保存起来*&#x2F;<br>function search() &#123;<br>    var location &#x3D; window.location;<br>    alert(location.href + location.host);<br>&#125;<br></code></pre></td></tr></table></figure><h3>尊重对象的所有权</h3>因为JavaScript可以在任何时候修改任意对象，这样就可以以不可预计的方式覆写默认的行为，所以如果你不负责维护某个对象，它的对象或者它的方法，那么你就不要对它进行修改，具体一点就是说<ol><li>不要为实例或原型添加属性</li><li>不要为实例或者原型添加方法</li><li>不要重定义已经存在的方法</li><li>不要重复定义其它团队成员已经实现的方法，永远不要修改不是由你所有的对象，你可以通过以下方式为对象创建新的功能:<br> 1) 创建包含所需功能的新对象，并用它与相关对象进行交互<br> 2) 创建自定义类型，继承需要进行修改的类型，然后可以为自定义类型添加额外功能</li></ol><h3>定时器</h3>如果针对的是不断运行的代码，不应该使用setTimeout，而应该是用setInterval，因为setTimeout每一次都会初始化一个定时器，而setInterval只会在开始的时候初始化一个定时器<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs plain">var timeoutTimes &#x3D; 0;<br>functiontimeout() &#123;<br>    timeoutTimes++;<br>    if(timeoutTimes &lt; 10) &#123;<br>        setTimeout(timeout, 10);<br>    &#125;<br>&#125;<br>timeout();<br>&#x2F;*可以替换为⬇*&#x2F;<br>var intervalTimes &#x3D; 0<br>functioninterval() &#123;<br>    intervalTimes++;<br>    if(intervalTimes &gt;&#x3D; 10)&#123;<br>        clearInterval(interv);<br>    &#125;   <br>&#125;<br>var interv &#x3D; setInterval(interval, 10);<br></code></pre></td></tr></table></figure><h3>插入迭代器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">如var name&#x3D;values[i]; i++;<br>前面两条语句可以写成<br>var name&#x3D;values[i++]<br></code></pre></td></tr></table></figure><h3>循环引用</h3>如果循环引用中包含DOM对象或者ActiveX对象，那么就会发生内存泄露。内存泄露的后果是在浏览器关闭前，即使是刷新页面，这部分内存不会被浏览器释放。<ol><li>简单的循环引用：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs plain">var el &#x3D; document.getElementById(&#39;MyElement&#39;);<br>var func &#x3D; function () &#123;<br>  …<br>&#125;<br>el.func &#x3D; func;<br>func.element &#x3D; el;<br>但是通常不会出现这种情况。通常循环引用发生在为dom元素添加闭包作为expendo的时候。<br>function init() &#123;<br>  var el &#x3D; document.getElementById(&#39;MyElement&#39;);<br>  el.onclick &#x3D; function () &#123;<br>    ……<br>  &#125;<br>&#125;<br>init();<br>init在执行的时候，当前上下文我们叫做context。<br>这个时候，context引用了el，el引用了function，function引用了context。这时候形成了一个循环引用。<br></code></pre></td></tr></table></figure>下面2种方法可以解决循环引用：<br>1) 置空dom对象<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs plain">function init() &#123;<br>  var el &#x3D; document.getElementById(&#39;MyElement&#39;);<br>  el.onclick &#x3D; function () &#123;<br>    ……<br>  &#125;<br>&#125;<br>init();<br>&#x2F;*可以替换为⬇*&#x2F;<br>function init() &#123;<br>  var el &#x3D; document.getElementById(&#39;MyElement&#39;);<br>  el.onclick &#x3D; function () &#123;<br>    ……<br>  &#125;<br>  el &#x3D; null;<br>&#125;<br>init();<br>将el置空，context中不包含对dom对象的引用，从而打断循环应用。<br>如果我们需要将dom对象返回，可以用如下方法：<br>function init() &#123;<br>  var el &#x3D; document.getElementById(&#39;MyElement&#39;);<br>  el.onclick &#x3D; function () &#123;<br>    ……<br>  &#125;<br>  return el;<br>&#125;<br>init();<br>&#x2F;*可以替换为⬇*&#x2F;<br>function init() &#123;<br>  var el &#x3D; document.getElementById(&#39;MyElement&#39;);<br>  el.onclick &#x3D; function () &#123;<br>    ……<br>  &#125;<br>  try &#123;<br>    return el;<br>  &#125; finally &#123;<br>    el &#x3D; null;<br>  &#125;<br>&#125;<br>init();<br></code></pre></td></tr></table></figure>2) 构造新的context<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs plain">function init() &#123;<br>  var el &#x3D; document.getElementById(&#39;MyElement&#39;);<br>  el.onclick &#x3D; function () &#123;<br>    ……<br>  &#125;<br>&#125;<br>init();<br>&#x2F;*可以替换为⬇*&#x2F;<br>function elClickHandler() &#123;<br>  ……<br>&#125;<br>function init() &#123;<br>  var el &#x3D; document.getElementById(&#39;MyElement&#39;);<br>  el.onclick &#x3D; elClickHandler;<br>&#125;<br>init();<br>把function抽到新的context中，这样，function的context就不包含对el的引用，从而打断循环引用。<br>&#x2F;*---*&#x2F;<br>通过javascript创建的dom对象，必须append到页面中<br>IE下，脚本创建的dom对象，如果没有append到页面中，刷新页面，这部分内存是不会回收的！<br><br>function create() &#123;<br>  var gc &#x3D; document.getElementById(&#39;GC&#39;);<br>  for (var i &#x3D; 0; i &lt; 5000; i++) &#123;<br>    var el &#x3D; document.createElement(&#39;div&#39;);<br>    el.innerHTML &#x3D; &quot;test&quot;;<br>    下面这句可以注释掉，看看浏览器在任务管理器中，点击按钮然后刷新后的内存变化<br>    gc.appendChild(el);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3>释放dom元素占用的内存</h3>将dom元素的innerHTML设置为空字符串，可以释放其子元素占用的内存。在rich应用中，用户也许会在一个页面上停留很长时间，可以使用该方法释放积累得越来越多的dom元素使用的内存。<h3>释放javascript对象</h3>在rich应用中，随着实例化对象数量的增加，内存消耗会越来越大。所以应当及时释放对对象的引用，让GC能够回收这些内存控件。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs plain">对象：obj &#x3D; null<br>对象属性：delete obj.myproperty<br><br>数组item：使用数组的splice方法释放数组中不用的item<br><br>避免string的隐式装箱<br><br>对string的方法调用，比如&#39;xxx&#39;.length，浏览器会进行一个隐式的装箱操作，将字符串先转换成一个String对象。<br>推荐对声明有可能使用String实例方法的字符串时，采用如下写法：<br>var myString &#x3D; new String(‘Hello World&#39;);<br></code></pre></td></tr></table></figure><h3>松散耦合</h3><ol><li>解耦HTML/JavaScript<br>JavaScript和HTML的紧密耦合：直接写在HTML中的JavaScript、使用包含内联代码的<br>HTML和JavaScript的紧密耦合：JavaScript中包含HTML，然后使用innerHTML来插入一段html文本到页面<br>其实应该是保持层次的分离，这样可以很容易的确定错误的来源，所以我们应确保HTML呈现应该尽可能与JavaScript保持分离</li><li>解耦CSS/JavaScript<br>显示问题的唯一来源应该是CSS，行为问题的唯一来源应该是JavaScript，层次之间保持松散耦合才可以让你的应用程序更加易于维护，所以像以下的代码element.style.color=”red”尽量改为element.className=”edit”，而且不要在css中通过表达式嵌入JavaScript</li><li>解耦应用程序/事件处理程序<br>将应用逻辑和事件处理程序相分离：一个事件处理程序应该从事件对象中提取，并将这些信息传送给处理应用逻辑的某个方法中。这样做的好处首先可以让你更容易更改触发特定过程的事件，其次可以在不附加事件的情况下测试代码，使其更易创建单元测试</li></ol><h3>性能方面的注意事项</h3><ol><li>尽量使用原生方法</li><li>switch语句相对if较快<br>通过将case语句按照最可能到最不可能的顺序进行组织</li><li>位运算较快<br>当进行数字运算时，位运算操作要比任何布尔运算或者算数运算快</li><li>巧用||和&amp;&amp;布尔运算符<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs plain">function eventHandler(e) &#123;<br>  if (!e) e &#x3D; window.event;<br>&#125;<br>&#x2F;*可以替换为⬇*&#x2F;<br>function eventHandler(e) &#123;<br>  e &#x3D; e || window.event;<br>&#125;<br>if (myobj) &#123;<br>  doSomething(myobj);<br>&#125;<br>&#x2F;*可以替换为⬇*&#x2F;<br>myobj &amp;&amp; doSomething(myobj);<br></code></pre></td></tr></table></figure></li></ol><h3>避免错误应注意的地方</h3><ol><li>每条语句末尾须加分号<br>在if语句中，即使条件表达式只有一条语句也要用{}把它括起来，以免后续如果添加了语句之后造成逻辑错误</li><li>使用+号时需谨慎<br>JavaScript 和其他编程语言不同的是，在 JavaScript 中，’+’除了表示数字值相加，字符串相连接以外，还可以作一元运算符用，把字符串转换为数字。因而如果使用不当，则可能与自增符’++’混淆而引起计算错误<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plain">var valueA &#x3D; 20;<br>var valueB &#x3D; &quot;10&quot;;<br>alert(valueA + valueB);   &#x2F;&#x2F;ouput: 2010 <br>alert(valueA + (+valueB)); &#x2F;&#x2F;output: 30 <br>alert(valueA + +valueB);  &#x2F;&#x2F;output:30 <br>alert(valueA ++ valueB);   &#x2F;&#x2F;Compile error<br></code></pre></td></tr></table></figure></li><li>使用return语句需要注意<br>一条有返回值的return语句不要用()括号来括住返回值，如果返回表达式，则表达式应与return关键字在同一行，以避免压缩时，压缩工具自动加分号而造成返回与开发人员不一致的结果<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs plain">function F1() &#123;<br>  var valueA &#x3D; 1;<br>  var valueB &#x3D; 2;<br>  return valueA + valueB;<br>&#125;<br>function F2() &#123;<br>  var valueA &#x3D; 1;<br>  var valueB &#x3D; 2;<br>  return<br>  valueA + valueB;<br>&#125;<br>alert(F1()); &#x2F;* output: 3 *&#x2F;<br>alert(F2()); &#x2F;* ouput: undefined *&#x2F;<br></code></pre></td></tr></table></figure></li><li>==和===的区别<br>避免在if和while语句的条件部分进行赋值，如if (a = b)，应该写成if (a == b)，但是在比较是否相等的情况下，最好使用全等运行符，也就是使用===和!==操作符会相对于==和!=会好点。==和!=操作符会进行类型强制转换<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs plain">var valueA &#x3D; &quot;1&quot;;<br>var valueB &#x3D; 1;<br>if (valueA &#x3D;&#x3D; valueB) &#123;<br>  alert(&quot;Equal&quot;);<br>&#125;<br>else &#123;<br>  alert(&quot;Not equal&quot;);<br>&#125;<br>&#x2F;&#x2F;output: &quot;Equal&quot;<br>if (valueA &#x3D;&#x3D;&#x3D; valueB) &#123;<br>  alert(&quot;Equal&quot;);<br>&#125;<br>else &#123;<br>  alert(&quot;Not equal&quot;);<br>&#125;<br>&#x2F;&#x2F;output: &quot;Not equal&quot;<br></code></pre></td></tr></table></figure></li></ol><h3>不要使用生偏语法</h3>不要使用生偏语法，写让人迷惑的代码，虽然计算机能够正确识别并运行，但是晦涩难懂的代码不方便以后维护<h3>函数返回统一类型</h3>虽然JavaScript是弱类型的，对于函数来说，前面返回整数型数据，后面返回布尔值在编译和运行都可以正常通过，但为了规范和以后维护时容易理解，应保证函数应返回统一的数据类型<h3>总是检查数据类型</h3>要检查你的方法输入的所有数据，一方面是为了安全性，另一方面也是为了可用性。用户随时随地都会输入错误的数据。这不是因为他们蠢，而是因为他们很忙，并且思考的方式跟你不同。用typeof方法来检测你的function接受的输入是否合法<h3>何时用单引号，何时用双引号</h3>虽然在JavaScript当中，双引号和单引号都可以表示字符串, 为了避免混乱，我们建议在HTML中使用双引号，在JavaScript中使用单引号，但为了兼容各个浏览器，也为了解析时不会出错，定义JSON对象时，最好使用双引号<h3>部署</h3>用JSLint运行JavaScript验证器来确保没有语法错误或者是代码没有潜在的问部署之前推荐使用压缩工具将JS文件压缩<h3>文件编码统一用UTF-8</h3><p>JavaScript 程序应该尽量放在 .js 的文件中，需要调用的时候在 HTML 中以标签前。<br>这样会降低因加载 JavaScript 代码而影响页面中其它组件的加载时间。<br>永远不要忽略代码优化工作，重构是一项从项目开始到结束需要持续的工作，只有不断的优化代码才能让代码的执行效率越来越好</p><h3>关于JQ部分</h3><p>这部分很多其实和原生js的优化原理是一样的</p><ol><li>用数组方式来遍历jQuery 对象集合<br>如果可以使用复杂的选择器直接选中元素，就不要使用循环，去一个个辨认元素。<br>javascript原生循环方法for和while，要比jQuery的.each()方法快，应该优先使用原生方法。<br>在性能方面，对于jQuery each方法这种优雅实现是有代价的。有一个办法能够更快地遍历一个jQuery对象。就是通过数组来实现，jQuery对象集合就是一个类数组，具有length和value属性。</li><li>选择器优化<br>选择器执行速度：id选择器&gt;class选择器&gt;后代Class选择器&gt;后代选择器&gt;伪类与属性选择器</li><li>理解子元素和父元素的关系<br>当父元素已经生成可以链式操作时，<br>最佳选择是$parent.find(‘.child’)。由于$parent往往在前面的操作已经生成，jQuery会进行缓存，所以进一步加快了执行速度。<br>当父元素未生成，为选择元素添加context选择区域会更快。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs plain">$(&#39;.child&#39;, $(&#39;#parent&#39;))<br>$parent.find(&#39;.child&#39;)&gt; $(&#39;.child&#39;, $parent)&gt;$(&#39;.child&#39;, $(&#39;#parent&#39;))&gt;$parent.children(&#39;.child&#39;)&gt;$(&#39;#parent &gt; .child&#39;)&gt;$(&#39;#parent .child&#39;)<br>(1) $(&#39;.child&#39;, $parent)<br>这条语句的意思是，给定一个DOM对象，然后从中选择一个子元素。<br>jQuery会自动把这条语句转成$.parent.find(&#39;child&#39;)，这会导致一定的性能损失。它比最快的形式慢了5%-10%。<br>(2) $parent.find(&#39;.child&#39;)<br>这条是最快的语句。.find()方法会调用浏览器的原生方法（getElementById，getElementByName，getElementByTagName等等），所以速度较快。<br>(3) $parent.children(&#39;.child&#39;)<br>这条语句在jQuery内部，会使用$.sibling()和javascript的nextSibling()方法，一个个遍历节点。它比最快的形式大约慢50%。<br>(4) $(&#39;#parent &gt; .child&#39;)<br>jQuery内部使用Sizzle引擎，处理各种选择器。<br>Sizzle引擎的选择顺序是从右到左，所以这条语句是先选.child，然后再一个个过滤出父元素#parent，这导致它比最快的形式大约慢70%。<br>(5) $(&#39;#parent .child&#39;)<br>这条语句与上一条是同样的情况<br>。但是，上一条只选择直接的子元素，这一条可以于选择多级子元素，所以它的速度更慢，大概比最快的形式慢了77%。<br>(6) $(&#39;.child&#39;, $(&#39;#parent&#39;))<br>jQuery内部会将这条语句转成$(&#39;#parent&#39;).find(&#39;.child&#39;)，比最快的形式慢了23%。<br></code></pre></td></tr></table></figure></li><li>有原生方法可以使用的场合，尽量避免使用jQuery<br>this.id的速度比$(this).attr(‘id’)快了20多倍；</li><li>做好缓存<br>使用选择器的次数应该越少越好，并且尽可能缓存选中的结果，便于以后反复使用。</li><li>使用链式写法<br>采用链式写法时，jQuery自动缓存每一步的结果，因此比非链式写法要快。</li><li>事件的委托处理</li><li>少改动DOM结构<br> 1) 改动DOM结构开销很大，因此不要频繁使用.append()、.insertBefore()和.insetAfter()这样的方法。<br> 如果要插入多个元素，就先把它们合并，然后再一次性插入。根据测试，合并插入比不合并插入，快了将近10倍。<br> 2) 如果你要对一个DOM元素进行大量处理，应该先用.detach()方法，把这个元素从DOM中取出来，处理完毕以后，再重新插回文档。根据测试，使用.detach()方法比不使用时，快了60%。<br> 3) 如果你要在DOM元素上储存数据，不要写成下面这样： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">var elem &#x3D; $(&#39;#elem&#39;);<br>elem.data(key,value);<br></code></pre></td></tr></table></figure> 而要写成 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plain">var elem &#x3D; $(&#39;#elem&#39;);<br>$.data(elem[0],key,value);<br>根据测试， 后一种写法要比前一种写法，快了将近10倍。<br>因为elem.data()方法是定义在jQuery函数的prototype对象上面的， <br>而$.data()方法是定义jQuery函数上面的，调用的时候不从复杂的jQuery对象上调用，所以速度快得多.<br></code></pre></td></tr></table></figure></li><li>选择作用域链最短的方法<br>Javascript的变量采用链式作用域。读取变量的时候，先在当前作用域寻找该变量，如果找不到，就前往上一层的作用域寻找该变量。因而读取局部变量比读取全局变量快得多。</li><li>插入html代码的时候，浏览器原生的innterHTML()方法比jQuery对象的html()更快。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;DOM编程&lt;/p&gt;
&lt;h3&gt;建议将对象进行缓存处理，特别是DOM访问是比较消耗资源的&lt;/h3&gt;
使用DocumentFragment优化多次append
一旦需要更新DOM,请考虑使用文档碎片来构建DOM结构，然后再将其添加到现存的文档中。

&lt;figure class=&quot;
      
    
    </summary>
    
    
    
      <category term="js" scheme="http://yoursite.com/tags/js/"/>
    
      <category term="优化" scheme="http://yoursite.com/tags/%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>解决JavaScript拖动时同时触发点击事件的BUG</title>
    <link href="http://yoursite.com/2020/04/17/%E8%A7%A3%E5%86%B3JavaScript%E6%8B%96%E5%8A%A8%E6%97%B6%E5%90%8C%E6%97%B6%E8%A7%A6%E5%8F%91%E7%82%B9%E5%87%BB%E4%BA%8B%E4%BB%B6%E7%9A%84BUG/"/>
    <id>http://yoursite.com/2020/04/17/%E8%A7%A3%E5%86%B3JavaScript%E6%8B%96%E5%8A%A8%E6%97%B6%E5%90%8C%E6%97%B6%E8%A7%A6%E5%8F%91%E7%82%B9%E5%87%BB%E4%BA%8B%E4%BB%B6%E7%9A%84BUG/</id>
    <published>2020-04-17T01:20:00.000Z</published>
    <updated>2020-04-17T01:31:21.569Z</updated>
    
    <content type="html"><![CDATA[<p>通过mousedown时记录下鼠标的位置x1，y1，mouseup时记录下鼠标的位置x2,y2，<br>通过计算判断拖动距离来判断此时是触发点击事件还是拖动事件。</p><p>var _val=Math.sqrt((x2-x1)<em>(x2-x1)+(y2-y1)</em>(y2-y1));<br>//判断<br>if(_val&gt;=0&amp;&amp;_val&lt;=2){<br>    dragFlag=true;<br>}else{<br>    dragFlag=false;<br>}</p>]]></content>
    
    <summary type="html">
    
      通过mousedown时记录下鼠标的位置x1，y1，mouseup时记录下鼠标的位置x2,y2， 通过计算判断拖动距离来判断此时是触发点击事件还是拖动事件。
    
    </summary>
    
    
    
      <category term="js" scheme="http://yoursite.com/tags/js/"/>
    
      <category term="问题" scheme="http://yoursite.com/tags/%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>web前端性能优化</title>
    <link href="http://yoursite.com/2020/04/16/web%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    <id>http://yoursite.com/2020/04/16/web%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</id>
    <published>2020-04-16T07:45:46.000Z</published>
    <updated>2020-04-23T01:32:14.166Z</updated>
    
    <content type="html"><![CDATA[<p>想要成为一名合格的Web前端工程师，Web前端性能优化是一个必须要掌握的知识，那么应该怎么进行Web前端性能优化呢？</p><h3>Web前端性能优化原理问题</h3><p>前端性能优化，资源的合并与压缩，图片编码的原理，以及类型的选择，浏览器的渲染机制，懒加载，预加载，浏览器存储，缓存机制，PWA和Vue-SSR等。<br>技术栈，Vue.js和Chrome，调试工具performance和layers。那么什么是前端性能优化原理的点，涉及作用以及原理，如何与真实的项目场景结合，理论结合实战经验，进行量化分析。<br>前端优化，一般是先基础优化（图片编码原理等问题），高一点 即为 进阶优化（浏览器的渲染机制，浏览器的存储，优化），结合服务端进行优化（首屏渲染等问题）等。<br>前端性能优化方案，最小化HTTP的请求，使用内容交付网络，避免空src或是href，添加过期或者是缓存控制标头，gzip组件，将styleSheets放在顶部，将脚本放在最下面，避免css表达式，减少dns的查找，将js和css设置为外部，避免重定向，配置etag，使用ajax缓存，减少dom元素的数量，没有404，减少cookie的大小，不缩放HTML中的图像，避免使用过滤器，使用favicon.icon小型且可缓存。</p><h3>面试官拷问</h3><p>面试官：为什么要进行前端优化？图片在前端是如何解码的？浏览器渲染加载的过程是如何进行的？懒加载和预加载的原理是什么样的？懒加载和预加载的应用场景是什么样的？PWA和VUE-SSR等原理的是怎么样的？</p><p>面试官深度拷问每个优化性能后的原理是怎么样的？结合你自己做过的项目性能优化的原理是怎么样的？说说你在项目中使用过性能优化后的感悟心得？说说每个性能优化原理最适合的场景过程。</p><p>面试人员想要了解你掌握多少性能优化的原理，了解你做过项目上是否使用过性能优化，分析自身做过的项目，找到需要性能优化的点，选择合适的性能优化等。</p><p>影响前端性能的有图像，样式表，脚本，flash等，减少组件的数量，减少所需的HTTP请求的数量，即可加快页面的速度。</p><h3>前端性能优化，资源的合并与压缩</h3><p>合并文件是一种通过将所有脚本合并为一个脚本，类似将所有css合并为一个样式表来减少HTTP请求数量的方法。<br>实现性能优化，第一，减少我们的HTTP请求的数量，以及减少请求的资源大小，第二，资源的压缩与合并的原理是什么。压缩与合并前是什么样的效果，压缩与合并后又有什么区别。</p><p>拷问：浏览器的一个请求从发送到返回是一个怎样的过程？</p><p>url分解，协议名称，层级url的标记符号，固定不变，访问资源需要的凭证信息，从哪个服务器获取数据，需要连接的端口号，指向资源的层级文件路径，查询字符串，片段id。<br>客户端，走HTTP应用层，tcp传输层，ip网络层，数据链路层网络</p><p>分层由高到低分别为：应用层、传输层、网络层、数据链路层。发送端从应用层往下走，接收端从数据链路层往上走。</p><p>应用层客户端发送HTTP请求，报文首部，空行，报文主体，报文首部含请求行，请求首部字段，实体首部字段，其他。</p><p>SYN （Synchronize Sequence Numbers）同步序列编号<br>ACK  (Acknowledgement）确认字符</p><p>过程，用户先在浏览器中输入一个url，浏览器内部中的核心代码会将这个输入的url拆分解析，然后将domain传给dns服务器，dns服务会根据domain查询相关的post对应的ip地址，然后将ip地址传递给浏览器，浏览器有ip地址，就知道浏览器要到哪里去，持有ip地址知道这个请求发送到哪里去。就跟随协议，请求的参数都会在协议中携带，发送到网络中去，然后通过局域网，交换机，路由器，主干网络，到达服务端。</p><p>服务端是有一个MVC的架构的，请求首先会进入Controller中，在Controller中进行相关的逻辑处理，以及请求的分发，调用Model层，负责和数据进行交互，model层会读取Redis和db里面的数据。然后通过view层给到网络，由服务端到浏览器端，浏览器主要是做render的过程，render的过程就是通过浏览器请求回来的HTML，css，JavaScript等渲染的过程，会形成相关的dom树，以及对应的css树，在页面上进行相应的样式渲染。</p><h3>拷问，从浏览器到服务器的过程中，那几个点，哪些过程可以进行我们的前端优化呢？</h3><p>client浏览器与server通过http协议通讯，http协议属于应用层协议，http属于tcp协议，所以client与server主要通过socket进行通讯。</p><p>tcp属于传输层协议，走https需要会话层tls,ssl等协议。</p><p>浏览器，dns服务器，服务器等，dns上我们可以进行缓存，来优化前端性能，路由器层面，url层面进行数据缓存，这样访问的时间就会被缩短了很多。</p><p>网络请求的过程，带宽，网络的选择，涉及到缓存，可以使用cdn，cdn是请求静态资源用的，请求静态资源，那么cookie是没有用的，所以希望在请求静态资源中，把这个cookie给去掉，这里注意cdn的域名不要和主站的域名一致，防止携带cookie。</p><p>如何减少我们HTTP请求的大小，每一个HTTP请求都要走网络环境才能达到我们的服务器，每一次请求都有网络环境的损耗，把多次HTTP请求减少到一次，减少网络环境中的损耗。也可以从服务器端出发，先把反映到页面中效果进行渲染，然后直出到网页上。</p><p>每一次请求都有网络环境的损耗，我们可以把多次HTTP请求合并成一次，从而减少相同的环境损耗。</p><p>带宽，一个HTTP的请求大小能够较小的话，访问就比较快一些，浏览器端的渲染过程，使用框架，就要从浏览器中进行渲染，框架中的模板是要在浏览器中进行渲染的，这个在框架中进行渲染，不利于首屏，对首屏有很大的损耗，不利于前端的性能。</p><p>服务器的渲染，将HTML渲染后直出到我们浏览器页面，不是在浏览器中进行渲染了。</p><p>前端性能优化点，通过HTTP请求的过程，可以了解到，我们可以通过dns进行缓存从而减少dns查询的时间，网络请求的过程走最近的网络环境，相同的静态资源进行缓存，减少HTTP请求的大小，减少HTTP请求，服务器端渲染，从业务中进行前端优化点。</p><p>重点，深入了解一下HTTP的请求过程，就可以知道前端性能优化的核心要点</p><h3>资源的合并与压缩</h3><p>减少资源体积，gzip压缩，js混淆，css压缩，图片压缩。</p><p>减少HTTP请求的数量即为合并，减少HTTP请求的大小即为压缩。可以对HTML进行压缩，css进行压缩，js进行压缩和混乱，文件合并，开启gzip等。</p><h3>进行HTML压缩</h3><p>第一使用在线网站压缩，使用html-minifier工具进行压缩，后端模板引擎渲染压缩。</p><h3>进行css压缩</h3><p>css sprite是减少图像请求数量的首选方法，将背景图像合并为单个图像。</p><p>CSS Sprites在国内很多人叫CSS精灵，是一种网页图片应用处理方式。它允许你将一个页面涉及到的所有零星图片都包含到一张大图中去，这样一来，当访问该页面时，载入的图片就不会像以前那样一幅一幅地慢慢显示出来了。对于当前网络流行的速度而言，不高于200KB的单张图片的所需载入时间基本是差不多的，所以无需顾忌这个问题。</p><p>第一进行无效代码的删除，第二是css语义合并，使用在线网站压缩，使用html-minifier对HTML中的css进行压缩，使用clean-css对css进行压缩。</p><p>用CSSbackground-image和background-position属性显示所需的图像段</p><h3>进行js的压缩和混乱</h3><p>第一删除无效字符，剔除注解，代码语义的缩减和优化，代码的保护，可以使用在线网站进行压缩，html-minifier对html中的js进行压缩，使用uglifyjs2对js进行压缩</p><p>（1）将table改为div布局<br>（2）缩减精简div、span、ul、li等系列标签<br>（3）删除多余空格<br>（4）表格类型布局时候适当使用table替代div布局<br>（5）网页GZIP压缩</p><h3>文件的合并</h3><p>文件与文件之间有插入的上行请求，增加了N-1个网络延迟，受丢包问题影响更加严重，经过代理服务器时可能会被断开。合并文件存在首屏渲染问题，缓存失败问题，js文件比较大，请求比较慢，得请求回来后才会首屏HTML渲染，js是由缓存的，文件合并如果其中某个js文件有变化，就会导致缓存失败的问题，如果文件不合并，修改其中的某一个js文件，只会导致该文件缓存失效，其他的不会受影响。文件合并，存在很严重的缓存失效问题。</p><p>那么是否进行文件的合并，建议可以将公共库单独打包成一个文件，业务单独打包成一个文件，不同页面的合并，将不同页面的js不同打包，</p><p>如何进行文件合并，在线网站进行文件合并，使用nodejs实现文件合并</p><h3>实战资源和与压缩</h3>实战页面开发，网站进行压缩与合并，fis进行自动化的压缩与合并。<p>压缩前<br><img src="/2020/04/16/web%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/20204_1.webp" alt><br>压缩后<br><img src="/2020/04/16/web%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/20204_2.png" alt></p><h3>前端自动化的构造实现压缩与合并</h3><p>fis3是一款百度内的构建工具，start-&gt;getSource()-&gt;所有文件是否编译完成，（单文件的编译，另个走向为打包的过程）。<br>fis3的配置文件，fis-conf.js<br><img src="/2020/04/16/web%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/20204_3.jpg" alt></p><h3>压缩后，优化前后性能对比，还是要性能优化得好，大的资源效果很明显</h3>加载优化，合并CSS，JavaScript，合并小图片，缓存一切可以缓存的资源，使用外联样式引用CSS和JavaScript，压缩HTML，css，JavaScript，启用GZIP，使用首屏加载，按需加载，滚屏加载，增加加载进度条，减少cookie，避免重定向，异步加载第三方资源。<p>css优化，css写在头部，JavaScript写在尾部，避免图片和Frame等的空Src，尽量避免重设置图片大小，图片尽量避免使用DataURL，尽量避免写在HTML标签中写style属性，避免css的表达式，移除空的css规则，正确使用display的属性，不滥用float，不滥用web字体，不滥用过多的Font-size，值为0时不需要任何单位，标准化各种浏览器前缀，避免让选择符看起来像正则表达式。</p><p>渲染优化，HTML使用viewport，减少dom节点，尽量使用css3动画，合理使用requestAnimationFrame动画代替setTimeout，适当使用Canvas动画，Touchmove，Scroll事件会导致多次渲染，使用CSS3 transitions，CSS3 3d，transforms，Opacity，Canvas等来触发GPU渲染。</p><p>脚本优化，减少重绘和回流，缓存dom选择与计算，缓存列表length，尽量使用事件代理，避免批量绑定事件，尽量使用id选择器，使用touchstart，touchend代替click。</p><p>图片优化，使用css3，svg，iconfont代替图片，使用srcset，web优于jpg，png8优于gif，首次加载不大于1014kb，图片不宽于640。</p><p>注意，在我们修改后端响应时间缩短一半时，整体响应事件只能减少5-10%，而优化前端性能，缩短一半时，整体响应可以减少40-45%。</p><p>前端优化的意义 HTTP请求的过程是进行优化的核心 压缩和合并的原理</p><h3>图片优化的过程</h3>图片加载处理，图片预加载，图片懒加载，首屏加载时进度条的显示。异步请求的优化，使用正常的json数据格式进行交互，部分常用数据的缓存。<p>图像映射将多个图像合并为一个图像，整体大小大致相同，但是减少HTTP请求的数量可以加快页面的速度。</p><p>png8、png24、png32区别</p><p>png8为256颜色，支持透明，png24为2的24次幂，不支持透明，png32为2的24次幂，支持透明。</p><p>jpg有损压缩，压缩率高，不支持透明，png支持透明，浏览器兼容好，webp压缩程度更好，在ios webview有兼容性问题，svg矢量图，代码内嵌，相对较小。</p><p>jpg使用场景，用在不需要透明图片，png使用场景，用在需要透明图片的场景，webp用在安卓，svg矢量图用在图片样式相对简单的业务。</p><p>css雪碧图，把一些图片整合到一张单独的图片中，用来减少请求数量，问题出在图片大，如果没有加载成功的话，慢，也是有问题的。image inline，把图片的内容内嵌到HTML上，与HTML存在，作为base64的格式，可以减少你的网站的HTTP请求数量。使用矢量图svg，绘制功能，使用iconfont解决icon问题。</p><p>webp使用在安卓下，它具更好的图像数据压缩算法，和无损和有损的压缩模式，alpha透明，动画的特性。</p><p>HTML渲染过程：顺序执行（词法分析），并发加载，是否阻塞，依赖关系，引入方式。</p><p>css阻塞，css head中阻塞页面的渲染，css阻塞js的执行，css不阻塞外部脚本的加载。</p><p>js阻塞，引入js阻塞页面的渲染，js不阻塞资源的加载，js顺序执行，阻塞后续js逻辑的执行。</p><h3>图片压缩与拼接</h3>PNG、PNG-8、PNG-24以及JPEG格式图片区别<p>PNG格式适合对透明度有要求的情形，PNG-8处理不了复杂色域下的渐变，PNG-24可以几乎不失真地保留渐变</p><h3>图片压缩方法</h3>使用Photoshop自带图片压缩，文件—存储为Web所用格式，一般情况下，JPEG选择输出质量为70~80%可以保证视觉上几乎没有差异。<p>页面体积</p><p>优化前后文件体积压缩率 = 优化后的体积÷优化前的体积<br><img src="/2020/04/16/web%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/20204_4.webp" alt></p><h3>懒加载原理</h3><p>什么是懒加载的定义是对于图片而言，图片资源，对于商城项目图片是很多的，页面很长的业务场景适用，减少无效资源的加载，并发加载的资源过多会阻塞js的加载。</p><p>当图片进入到我们可视区域，去请求加载资源</p><p>懒加载的效果延迟加载</p><h3>预加载原理</h3><p>图片等静态资源使用前提前请求，资源在使用时从缓存中加载，提高用户体验。</p><h3>什么是重绘与回流的机制？</h3><p>频繁重绘与回流会导致ui频繁渲染，导致JavaScript变慢。回流，当render tree中的一部分因为元素的规模尺寸，布局等改变需要重新构建，会触发回流，重绘，当render tree中的一些元素需要修改属性，这些属性不影响元素的外观，风格，布局，就叫做重绘，如修改颜色等。</p><p>所以回流一定会引起重绘，但是重绘不一定会引起回流。</p><h3>掌握一些css属性</h3><p><img src="/2020/04/16/web%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/20204_7.webp" alt></p><p>将频繁重绘回流的元素单独出来，作为一个独立的图层，那么这个元素的重绘回流就只能影响这个图层中。</p><p>把一个元素独立成独立的图层，用css属性</p><p>避免使用触发重绘，回流的css属性，重绘和回流很频繁可以独立出来。</p><h3>浏览器存储</h3><p>了解什么是localstorage，cookie，sessionstorage，indexdb</p><p>了解pwa和service worker的应用</p><p>多种浏览器存储方式共存</p><h3>什么是cookie</h3><p>用cookie给服务端传递相关信息，让服务端来分别当前请求的是哪个客户端，cookie是1993年有的，它的目的就是为了区分HTTP的请求情况，本来HTTP请求就是无状态的，就是请求之后的连接就关闭了，cookie就是去维护客户端的状态。</p><p>用于浏览器端和服务端的交互，客户端自身数据的存储。</p><p>cookie有限制，作为浏览器存储大小有4kb左右，需要设置过期时间。</p><p>cookie的生成方式，http response header的set-cookie，通过document.cookie可以读写cookie，cookie中的相关域名下面-cdn的流量损耗，httponly。</p><h3>LocalStorage</h3><p>专门用于浏览器存储，大小5M左右，接口封装好，本地缓存的方案，可提高首屏的加载速度。</p><h3>SessionStorage</h3><p>会话级别的浏览器存储，大小5M左右，在客户端使用，不和服务端进行通信，接口封装较好。</p><h3>pwa是什么</h3><p>它是一种web app 新模型，并不是指某一种前沿的技术，是一种渐进式的web app，是通过一系列新的web特性。pwa在没有网络的环境中也能提供基本的页面访问，web app没有网络的话接收不到基本页面的展示，但是pwa不会出现未连接到网络就导致显示不了页面。它很快速，对网页渲染以及网络数据访问很快速，融入特性，可以被添加到手机桌面等。</p><h3>service worker是什么</h3><p>它是一个脚本，浏览器独立于当前网页，将其在后台运行，实现一些不依赖的页面。具有拦截和处理网络请求的特性。</p><h3>缓存策略</h3><p>缓存，DNS缓存，CDN部署与缓存，http缓存</p><p>了解cache-control，last-modified，etag。httpheader的属性，Cache-control属性，max-age，s-maxage，private，public，no-cache，no-store。</p><p>浏览器在DNS解析中会消耗一定的时间，对一些访问量高的来说，需要做好DNS的缓存工作，CDN缓存，CDN作为静态资源文件的分发，做好静态资源的缓存工作，就能加快网站的加载速度，</p><p>移动到优化，使用cache，减少重定向，首屏优化，保证首屏加载数据小于14kb，不滥用web字体。</p><h3>服务端性能优化</h3><p>服务器是node.js，所以也能进行优化。</p><p>谷歌PageSpeed团队的测试表明，30~50KB（压缩后）是每个JavaScript文件大小的合适范围：既达到了能够减少小文件带来的网络延迟，还能确保递增及分层式的执行。–web性能权威指南<br><img src="/2020/04/16/web%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/20204_5.webp" alt></p><p>减少HTTP请求，合并js文件，合并css文件，使用css sprite，使用base64表示简单的图片。</p><p>移动端优化，长列表滚动优化，函数防抖和函数节流，使用touchstart，touchend代替click，html的viewport设置，开启gpu渲染加速。<br><img src="/2020/04/16/web%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/20204_6.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;想要成为一名合格的Web前端工程师，Web前端性能优化是一个必须要掌握的知识，那么应该怎么进行Web前端性能优化呢？&lt;/p&gt;
&lt;h3&gt;Web前端性能优化原理问题&lt;/h3&gt;

&lt;p&gt;前端性能优化，资源的合并与压缩，图片编码的原理，以及类型的选择，浏览器的渲染机制，懒加载，预加
      
    
    </summary>
    
    
    
      <category term="优化" scheme="http://yoursite.com/tags/%E4%BC%98%E5%8C%96/"/>
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>hexo搭建到github上</title>
    <link href="http://yoursite.com/2020/04/16/hexo%E6%90%AD%E5%BB%BA%E5%88%B0github%E4%B8%8A/"/>
    <id>http://yoursite.com/2020/04/16/hexo%E6%90%AD%E5%BB%BA%E5%88%B0github%E4%B8%8A/</id>
    <published>2020-04-16T07:17:44.000Z</published>
    <updated>2020-04-17T01:26:45.130Z</updated>
    
    <content type="html"><![CDATA[<h4>1 打开“https://github.com/”网站进行用户注册，注册成功之后，在首页点击“New repository”来新建仓库;</h4><h4>2 在创建仓库页面，输入名称，注意名称格式“yourname.github.io”，yourname就是你注册用户时候的用户名;</h4><h4>3 做好上面两步后，返回到gitbash客户端，如果已经关闭了客户端或者重启了客户端，先进入博客的站点目录，然后输入接下来的命令。</h4><p>我们在gitbash中配置github的用户信息，分别输入以下两条命令，如图：<br><img src="/2020/04/16/hexo%E6%90%AD%E5%BB%BA%E5%88%B0github%E4%B8%8A/20204_0.png" alt></p><p>图中“xqwcloud”和“<a href="mailto:977318777@qq.com">977318777@qq.com</a>”分别是我注册github时候的用户名和邮箱。</p><h4>4 配置完信息后，我们创建SSH，通过输入如图命令即可创建，然后通过下面的方式找到“id_rsa.pub”文件的内容，供后续步骤使用：</h4><p><img src="/2020/04/16/hexo%E6%90%AD%E5%BB%BA%E5%88%B0github%E4%B8%8A/20204_0_1.png" alt><br><img src="/2020/04/16/hexo%E6%90%AD%E5%BB%BA%E5%88%B0github%E4%B8%8A/20204_0_2.png" alt></p><h4>5 查看到id_rsa.pub内容之后，我们返回到github页面，在右上角用户信息中选择“Settings”，来进行SSH的添加;title里的内容随便写，key里面的内容就是gitbash里面我们查看到的id_rsa.pub文件中的内容，我们复制粘贴过来即可，如图：</h4><p><img src="/2020/04/16/hexo%E6%90%AD%E5%BB%BA%E5%88%B0github%E4%B8%8A/20204_1.png" alt></p><h4>6 然后点击下方的“ADD按钮”完成SSH的添加，我们可以输入“ssh -T git@github.com”来进行验证，如图：</h4><p><img src="/2020/04/16/hexo%E6%90%AD%E5%BB%BA%E5%88%B0github%E4%B8%8A/20204_2.png" alt></p><h4>7 回到站点目录下，打开站点配置文件，进行如下图所示的站点配置：</h4><p><img src="/2020/04/16/hexo%E6%90%AD%E5%BB%BA%E5%88%B0github%E4%B8%8A/20204_3.png" alt></p><h4>8 返回gitbash，分别输入以下命令，然后打开浏览器输入“localhost:4000”查看，如果页面能正常显示说明配置文件修改没有影响其他因素，接下来我们继续进行下面的步骤：</h4><p><img src="/2020/04/16/hexo%E6%90%AD%E5%BB%BA%E5%88%B0github%E4%B8%8A/20204_4.png" alt><br><img src="/2020/04/16/hexo%E6%90%AD%E5%BB%BA%E5%88%B0github%E4%B8%8A/20204_5.png" alt></p><h4>9 现在我们进行最后一步，首先安装相关的插件，输入“npm install hexo-deployer-git --save”命令来进行安装，安装过程中可能会提示版本太低或者已经不在维护之类的警告，不必理会，等安装完成;</h4><p><img src="/2020/04/16/hexo%E6%90%AD%E5%BB%BA%E5%88%B0github%E4%B8%8A/20204_6.png" alt><br>安装完成之后依次输入以下命令来进行最后的部署：</p><p>输入以下命令<br>hexo clean</p><p>hexo g</p><p>hexo d</p><p>在deploy过程中会弹出窗口让你输入github用户名和密码，我们输入之后操作会继续，等待操作完成，然后在浏览器输入“<a href="https://xqwcloud.github.io/”就可以看到我们的博客啦，如果没有看到，清理一下缓存就可以啦。" target="_blank" rel="noopener">https://xqwcloud.github.io/”就可以看到我们的博客啦，如果没有看到，清理一下缓存就可以啦。</a><br><img src="/2020/04/16/hexo%E6%90%AD%E5%BB%BA%E5%88%B0github%E4%B8%8A/20204_8.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4&gt;1 打开“https://github.com/”网站进行用户注册，注册成功之后，在首页点击“New repository”来新建仓库;&lt;/h4&gt;

&lt;h4&gt;2 在创建仓库页面，输入名称，注意名称格式“yourname.github.io”，yourname就是你注册用户
      
    
    </summary>
    
    
    
      <category term="搭建" scheme="http://yoursite.com/tags/%E6%90%AD%E5%BB%BA/"/>
    
  </entry>
  
  <entry>
    <title>git 操作</title>
    <link href="http://yoursite.com/2020/04/16/git-%E6%93%8D%E4%BD%9C/"/>
    <id>http://yoursite.com/2020/04/16/git-%E6%93%8D%E4%BD%9C/</id>
    <published>2020-04-16T06:44:33.000Z</published>
    <updated>2020-04-16T07:02:35.813Z</updated>
    
    <content type="html"><![CDATA[<h3>上传代码</h3>git status             查看修改的文件<br>git add 文件名         这个添加修改文件<br>git commit -m '注释'  注释<br>git pull               将本地拉下来，如果出现一个特殊框，输入:p<br>git push               上传本地代码<br><h3>切换合并分支</h3>git checkout test    切换分支到test<br>git pull               将本地拉下来，如果出现一个特殊框，输入:p<br>git merge dev        将dev合并进test分支<br>git push<h3>创建分支</h3>git branch -a 查看当前所以分支<br>git pull<br>git checkout -b center_order 创建分支<br>git pull<br>git push origin center_order <br>git branch --set-upstream-to=origin/center_order 将分支关联上远程<br>git pull<h3>解决冲突</h3><<<< <br>找到冲突地方选择修改的地方确定替换<br>执行上传代码操作<br><h3>撤回</h3>git merge --abort<br>删除本地分支 大写d为强制删除<br>git branch -D 分支名]]></content>
    
    <summary type="html">
    
      上传代码,切换合并分支,创建分支,解决冲突,撤回,删除本地分支
    
    </summary>
    
    
    
      <category term="git" scheme="http://yoursite.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>vscode快捷键</title>
    <link href="http://yoursite.com/2020/04/16/vscode%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    <id>http://yoursite.com/2020/04/16/vscode%E5%BF%AB%E6%8D%B7%E9%94%AE/</id>
    <published>2020-04-16T06:11:47.000Z</published>
    <updated>2020-04-16T06:43:28.744Z</updated>
    
    <content type="html"><![CDATA[<h3> 1、一次搜索所有文件的文本</h3><p>Windows: Ctrl + Shift + F</p><p>Mac: Command + Shift + F</p><p>VSCode中我最喜欢的特性之一是能够在项目目录中的所有文件中搜索任何匹配的文本。</p><p>要使用此特性，可以按Ctrl + Shift + f打开视图，它将显示编辑器左侧的侧边栏：</p><p>输入查找的內容并回车，VS code 将提供与输入内容匹配的结果列表，如下所示：</p><p>你还可以同时规制每个搜索果文件中的所有匹配内容。如果你单击左边的这个小箭头，它将在下面弹出第二个输入框，可以在这里输入要替换的文本，同时单击右边出现的小框：</p><h3>2、为 tabs 设置强调色 (Material Theme)</h3><p>你是否厌倦了每天看到相同的 tabs 底部颜色?可以使用 Material Theme来扩展 VsCode 的主题，这样就可以为 tabs 设置不同的颜色。</p><p>红色：</p><p>紫色：</p><p>黄色：</p><p>有16种不同的颜色可供选择。</p><p>因此，如果胸有安装此扩展，打开的命令面板(Ctrl + Shift + P)，选择 Material Theme: Set accent color并从列表中选择一个颜色，它将更改选项卡的下划线颜色，如下所示</p><h3>3、进程资源管理器</h3><p>你是否发现你的VsCode 编辑器有时有点慢?这时候你希望哪个进程在吃我们的内存？</p><p>好吧，如果你还不知道，VsCode 有一个进程资源管理器功能，如下所示：</p><p>是不是看起来很熟悉？</p><p>在windows任务管理器中看到过这一点，在VsCode 中按Ctrl + Alt + Delete可以打开该任务管理器。</p><h3>4、Expand Bracket Selection</h3><p>打开键盘快捷键(Ctrl + Shift + P或 command + Shift + p)，搜索 Expand Bracket Selection。</p><p>这是我需要花费一些时间才能发现的，因为我无法猜出该功能的名称。使用此功能可以自动选择整个块，从开始的大括号到结束。</p><p><img src="/2020/04/16/vscode%E5%BF%AB%E6%8D%B7%E9%94%AE/202004_1.gif" alt></p><p>我发现这个功能在想要找到 if/else对应的结束块很有用。</p><h3>5、重新打开 关闭的编辑页面</h3><p>Windows: Ctrl + Shift + T</p><p>Mac: command + Shift + T</p><p>当你处理一个文件很多的大型项目时，如果不小心关闭了一个页面，并且不得不在侧菜单中再次搜索它，这可能会有点令人沮丧。</p><p>现在，可以按 Ctrl + Shift + T重新打开一个关闭的页面。</p><h3>6、通过匹配文本打开文件</h3><p>Windows: Ctrl + T</p><p>Mac: command + T</p><p>说到搜索文件，你可以动态地搜索和打开文件。这是我最喜欢的特性之一，因为不需要手动单击目录来重新打开一个不再打开的文件。</p><h3>7、集成终端</h3><p>Windows: Ctrl + `</p><p>Mac: control + `</p><p>通过 Ctrl + `可以打开或关闭终端</p><h3>8、查看正在运行插件</h3><p>你可以通过打开命令面板(Ctrl + Shift + P)并输入Show running extensions来查看所有你安装的正在运行的插件。</p><h3>9、重新加载</h3><p>我个人认为这是 VsCode 最酷的特性之一。它允许你在重新加载编辑器时将窗口放在前面，同时具有与关闭和重新打开窗口相同的效果。</p><p>Windows: Ctrl + Alt + R</p><p>Mac: Control + Option + R</p><h3>10、将选项卡交换到不同的组</h3><p>在我开发的过程中，我习惯在错误的选项卡组中使用选项卡。我也希望避免尽可能多地使用我的鼠标来解决问题，因为这会让我把手从键盘上抬起来，我很懒，手一起想放键盘上。</p><p>幸运的是，VsCode 有一种方法可以通过按Ctrl + Alt +右箭头（Mac：Control + Option +右箭头）将标签移动到右侧的组，或者按Ctrl + Alt + 左箭头将标签转移到单独的标签组 （Mac：Control + Option +左箭头））将标签移动到左侧的组：</p><h3>11、选择左侧/右侧的所有内容</h3><p>有时你想要删除光标右侧或左侧的所有内容。你可以选择光标右侧或左侧的所有内容。例如，要选择右侧或左侧的所有内容：</p><p>Windows: Ctrl + Shift + Home/End</p><p>Mac: command + Shift + Home/End</p><p>苹果笔记本没home键，可以用组合键实现</p><p>fn键+左方向键是HOME<br>fn键+右方向键是END<br>fn+上方向键是page up<br>fn+下方向键是page down</p><h3>12、删除上一个单词</h3><p>要删除前一个单词，可以按Ctrl + Backspace(Mac: option + delete)。这在你打错字的时候非常有用。</p><p>你可以在 VsCode 之外的任何地方使用它。</p><h3>13、启动性能</h3><p>有时候，缺乏关于性能问题的详细信息是一件非常痛苦的事情，同时还要找出哪些有性能问题。</p><p>有时候，如果你足够幸运，你会找到一个工具，它能给你所有的答案。在VsCode 中，启动性能是很重要的。这就是为什么你能弹出一个有用的窗口，奇迹般地提供所有你需要的信息：</p><p>打开命令面板(Ctrl + Shift + P)，搜索Startup Performance。</p><h3>14、逐个选择文本</h3><p>可以通过快捷键Ctrl + Shift +右箭头(Mac: option + Shift +右箭头)和Ctrl + Shift +左箭头(Mac: option + Shift +左箭头)逐个选择文本。</p><h3>15、重复的行</h3><p>一个非常强大和已知的功能是复制行。只需按 Shift + Alt + 向下箭头(Mac: command + Shift + 向下箭头)</p><h3>16、移至文件的开头/结尾</h3><p>要使光标移到文件的第一行或最后一行，最快的方法是按Ctrl + Home(Mac: command + Home)键开头，然后按Ctrl + End(Mac: command + End)键结尾。</p><h3>17、批量替换当前文件中所有匹配的文本</h3><p>可以选择任何一组文本，如果该选中文本出现多个，可以通过按Ctrl + F2(Mac: command + F2)一次改所有出现的文本。</p><h3>18、向上/向下移动一行</h3><p>按Alt + 向上箭头(Mac: command+ 向上箭头)当前行向上移动，按Alt + 向下箭头(Mac: command+ 向下箭头))当前行向下移动。</p><h3>19、删除一行</h3><p>有两种方法可以立即删除一行。</p><p>使用Ctrl + X剪切命令(Mac：command + X)来删除一行。</p><p>或者使用 Ctrl + Shift + K(Mac: command + Shift + K)命令。</p><h3>20、将编辑器向左或向右移动</h3><p>如果你像我一样，你可能会有一种无法控制的欲望，想要在一个组中重新排列选项卡，其中选项卡相互关联，左边的选项卡是比较重要文件，而右边的选项卡是相对不重要的文件。</p><p>通过 Ctrl+Shift+PgUp/PgDown(command + +Shift+PgUp/PgDown)向左/向右移动编辑器。</p><p>21、复制光标向上或者向上批量添加内容</p><p>在 VsCode 中复制游标可以证明是最节省时间的特性。</p><p>按Ctrl + Alt +向上箭头(Mac: Control + Option +向上箭头)将光标添加到上面，按Ctrl + Alt +向下箭头(Mac: Control + Option + 向下箭头)将光标添加到下面</p>]]></content>
    
    <summary type="html">
    
      Ctrl + Backspace 要删除前一个单词; Shift + Alt + 箭头 复制行; Ctrl + F2 选择任何一组文本，可以使选中文本出现多个一样的，一次改所有出现的文本; Alt + 箭头 当前行向上或向下移动;
    
    </summary>
    
    
    
      <category term="vscode" scheme="http://yoursite.com/tags/vscode/"/>
    
      <category term="快捷键" scheme="http://yoursite.com/tags/%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    
  </entry>
  
</feed>
