<!DOCTYPE html>
<html>
  <!-- Html Head Tag-->
  <head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content="">
  <meta name="author" content="陈sis">
  <!-- Open Graph Data -->
  <meta property="og:title" content="前端面试题"/>
  <meta property="og:description" content="" />
  <meta property="og:site_name" content="陈sis的笔记"/>
  <meta property="og:type" content="article" />
  <meta property="og:image" content="http://yoursite.com"/>
  
    <link rel="alternate" href="/atom.xml" title="陈sis的笔记" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  

  <!-- Site Title -->
  <title>陈sis的笔记</title>

  <!-- Bootstrap CSS -->
  
<link rel="stylesheet" href="/css/bootstrap.min.css">

  <!-- Custom CSS -->
  
  
<link rel="stylesheet" href="/css/style.light.css">


  <!-- Google Analytics -->
  

<meta name="generator" content="Hexo 4.2.0"></head>

  <script type="text/javascript" src="/js/jquery.min.js"></script>
  <script type="text/javascript" src="/js/hljs.js"></script>
  <body>
    <!-- Page Header -->


<header class="site-header header-background" style="background-image: url(/img/default-banner-dark.jpg)">
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <div class="page-title with-background-image">
          <p class="title">前端面试题</p>
          <p class="subtitle"></p>
        </div>
        <div class="site-menu with-background-image">
          <ul>
            
              <li>
                <a href="/">
                  
                  Home
                  
                </a>
              </li>
            
              <li>
                <a href="/archives">
                  
                  Archives
                  
                </a>
              </li>
            
              <li>
                <a href="https://github.com/<your-github-username>" target="_blank" rel="noopener">
                  
                  Github
                  
                </a>
              </li>
            
              <li>
                <a href="mailto:<your-email-address>">
                  
                  Email
                  
                </a>
              </li>
            
          </ul>
        </div>
      </div>
    </div>
  </div>
</header>

<article>
  <div class="container typo">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <div class="post-info text-muted">
          
            <!-- Author -->
            <span class="author info">By 陈sis</span>
          
          <!-- Date -->
          <span class="date-time info">On
            <span class="date">2020-04-24</span>
            <span class="time">17:50:59</span>
          </span>
          
        </div>
        <!-- Tags -->
        
          <div class="post-tags text-muted">
            Tags: 

<a class="tag" href="/tags/%E9%9D%A2%E8%AF%95/">#面试</a>


          </div>
        
        <!-- Post Main Content -->
        <div class="post-content">
          <h1>存储</h1>
<h3>请你谈谈Cookie的弊端</h3>

<p>1.IE6或更低版本最多20个cookie<br>2.IE7和之后的版本最后可以有50个cookie。<br>3.Firefox最多50个cookie<br>4.chrome和Safari没有做硬性限制<br>Opera 会清理近期最少使用的Firefox会随机清理 4096字节，为了兼容性，一般不能超过 IE 提供了一种存储可以持久化用户数据，叫做IE5.0就开始支持。每个数据最多128K，每个域名下最多1M。这个持久化数据放在缓存中，如果缓存没有清理，那么会一直存在。</p>
<ol>
<li><p>优点：极高的扩展性和可用性<br>1) 通过良好的编程，控制保存在cookie中的session对象的大小。<br>2) 通过加密和安全传输技术（SSL），减少cookie被破解的可能性。<br>3) 只在cookie中存放不敏感数据，即使被盗也不会有重大损失。<br>4) 控制cookie的生命期，使之不会永远有效。偷盗者很可能拿到一个过期的cookie。</p>
</li>
<li><p>缺点:<br>1) <code>Cookie</code>数量和长度的限制。每个domain最多只能有20条cookie，每个cookie长度不能超过4KB，否则会被截掉。<br>2) 安全性问题。如果cookie被人拦截了，那人就可以取得所有的session信息。即使加密也与事无补，因为拦截者并不需要知道cookie的意义，他只要原样转发cookie就可以达到目的了。<br>3) 有些状态不可能保存在客户端。例如，为了防止重复提交表单，我们需要在服务器端保存一个计数器。如果我们把这个计数器保存在客户端，那么它起不到任何作用。</p>
</li>
</ol>
<h3>浏览器本地存储</h3>

<p>在较高版本的浏览器中，sessionStorage和HTML5中提供了globalStorage。<br>Web Storage包括了两种存储方式：localStorage和sessionStorage。<br>sessionStorage不是一种持久化的本地存储，仅仅是会话级别的存储。<br>localStorage生命周期是永久，除非主动清除localStorage信息，否则这些信息将永远存在，存放数据大小为一般为5MB。</p>
<h3>web storage和cookie的区别</h3>

<p>一、储存空间不同<br>1.Web Storage能提供5M的存储空间（不同浏览器不同），Cookie提供4K的空间<br>2.Web Storage每个域（包括子域）都有独立的存储空间，每个存储空间是完全独立的，因此不会造成数据混淆<br>二、与服务端交互<br>1.Web Storage中数据仅仅是本地存储，不会与服务器发生任何交互<br>2.Cookie的内容会随着请求一并发送到服务器（每请求一个新的页面时，Cookie都会被发送过去，无形中造成宽带浪费）<br>三、接口<br>1.Web Storage提供了许多丰富易用的接口，拥有setItem，removeItemgetItem，clear，key等方法，操作数据更简单<br>2.Cookie需要自己封装setCookie，getCookie等</p>
<h1>CSS 相关问题</h1>
<h3>display:none和visibility:hidden的区别？</h3>

<p>display:none 隐藏对应的元素，在文档布局中不再给它分配空间，它各边的元素会合拢，就当他从来不存在。<br>visibility:hidden 隐藏对应的元素，但是在文档布局中仍保留原来的空间。</p>
<h3>CSS中 link 和@import 的区别是？</h3>

<p>(1) link属于HTML标签，而@import是CSS提供的;<br>(2) 页面被加载的时，link会同时被加载，而@import引用的CSS会等到页面被加载完再加载;<br>(3) import只在IE5以上才能识别，而link是HTML标签，无兼容问题;<br>(4) link方式的样式的权重 高于@import的权重.</p>
<h3>position的absolute与fixed共同点与不同点</h3>

<p>A：共同点：<br>1.改变行内元素的呈现方式，display被置为block；<br>2.让元素脱离普通流，不占据空间；<br>3.默认会覆盖到非定位元素上</p>
<p>B：不同点：<br>absolute的”根元素“是可以设置的，而fixed的”根元素“固定为浏览器窗口。<br>当你滚动网页，fixed元素与浏览器窗口之间的距离是不变的。</p>
<h3>介绍一下CSS的盒子模型？</h3>

<p>1）有两种， IE 盒子模型、标准 W3C 盒子模型；IE的盒子模型content部分包含了 border 和 pading;<br>2）盒模型： 内容(content)、填充(padding)、边界(margin)、 边框(border).</p>
<h3>CSS 选择符有哪些？哪些属性可以继承？优先级算法如何计算？</h3>

<p>1.id选择器（ # myid）<br>2.类选择器（.myclassname）<br>3.标签选择器（div, h1, p）<br>4.相邻选择器（h1 + p）<br>5.子选择器（ul &gt; li）<br>6.后代选择器（li a）<br>7.通配符选择器（ * ）<br>8.属性选择器（a[rel = “external”]）<br>9.伪类选择器（a: hover, li:nth-child）</p>
<ul>
<li>可继承的样式： font-size font-family color, text-indent;</li>
<li>不可继承的样式：border padding margin width height ;</li>
<li>优先级就近原则，同权重情况下样式定义最近者为准;</li>
<li>载入样式以最后载入的定位为准;<br>优先级为:<br>!important &gt; id &gt; class &gt; tag<br>important 比 内联优先级高,但内联比 id 要高</li>
</ul>
<h3>CSS3新增伪类举例</h3>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plain">p:first-of-type 选择属于其父元素的首个 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。<br>p:last-of-type 选择属于其父元素的最后 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。<br>p:only-of-type 选择属于其父元素唯一的 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。<br>p:only-child 选择属于其父元素的唯一子元素的每个 &lt;p&gt; 元素。<br>p:nth-child(2) 选择属于其父元素的第二个子元素的每个 &lt;p&gt; 元素。<br>:enabled :disabled 控制表单控件的禁用状态。<br>:checked 单选框或复选框被选中。<br></code></pre></td></tr></table></figure>

<h3>列出display的值，说明他们的作用。position的值， relative和absolute分别是相对于谁进行定位的？</h3>

<p>block 象块类型元素一样显示。<br>inline 缺省值。象行内元素类型一样显示。<br>inline-block 象行内元素一样显示，但其内容象块类型元素一样显示。<br>list-item 象块类型元素一样显示，并添加样式列表标记。</p>
<p>*absolute<br>生成绝对定位的元素，相对于 static 定位以外的第一个祖先元素进行定位。</p>
<p>*fixed （老IE不支持）<br>生成绝对定位的元素，相对于浏览器窗口进行定位。</p>
<p>*relative<br>生成相对定位的元素，相对于其在普通流中的位置进行定位。</p>
<ul>
<li><p>static 默认值。没有定位，元素出现在正常的流中</p>
</li>
<li><p>（忽略 top, bottom, left, right z-index 声明）。</p>
</li>
<li><p>inherit 规定从父元素继承 position 属性的值。</p>
</li>
</ul>
<h3>CSS3有哪些新特性？</h3>

<p>圆角（border-radius），阴影（box-shadow），对文字加特效（text-shadow、），线性渐变（gradient），旋转（transform）<br>transform:rotate(9deg) scale(0.85,0.90) translate(0px,-30px) skew(-9deg,0deg);//旋转,缩放,定位,倾斜<br>增加了更多的CSS选择器 多背景 rgba<br>在CSS3中唯一引入的伪元素是::selection.<br>媒体查询，多栏布局，border-image</p>
<h3>为什么要初始化CSS样式。</h3>

<p>因为浏览器的兼容问题，不同浏览器对有些标签的默认值是不同的，如果没对CSS初始化往往会出现浏览器之间的页面显示差异。<br>当然，初始化样式会对SEO有一定的影响，但鱼和熊掌不可兼得，但力求影响最小的情况下初始化。<br>*最简单的初始化方法就是： * {padding: 0; margin: 0;} （不建议）<br>淘宝的样式初始化：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs plain">body, h1, h2, h3, h4, h5, h6, hr, p, blockquote, dl, dt, dd, ul, ol, li, pre, form, fieldset, legend, button, input, textarea, th, td &#123; margin:0; padding:0; &#125;<br>body, button, input, select, textarea &#123; font:12px&#x2F;1.5tahoma, arial, \5b8b\4f53; &#125;<br>h1, h2, h3, h4, h5, h6&#123; font-size:100%; &#125;<br>address, cite, dfn, em, var &#123; font-style:normal; &#125;<br>code, kbd, pre, samp &#123; font-family:couriernew, courier, monospace; &#125;<br>small&#123; font-size:12px; &#125;<br>ul, ol &#123; list-style:none; &#125;<br>a &#123; text-decoration:none; &#125;<br>a:hover &#123; text-decoration:underline; &#125;<br>sup &#123; vertical-align:text-top; &#125;<br>sub&#123; vertical-align:text-bottom; &#125;<br>legend &#123; color:#000; &#125;<br>fieldset, img &#123; border:0; &#125;<br>button, input, select, textarea &#123; font-size:100%; &#125;<br>table &#123; border-collapse:collapse; border-spacing:0; &#125;<br></code></pre></td></tr></table></figure>
<h3>对BFC规范的理解？</h3>

<p>BFC，块级格式化上下文，一个创建了新的BFC的盒子是独立布局的，盒子里面的子元素的样式不会影响到外面的元素。在同一个BFC中的两个毗邻的块级盒在垂直方向（和布局方向有关系）的margin会发生折叠。<br>（W3C CSS 2.1 规范中的一个概念，它决定了元素如何对其内容进行布局，以及与其他元素的关系和相互作用。）<br>形成BFC:<br>1.float的值不为none。<br>2.overflow的值不为visible。<br>3.display的值为table-cell, table-caption, inline-block中的任何一个。<br>4.position的值不为relative和static。<br>BFC的规则:<br>BFC中的元素的布局是不受外界的影响（我们往往利用这个特性来消除浮动元素对其非浮动的兄弟元素和其子元素带来的影响。）并且在一个BFC中，块盒与行盒（行盒由一行中所有的内联元素所组成）都会垂直的沿着其父元素的边框排列。</p>
<h3>解释下 CSS sprites，以及你要如何在页面或网站中使用它。</h3>
CSS Sprites其实就是把网页中一些背景图片整合到一张图片文件中，再利用CSS的“background-image”，“background- repeat”，“background-position”的组合进行背景定位，background-position可以用数字能精确的定位出背景图片的位置。这样可以减少很多图片请求的开销，因为请求耗时比较长；请求虽然可以并发，但是也有限制，一般浏览器都是6个。对于未来而言，就不需要这样做了，因为有了`http2`。

<h1>html部分<h1>
<h3>说说你对语义化的理解？</h3>
1，去掉或者丢失样式的时候能够让页面呈现出清晰的结构
2，有利于SEO：和搜索引擎建立良好沟通，有助于爬虫抓取更多的有效信息：爬虫依赖于标签来确定上下文和各个关键字的权重；
3，方便其他设备解析（如屏幕阅读器、盲人阅读器、移动设备）以意义的方式来渲染网页；
4，便于团队开发和维护，语义化更具可读性，是下一步网页的重要动向，遵循W3C标准的团队都遵循这个标准，可以减少差异化。

<h3>Doctype作用? 严格模式与混杂模式如何区分？它们有何意义?</h3>

<p>（1）&lt;!DOCTYPE&gt; 声明位于文档中的最前面，处于 html 标签之前。告知浏览器以何种模式来渲染文档。<br>（2）严格模式的排版和 JS 运作模式是 以该浏览器支持的最高标准运行。<br>（3）在混杂模式中，页面以宽松的向后兼容的方式显示。模拟老式浏览器的行为以防止站点无法工作。<br>（4）DOCTYPE不存在或格式不正确会导致文档以混杂模式呈现。</p>
<h3>你知道多少种Doctype文档类型？</h3>

<p>该标签可声明三种 DTD 类型，分别表示严格版本、过渡版本以及基于框架的 HTML 文档。<br>HTML 4.01 规定了三种文档类型：Strict、Transitional 以及 Frameset。<br>XHTML 1.0 规定了三种 XML 文档类型：Strict、Transitional 以及 Frameset。<br>Standards （标准）模式（也就是严格呈现模式）用于呈现遵循最新标准的网页，而 Quirks（包容）模式（也就是松散呈现模式或者兼容模式）用于呈现为传统浏览器而设计的网页。</p>
<h3>HTML与XHTML——二者有什么区别</h3>

<p>区别：</p>
<ol>
<li>所有的标记都必须要有一个相应的结束标记</li>
<li>所有标签的元素和属性的名字都必须使用小写</li>
<li>所有的XML标记都必须合理嵌套</li>
<li>所有的属性必须用引号””括起来</li>
<li>把所有&lt;和&amp;特殊符号用编码表示</li>
<li>给所有属性赋一个值</li>
<li>不要在注释内容中使“–”</li>
<li>图片必须有说明文字</li>
</ol>
<h3>常见兼容性问题？</h3>

<ul>
<li><p>png24位的图片在iE6浏览器上出现背景，解决方案是做成PNG8.也可以引用一段脚本处理.</p>
</li>
<li><p>浏览器默认的margin和padding不同。解决方案是加一个全局的*{margin:0;padding:0;}来统一。</p>
</li>
<li><p>IE6双边距bug:块属性标签float后，又有横行的margin情况下，在ie6显示margin比设置的大。</p>
</li>
<li><p>浮动ie产生的双倍距离（IE6双边距问题：在IE6下，如果对元素设置了浮动，同时又设置了margin-left或margin-right，margin值会加倍。）<br>#box{ float:left; width:10px; margin:0 0 0 100px;}<br>这种情况之下IE会产生20px的距离，解决方案是在float的标签样式控制中加入 ——_display:inline;将其转化为行内属性。(_这个符号只有ie6会识别)</p>
</li>
<li><p>渐进识别的方式，从总体中逐渐排除局部。<br>首先，巧妙的使用“\9”这一标记，将IE游览器从所有情况中分离出来。<br>接着，再次使用“+”将IE8和IE7、IE6分离开来，这样IE8已经独立识别。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plain">css<br>.bb&#123;<br>background-color:#f1ee18;&#x2F;*所有识别*&#x2F;<br>.background-color:#00deff\9; &#x2F;*IE6、7、8识别*&#x2F;<br>+background-color:#a200ff;&#x2F;*IE6、7识别*&#x2F;<br>_background-color:#1e0bd1;&#x2F;*IE6识别*&#x2F;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>IE下,可以使用获取常规属性的方法来获取自定义属性,<br>也可以使用getAttribute()获取自定义属性;<br>Firefox下,只能使用getAttribute()获取自定义属性.<br>解决方法:统一通过getAttribute()获取自定义属性.</p>
</li>
<li><p>IE下,event对象有x,y属性,但是没有pageX,pageY属性;<br>Firefox下,event对象有pageX,pageY属性,但是没有x,y属性.</p>
</li>
<li><p>解决方法：（条件注释）缺点是在IE浏览器下可能会增加额外的HTTP请求数。</p>
</li>
<li><p>Chrome 中文界面下默认会将小于 12px 的文本强制按照 12px 显示,<br>可通过加入 CSS 属性 -webkit-text-size-adjust: none; 解决.</p>
</li>
<li><p>超链接访问过后hover样式就不出现了 被点击访问过的超链接样式不在具有hover和active了解决方法是改变CSS属性的排列顺序:<br>L-V-H-A : a:link {} a:visited {} a:hover {} a:active {}</p>
</li>
<li><p>怪异模式问题：漏写DTD声明，Firefox仍然会按照标准模式来解析网页，但在IE中会触发怪异模式。为避免怪异模式给我们带来不必要的麻烦，最好养成书写DTD声明的好习惯。现在可以使用<a href="http://www.w3.org/TR/html5/single-page.html" target="_blank" rel="noopener">html5</a>推荐的写法：<code>&lt;doctype html&gt;</code></p>
</li>
<li><p>上下margin重合问题<br>ie和ff都存在，相邻的两个div的margin-left和margin-right不会重合，但是margin-top和margin-bottom却会发生重合。<br>解决方法，养成良好的代码编写习惯，同时采用margin-top或者同时采用margin-bottom。</p>
</li>
<li><p>ie6对png图片格式支持不好(引用一段脚本处理)</p>
</li>
</ul>
<h3>解释下浮动和它的工作原理？清除浮动的技巧</h3>

<p>浮动元素脱离文档流，不占据空间。浮动元素碰到包含它的边框或者浮动元素的边框停留。<br>1 .使用空标签清除浮动。<br>这种方法是在所有浮动标签后面添加一个空标签 定义css clear:both. 弊端就是增加了无意义标签。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">&lt;div style&#x3D;&quot;clear:both;&quot;&gt;&lt;&#x2F;div&gt;<br></code></pre></td></tr></table></figure>
<p>2 .使用overflow。<br>给包含浮动元素的父标签添加css属性 overflow:auto; zoom:1; zoom:1用于兼容IE6。<br>3 .使用after伪对象清除浮动。<br>该方法只适用于非IE浏览器。具体写法可参照以下示例。使用中需注意以下几点。<br>一、该方法中必须为需要清除浮动元素的伪对象中设置 height:0，否则该元素会比实际高出若干像素；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plain">#parent:after&#123;<br>content:&quot;.&quot;;<br>height:0;<br>visibility:hidden;<br>display:block;<br>clear:both;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3>浮动元素引起的问题和解决办法？</h3>
浮动元素引起的问题：
（1）父元素的高度无法被撑开，影响与父元素同级的元素
（2）与浮动元素同级的非浮动元素会跟随其后
（3）若非第一个元素浮动，则该元素之前的元素也需要浮动，否则会影响页面显示的结构
解决方法：
使用clear:both;属性来清除元素的浮动可解决2、3问题，对于问题1，添加如下样式，给父元素添加.clearfix:after{content: ".";display: block;height: 0;clear: both;visibility: hidden;} .clearfix{display: inline-block;} /* for IE/Mac */

<h3>IE 8以下版本的浏览器中的盒模型有什么不同</h3>
IE8以下浏览器的盒模型中定义的元素的宽高不包括内边距和边框
<h3>DOM操作——怎样添加、移除、移动、复制、创建和查找节点。</h3>

<ol>
<li>创建新节点<br>createDocumentFragment() //创建一个DOM片段<br>createElement() //创建一个具体的元素<br>createTextNode() //创建一个文本节点</li>
<li>添加、移除、替换、插入<br>appendChild()<br>removeChild()<br>replaceChild()<br>insertBefore() //在已有的子节点前插入一个新的子节点</li>
<li>查找<br>getElementsByTagName() //通过标签名称<br>getElementsByName() //通过元素的Name属性的值(IE容错能力较强，会得到一个数组，其中包括id等于name值的)<br>getElementById() //通过元素Id，唯一性</li>
</ol>
<h3>html5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？如何区分 HTML 和 HTML5？</h3>
* HTML5 现在已经不是 SGML 的子集，主要是关于图像，位置，存储，多任务等功能的增加。

<ul>
<li>拖拽释放(Drag and drop) API<br>语义化更好的内容标签（header,nav,footer,aside,article,section）<br>音频、视频API(audio,video)<br>画布(Canvas) API<br>地理(Geolocation) API<br>本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失；<br>sessionStorage 的数据在浏览器关闭后自动删除;</li>
</ul>
<p>表单控件，calendar、date、time、email、url、search<br>新的技术webworker, websocket, Geolocation</p>
<ul>
<li>移除的元素<br>纯表现的元素：basefont，big，center，font, s,strike,tt,u；<br>对可用性产生负面影响的元素：frame，frameset，noframes；</li>
</ul>
<p>支持HTML5新标签：</p>
<ul>
<li>IE8/IE7/IE6支持通过document.createElement方法产生的标签，<br>可以利用这一特性让这些浏览器支持HTML5新标签，</li>
</ul>
<p>浏览器支持新标签后，还需要添加标签默认的样式：</p>
<ul>
<li>当然最好的方式是直接使用成熟的框架、使用最多的是html5shim框架<!--[if lt IE 9]>
<script> src="http://html5shim.googlecode.com/svn/trunk/html5.js"</script>
<![endif]-->

</li>
</ul>
<h3>iframe的优缺点？</h3>

<ol>
<li>iframe优点：<br>解决加载缓慢的第三方内容如图标和广告等的加载问题<br>Security sandbox<br>并行加载脚本</li>
<li>ifram的缺点：<br>iframe会阻塞主页面的Onload事件；<br>即使内容为空，加载也需要时间<br>没有语意</li>
</ol>
<h3>如何实现浏览器内多个标签页之间的通信?</h3>

<p>调用localstorge、cookies等本地存储方式</p>
<h3>webSocket如何兼容低浏览器？</h3>
Adobe Flash Socket 、 ActiveX HTMLFile (IE) 、 基于 multipart 编码发送 XHR 、 基于长轮询的 XHR

<h3>线程与进程的区别</h3>

<p>一个程序至少有一个进程,一个进程至少有一个线程.<br>线程的划分尺度小于进程，使得多线程程序的并发性高。<br>另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。<br>线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。<br>但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。<br>从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别。</p>
<h3>你如何对网站的文件和资源进行优化？</h3>

<p>文件合并<br>文件最小化/文件压缩<br>使用 CDN 托管<br>缓存的使用（多个域名来提供缓存）<br>其他</p>
<h3>请说出三种减少页面加载时间的方法。</h3>

<p>1.优化图片<br>2.图像格式的选择（GIF：提供的颜色较少，可用在一些对颜色要求不高的地方）<br>3.优化CSS（压缩合并css，如margin-top,margin-left…)<br>4.网址后加斜杠（如<a href="http://www.campr.com/目录，会判断这个“目录是什么文件类型，或者是目录。）" target="_blank" rel="noopener">www.campr.com/目录，会判断这个“目录是什么文件类型，或者是目录。）</a><br>5.标明高度和宽度（如果浏览器没有找到这两个参数，它需要一边下载图片一边计算大小，如果图片很多，浏览器需要不断地调整页面。这不但影响速度，也影响浏览体验。<br>当浏览器知道了高度和宽度参数后，即使图片暂时无法显示，页面上也会腾出图片的空位，然后继续加载后面的内容。从而加载时间快了，浏览体验也更好了。）<br>6.减少http请求（合并文件，合并图片）。</p>
<h3>什么是 FOUC（无样式内容闪烁）？你如何来避免 FOUC？</h3>
FOUC - Flash Of Unstyled Content 文档样式闪烁
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">&lt;style type&#x3D;&quot;text&#x2F;css&quot; media&#x3D;&quot;all&quot;&gt;@import &quot;..&#x2F;fouc.css&quot;;&lt;&#x2F;style&gt;<br>而引用CSS文件的@import就是造成这个问题的罪魁祸首。IE会先加载整个HTML文档的DOM，然后再去导入外部的CSS文件，因此，在页面DOM加载完成到CSS导入完成中间会有一段时间页面上的内容是没有样式的，这段时间的长短跟网速，电脑速度都有关系。<br>解决方法简单的出奇，只要在&lt;head&gt;之间加入一个&lt;link&gt;或者&lt;script&gt;元素就可以了。<br></code></pre></td></tr></table></figure>

<h3>null和undefined的区别？</h3>

<p>undefined表示缺少值，即此处应该有值，但没有定义<br>（1）变量被声明了，但没有赋值时，就等于undefined。<br>（2) 调用函数时，应该提供的参数没有提供，该参数等于undefined。<br>（3）对象没有赋值的属性，该属性的值为undefined。<br>（4）函数没有返回值时，默认返回undefined。</p>
<p>null表示没有对象，即该处不应该有值<br>（1） 作为函数的参数，表示该函数的参数不是对象。<br>（2） 作为对象原型链的终点。</p>
<h3>new操作符具体干了什么呢?</h3>

<p>1、创建一个空对象，并且 this 变量引用该对象，同时还继承了该函数的原型。<br>2、属性和方法被加入到 this 引用的对象中。<br>3、新创建的对象由 this 所引用，并且最后隐式的返回 this 。</p>
<h3>JSON 的了解？</h3>

<p>JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式。<br>它是基于JavaScript的一个子集。数据格式简单, 易于读写, 占用带宽小<br>{‘age’:’12’, ‘name’:’back’}</p>
<h3>js延迟加载的方式有哪些？</h3>

<p>defer和async、动态创建DOM方式（创建script，插入到DOM中，加载完毕后callBack）、使用jquery的getScript方法、使用setTimeout延迟方法、让js最后加载</p>
<ul>
<li>defer:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain"> 明脚本在执行时不会影响页面的构造，浏览器会立即下载，但延迟执行，即脚本会被延迟到整个页面都解析完毕之后再执行。<br>&lt;script defer src&#x3D;&quot;js&#x2F;vendor&#x2F;jquery.js&quot;&gt;&lt;&#x2F;script&gt;<br></code></pre></td></tr></table></figure>
<ul>
<li>async:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">添加此属性后，脚本和HTML将一并加载（异步），代码将顺利运行<br>&lt;script async src&#x3D;&quot;js&#x2F;vendor&#x2F;jquery.js&quot;&gt;&lt;&#x2F;script&gt;<br></code></pre></td></tr></table></figure></li>
<li>defer和async相同：<br>加载文件时不会阻塞页面渲染<br>对于内部的js不起作用<br>使用这两个属性的脚本中不能调用document.write方法</li>
<li>defer和async区别：<br>如果脚本无需等待页面解析，且无依赖独立运行，那么应使用 async。也就是每一个async属性的脚本都在它下载结束之后立即执行，同时会在window的load事件之前执行。<br>如果脚本需要等待解析，且依赖于其它脚本，调用这些脚本时应使用 defer，将关联的脚本按所需顺序置于 HTML 中。</li>
<li>jquery的getScript方法:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plain">&#x2F;&#x2F;加载并执行 test.js：<br>$.getScript(&quot;test.js&quot;);<br>&#x2F;&#x2F;加载并执行 test.js ，成功后显示信息<br>$.getScript(&quot;test.js&quot;, function()&#123;<br>  alert(&quot;Script loaded and executed.&quot;);<br>&#125;);<br></code></pre></td></tr></table></figure>

</li>
</ul>
<h3>如何解决跨域问题?</h3>

<p>jsonp、 document.domain+iframe、window.name、window.postMessage、服务器上设置代理页面</p>
<ul>
<li>jsonp的原理是动态插入script标签</li>
<li>document.domain+iframe (只有在主域相同的时候才能使用该方法)<br>1) 在<a href="http://www.a.com/a.html中：" target="_blank" rel="noopener">www.a.com/a.html中：</a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs plain">document.domain &#x3D; &#39;a.com&#39;;<br>var ifr &#x3D; document.createElement(&#39;iframe&#39;);<br>ifr.src &#x3D; &#39;http:&#x2F;&#x2F;www.script.a.com&#x2F;b.html&#39;;<br>ifr.display &#x3D; none;<br>document.body.appendChild(ifr);<br>ifr.onload &#x3D; function()&#123;<br>    var doc &#x3D; ifr.contentDocument || ifr.contentWindow.document;<br>    &#x2F;* 在这里操作doc，也就是b.html *&#x2F;<br>    ifr.onload &#x3D; null;<br>&#125;;<br></code></pre></td></tr></table></figure>
2) 在<a href="http://www.script.a.com/b.html中：" target="_blank" rel="noopener">www.script.a.com/b.html中：</a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">document.domain &#x3D; &#39;a.com&#39;;<br></code></pre></td></tr></table></figure></li>
<li>window.name 的美妙之处：name 值在不同的页面（甚至不同域名）加载后依旧存在，并且可以支持非常长的 name 值（2MB）。</li>
<li>postMessage（HTML5中的XMLHttpRequest Level 2中的API）<br>1) a.com/index.html中的代码：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs plain">&lt;iframe id&#x3D;&quot;ifr&quot; src&#x3D;&quot;b.com&#x2F;index.html&quot;&gt;&lt;&#x2F;iframe&gt;<br>&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;<br>window.onload &#x3D; function() &#123;<br>    var ifr &#x3D; document.getElementById(&#39;ifr&#39;);<br>    var targetOrigin &#x3D; &#39;http:&#x2F;&#x2F;b.com&#39;;  <br>    &#x2F;* 若写成&#39;http:&#x2F;&#x2F;b.com&#x2F;c&#x2F;proxy.html&#39;效果一样 *&#x2F;<br>    &#x2F;* 若写成&#39;http:&#x2F;&#x2F;c.com&#39;就不会执行postMessage了 *&#x2F;<br>    ifr.contentWindow.postMessage(&#39;I was there!&#39;, targetOrigin);<br>&#125;;<br>&lt;&#x2F;script&gt;<br></code></pre></td></tr></table></figure>
2) b.com/index.html中的代码：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs plain">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;<br>    window.addEventListener(&#39;message&#39;, function(event)&#123;<br>        &#x2F;&#x2F; 通过origin属性判断消息来源地址<br>        if (event.origin &#x3D;&#x3D; &#39;http:&#x2F;&#x2F;a.com&#39;) &#123;<br>            alert(event.data);    &#x2F;&#x2F; 弹出&quot;I was there!&quot;<br>            alert(event.source);  &#x2F;&#x2F; 对a.com、index.html中window对象的引用<br>                                  &#x2F;&#x2F; 但由于同源策略，这里event.source不可以访问window对象<br>        &#125;<br>    &#125;, false);<br>&lt;&#x2F;script&gt;<br></code></pre></td></tr></table></figure>

</li>
</ul>
<h3>documen.write和 innerHTML的区别</h3>

<p>document.write只能重绘整个页面<br>innerHTML可以重绘页面的一部分</p>
<h3>.call() 和 .apply() 的区别和作用？</h3>

<p>作用：调用一个对象的一个方法，用另一个对象替换当前对象。<br>B.apply(A, arguments);<br>B.call(A, args1,args2);</p>
<ul>
<li>call 与 apply 的相同点：<br>方法的含义是一样的，即方法功能是一样的；<br>第一个参数的作用是一样的；</li>
<li>call 与 apply 的不同点：两者传入的列表形式不一样<br>call可以传入多个参数；<br>apply只能传入两个参数，所以其第二个参数往往是作为数组形式传入</li>
</ul>
<h3>哪些操作会造成内存泄漏？</h3>

<p>内存泄漏指任何对象在您不再拥有或需要它之后仍然存在。<br>垃圾回收器定期扫描对象，并计算引用了每个对象的其他对象的数量。如果一个对象的引用数量为 0（没有其他对象引用过该对象），或对该对象的惟一引用是循环的，那么该对象的内存即可回收。<br>setTimeout 的第一个参数使用字符串而非函数的话，会引发内存泄漏。<br>闭包、控制台日志、循环（在两个对象彼此引用且彼此保留时，就会产生一个循环）</p>
<h3>什么叫优雅降级和渐进增强？</h3>

<p>优雅降级：Web站点在所有新式浏览器中都能正常工作，如果用户使用的是老式浏览器，则代码会检查以确认它们是否能正常工作。由于IE独特的盒模型布局问题，针对不同版本的IE的hack实践过优雅降级了,为那些无法支持功能的浏览器增加候选方案，使之在旧式浏览器上以某种形式降级体验却不至于完全失效.</p>
<p>渐进增强：从被所有浏览器支持的基本功能开始，逐步地添加那些只有新式浏览器才支持的功能,向页面增加无害于基础浏览器的额外样式和功能的。当浏览器支持时，它们会自动地呈现出来并发挥作用。</p>
<h3>WEB应用从服务器主动推送Data到客户端有那些方式？</h3>

<ol>
<li>html5 websocket</li>
<li>WebSocket 通过 Flash</li>
<li>XHR长时间连接</li>
<li>XHR Multipart Streaming</li>
<li>不可见的Iframe</li>
<li>script标签的长时间连接(可跨域)</li>
</ol>
<h3>对Node的优点和缺点提出了自己的看法？</h3>

<ul>
<li><p>（优点）因为Node是基于事件驱动和无阻塞的，所以非常适合处理并发请求，<br>因此构建在Node上的代理服务器相比其他技术实现（如Ruby）的服务器表现要好得多。<br>此外，与Node代理服务器交互的客户端代码是由javascript语言编写的，<br>因此客户端和服务器端都用同一种语言编写，这是非常美妙的事情。</p>
</li>
<li><p>（缺点）Node是一个相对新的开源项目，所以不太稳定，它总是一直在变，<br>而且缺少足够多的第三方库支持。看起来，就像是Ruby/Rails当年的样子。</p>
</li>
</ul>
<h3>你有哪些性能优化的方法？</h3>

<ol>
<li>减少http请求次数：CSS Sprites, JS、CSS源码压缩、图片大小控制合适；网页Gzip，CDN托管，data缓存 ，图片服务器。</li>
<li>前端模板 JS+数据，减少由于HTML标签导致的带宽浪费，前端用变量保存AJAX请求结果，每次操作本地变量，不用请求，减少请求次数</li>
<li>用innerHTML代替DOM操作，减少DOM操作次数，优化javascript性能。</li>
<li>当需要设置的样式很多时设置className而不是直接操作style。</li>
<li>少用全局变量、缓存DOM节点查找的结果。减少IO读取操作。</li>
<li>避免使用CSS Expression（css表达式）又称Dynamic properties(动态属性)。</li>
<li>图片预加载，将样式表放在顶部，将脚本放在底部 加上时间戳。</li>
</ol>
<h3>http状态码有那些？分别代表是什么意思？</h3>

<p>100-199 用于指定客户端应相应的某些动作。<br>200-299 用于表示请求成功。<br>300-399 用于已经移动的文件并且常被包含在定位头信息中指定新的地址信息。<br>400-499 用于指出客户端的错误。400 1、语义有误，当前请求无法被服务器理解。401 当前请求需要用户验证 403 服务器已经理解请求，但是拒绝执行它。<br>500-599 用于支持服务器错误。 503 – 服务不可用</p>
<h3>一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？</h3>

<p>分为4个步骤：<br>（1），当发送一个URL请求时，不管这个URL是Web页面的URL还是Web页面上每个资源的URL，浏览器都会开启一个线程来处理这个请求，同时在远程DNS服务器上启动一个DNS查询。这能使浏览器获得请求对应的IP地址。<br>（2）， 浏览器与远程Web服务器通过TCP三次握手协商来建立一个TCP/IP连接。该握手包括一个同步报文，一个同步-应答报文和一个应答报文，这三个报文在 浏览器和服务器之间传递。该握手首先由客户端尝试建立起通信，而后服务器应答并接受客户端的请求，最后由客户端发出该请求已经被接受的报文。<br>（3），一旦TCP/IP连接建立，浏览器会通过该连接向远程服务器发送HTTP的GET请求。远程服务器找到资源并使用HTTP响应返回该资源，值为200的HTTP响应状态表示一个正确的响应。<br>（4），此时，Web服务器提供资源服务，客户端开始下载资源。</p>
<p>请求返回后，便进入了我们关注的前端模块<br>简单来说，浏览器会解析HTML生成DOM Tree，其次会根据CSS生成CSS Rule Tree，而javascript又可以根据DOM API操作DOM</p>
<h3>javascript对象的几种创建方式</h3>

<ol>
<li><p>工厂模式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs plain">function createPerson(name,age,job)&#123;<br>    var o &#x3D; new Object();<br>    o.name &#x3D; name;<br>    o.age &#x3D; age;<br>    o.job &#x3D; job;<br>    o.sayname &#x3D; function()&#123;<br>        alert(this.name);<br>    &#125;;<br>    return o;<br>&#125;<br>var person1 &#x3D; createPerson(&quot;a&quot;,29,&quot;cc&quot;);<br>var person2 &#x3D; createPerson(&quot;b&quot;,26,&quot;cc&quot;);<br></code></pre></td></tr></table></figure></li>
<li><p>构造函数模式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs plain">function Person(name,age,job)&#123;<br>    this.name &#x3D; name;<br>    this.age &#x3D; age;<br>    this.job &#x3D; job;<br>    this.sayname &#x3D; function()&#123;<br>        alert(this.name);<br>    &#125;;<br>&#125;<br>var person1 &#x3D; new Person(&quot;a&quot;,29,&quot;cc&quot;);<br>var person2 &#x3D; new Person(&quot;b&quot;,26,&quot;cc&quot;);<br></code></pre></td></tr></table></figure>
<p>使用自定义的构造函数，可以将它的实例标识为一种特定的类型，这正是构造函数模式胜过工厂模式的地方。<br>比如（instanceof用于检测对象类型）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">person1 instanceof Person  &#x2F;&#x2F;true    这里可以看到person1也是Person的实例，而工厂模式没有能具体检测对象类型的这一特定<br>person1 instanceof Object &#x2F;&#x2F;true    所有对象均继承自Object<br></code></pre></td></tr></table></figure>
<p>构造函数模式的主要问题，就是每个方法都要在每个实例对象上重新创建一遍，即使是同名方法或者两个方法的作用一样，而不同实例对象上的同名方法其实是不一样的，这样就造成了一种冗余，比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">person1.sayname !&#x3D; person2.sayname<br></code></pre></td></tr></table></figure>
</li>
<li><p>原型模式</p>
</li>
</ol>
<p>使用原型对象的好处就是，可以让所有对象实例共享它所包含的属性和方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs plain">function Person()&#123;&#125;<br>Person.prototype.name&#x3D;&quot;a&quot;;<br>Person.prototype.age&#x3D;&quot;29&quot;;<br>Person.prototype.job&#x3D;&quot;cc&quot;;<br>Person.prototype.sayname &#x3D; function()&#123;<br>        alert(this.name);<br>&#125;;<br>var person1 &#x3D; new Person();<br>var person2 &#x3D; new Person();<br>这样person1.sayname &#x3D;&#x3D; person2.sayname<br></code></pre></td></tr></table></figure>
<ol start="4">
<li>混合构造函数和原型模式<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs plain">function createPerson(name,age,job)&#123;<br>    var o &#x3D; new Object();<br>    o.name &#x3D; name;<br>    o.age &#x3D; age;<br>    o.job &#x3D; job;<br>    o.sayname &#x3D; function()&#123;<br>        alert(this.name);<br>    &#125;;<br>    return o;<br>&#125;<br>var person1 &#x3D; createPerson(&quot;a&quot;,29,&quot;cc&quot;);<br>var person2 &#x3D; createPerson(&quot;b&quot;,26,&quot;cc&quot;);<br></code></pre></td></tr></table></figure></li>
<li>动态原型模式</li>
<li>寄生构造函数模式</li>
<li>稳妥构造函数模式</li>
</ol>
<h3>ajax过程</h3>

<p>(1)创建XMLHttpRequest对象,也就是创建一个异步调用对象.<br>(2)创建一个新的HTTP请求,并指定该HTTP请求的方法、URL及验证信息.<br>(3)设置响应HTTP请求状态变化的函数.<br>(4)发送HTTP请求.<br>(5)获取异步调用返回的数据.<br>(6)使用JavaScript和DOM实现局部刷新.</p>
<h3>异步加载和延迟加载</h3>

<p>1.异步加载的方案： 动态插入script标签<br>2.通过ajax去获取js代码，然后通过eval执行<br>3.script标签上添加defer或者async属性<br>4.创建并插入iframe，让它异步执行js<br>5.延迟加载：有些 js 代码并不是页面初始化的时候就立刻需要的，而稍后的某些情况才需要的。</p>
<h3>前端安全问题？</h3>

<ol>
<li>SQL注入：<br>这个比较常见，可能大家也听说过，就是URL里面如果有对数据库进行操作的参数时，要做一下特殊的处理，<br>否则被别有用心的人利用的话就可能酿成大错，轻则用户信息泄露，重则数据库被删.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">(1) 防止系统敏感信息泄露。设置php.ini选项display_errors&#x3D;off，防止php脚本出错之后，在web页面输出敏感信息错误，让攻击者有机可乘。<br>(2) 数据转义。设置php.ini选项magic_quotes_gpc&#x3D;on，它会将提交的变量中所有的’(单引号)，”(双引号)，\(反斜杠)，空白字符等都在前面自动加上\。或者采用mysql_real_escape()函数或addslashes()函数进行输入参数的转义。<br>(3) 增加黑名单或者白名单验证。白名单验证一般指，检查用户输入是否是符合预期的类型、长度、数值范围或者其他格式标准。黑名单验证是指，若在用户输入中，包含明显的恶意内容则拒绝该条用户请求。在使用白名单验证时，一般会配合黑名单验证。<br></code></pre></td></tr></table></figure></li>
<li>XSS 全称跨站脚本攻击<br>这个大家都做过处理，但是并不一定知道名字，（Cross Site Scripting, 安全专家们通常将其缩写成XSS,原本应当是css，但为了和层叠样式表（Cascading Style Sheet,CSS ）有所区分，故称XSS）,<br>这种问题通常是由于对用户的输入没有严格的加以过滤导致的<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs plain">(1) 输入过滤。永远不要相信用户的输入，对用户输入的数据做一定的过滤。如输入的数据是否符合预期的格式，比如日期格式，Email格式，电话号码格式等等。这样可以初步对XSS漏洞进行防御。上面的措施只在web端做了限制，攻击者通抓包工具如Fiddler还是可以绕过前端输入的限制，修改请求注入攻击脚本。<br>因此，后台服务器需要在接收到用户输入的数据后，对特殊危险字符进行过滤或者转义处理，然后再存储到数据库中。<br><br>(2) 输出编码。服务器端输出到浏览器的数据，可以使用系统的安全函数来进行编码或转义来防范XSS攻击。在PHP中，有htmlentities()和htmlspecialchars()两个函数可以满足安全要求。相应的JavaScript的编码方式可以使用JavascriptEncode。<br><br>(3) 安全编码。开发需尽量避免Web客户端文档重写、重定向或其他敏感操作，同时要避免使用客户端数据，这些操作需尽量在服务器端使用动态页面来实现。<br><br>(4) HttpOnly Cookie。预防XSS攻击窃取用户cookie最有效的防御手段。Web应用程序在设置cookie时，将其属性设为HttpOnly，就可以避免该网页的cookie被客户端恶意JavaScript窃取，保护用户cookie信息。<br><br>(5)WAF(Web Application Firewall)，Web应用防火墙，主要的功能是防范诸如网页木马、XSS以及CSRF等常见的Web漏洞攻击。由第三方公司开发，在企业环境中深受欢迎<br></code></pre></td></tr></table></figure></li>
<li>CSRF （Cross-site request forgery）跨站请求伪造<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plain">(1) 验证码。应用程序和用户进行交互过程中，特别是账户交易这种核心步骤，强制用户输入验证码，才能完成最终请求。在通常情况下，验证码够很好地遏制CSRF攻击。但增加验证码降低了用户的体验，网站不能给所有的操作都加上验证码。所以只能将验证码作为一种辅助手段，在关键业务点设置验证码。<br><br>(2) Referer Check。HTTP Referer是header的一部分，当浏览器向web服务器发送请求时，一般会带上Referer信息告诉服务器是从哪个页面链接过来的，服务器籍此可以获得一些信息用于处理。可以通过检查请求的来源来防御CSRF攻击。正常请求的referer具有一定规律，如在提交表单的referer必定是在该页面发起的请求。所以通过检查http包头referer的值是不是这个页面，来判断是不是CSRF攻击。但在某些情况下如从https跳转到http，浏览器处于安全考虑，不会发送referer，服务器就无法进行check了。若与该网站同域的其他网站有XSS漏洞，那么攻击者可以在其他网站注入恶意脚本，受害者进入了此类同域的网址，也会遭受攻击。出于以上原因，无法完全依赖Referer Check作为防御CSRF的主要手段。但是可以通过Referer Check来监控CSRF攻击的发生。<br><br>(3) Anti CSRF Token。目前比较完善的解决方案是加入Anti-CSRF-Token，即发送请求时在HTTP 请求中以参数的形式加入一个随机产生的token，并在服务器建立一个拦截器来验证这个token。服务器读取浏览器当前域cookie中这个token值，会进行校验该请求当中的token和cookie当中的token值是否都存在且相等，才认为这是合法的请求。否则认为这次请求是违法的，拒绝该次服务。这种方法相比Referer检查要安全很多，token可以在用户登陆后产生并放于session或cookie中，然后在每次请求时服务器把token从session或cookie中拿出，与本次请求中的token 进行比对。由于token的存在，攻击者无法再构造出一个完整的URL实施CSRF攻击。但在处理多个页面共存问题时，当某个页面消耗掉token后，其他页面的表单保存的还是被消耗掉的那个token，其他页面的表单提交时会出现token错误<br></code></pre></td></tr></table></figure></li>
<li>文件上传漏洞<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plain">(1) 检查服务器是否判断了上传文件类型及后缀。<br><br>(2) 定义上传文件类型白名单，即只允许白名单里面类型的文件上传。<br><br>(3) 文件上传目录禁止执行脚本解析，避免攻击者进行二次攻击。  Info漏洞 Info漏洞就是CGI把输入的参数原样输出到页面，攻击者通过修改输入参数而达到欺骗用户的目的。<br></code></pre></td></tr></table></figure>

</li>
</ol>
<h3>ie各版本和chrome可以并行下载多少个资源</h3>

<p>IE6 两个并发，iE7升级之后的6个并发，之后版本也是6个<br>Firefox，chrome也是6个</p>
<h3>javascript里面的继承怎么实现，如何避免原型链上面的对象共享</h3>

<p>用构造函数和原型链的混合模式去实现继承，避免对象共享可以参考经典的extend()函数，很多前端框架都有封装的，就是用一个空函数当做中间变量<br>1.利用原型来继承,通过增加一个空的函数来避免原型链上的对象共享</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plain">var a &#x3D; &#123;name：“小明”&#125;；<br>var b &#x3D; cloneObj(a);<br> function cloneObj(obj)&#123;<br>        var f &#x3D; function(）&#123;&#125;；<br>        f.prototype &#x3D; obj;<br>        return new f();<br>&#125;<br></code></pre></td></tr></table></figure>
<p>2.使用extend，多用于插件封装</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plain">示例：<br>Var item&#x3D;&#123;name:”olive”,age:23&#125;;<br>Var item1&#x3D;&#123;name:”Momo”,sex:”gril”&#125;;<br>Var result&#x3D;$.extend(&#123;&#125;,item,item1);<br>结果：<br>Result&#x3D;&#123;name:”Momo”,age:23,sex:”gril”&#125;;<br></code></pre></td></tr></table></figure>

<p>Flash、Ajax各自的优缺点，在使用中如何取舍？</p>
<h3>Flash ajax对比</h3>

<p>Flash适合处理多媒体、矢量图形、访问机器；对CSS、处理文本上不足，不容易被搜索。<br>Ajax对CSS、文本支持很好，支持搜索；多媒体、矢量图形、机器访问不足。<br>共同点：与服务器的无刷新传递消息、用户离线和在线状态、操作DOM</p>
<h3>请解释一下 JavaScript 的同源策略。</h3>

<p>概念:同源策略是客户端脚本（尤其是Netscape Navigator2.0，其目的是防止某个文档或脚本从多个不同源装载。<br>这里的同源策略指的是：协议，域名，端口相同，同源策略是一种安全协议。<br>指一段脚本只能读取来自同一来源的窗口和文档的属性。</p>
<p>为什么要有同源限制？<br>比如一个黑客程序，他利用Iframe把真正的银行登录页面嵌到他的页面上，当你使用真实的用户名，密码登录时，他的页面就可以通过Javascript读取到你的表单中input中的内容，这样用户名，密码就轻松到手了。</p>
<h3>什么是 "use strict"; ? 使用它的好处和坏处分别是什么？</h3>

<p>“use strict” =&gt; 严格模式”<br>是一种在JavaScript代码运行时自动实行更严格解析和错误处理的方法。这种模式使得Javascript在更严格的条件下运行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs plain">function doSomething() &#123; <br>&quot;use strict&quot;; <br> 严格模式下运行 <br>&#125;<br><br>function doSomethingElse() &#123; <br> 非严格模式下运行 <br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>设立”严格模式”的目的，主要有以下几个：</li>
</ul>
<ul>
<li>消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为;</li>
<li>消除代码运行的一些不安全之处，保证代码运行的安全；</li>
<li>提高编译器效率，增加运行速度；</li>
<li>为未来新版本的Javascript做好铺垫。<br>注：经过测试 ie6,7,8,9均不支持</li>
</ul>
<ul>
<li>缺点：<br>现在网站的 JS 都会进行压缩，一些文件用了严格模式，而另一些没有。这时这些本来是严格模式的文件，被 merge 后，这个串就到了文件的中间，不仅没有指示严格模式，反而在压缩后浪费了字节。</li>
</ul>
<h3>GET和POST的区别，何时使用POST？</h3>

<p>GET：一般用于信息获取，使用URL传递参数，对所发送信息的数量也有限制，一般在2000个字符<br>POST：一般用于修改服务器上的资源，对所发送的信息没有限制。</p>
<p>GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form来获取变量的值，<br>也就是说Get是通过地址栏来传值，而Post是通过提交表单来传值。</p>
<p>然而，在以下情况中，请使用 POST 请求：<br>无法使用缓存文件（更新服务器上的文件或数据库）<br>向服务器发送大量数据（POST 没有数据量限制）<br>发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠</p>
<h3>哪些地方会出现css阻塞，哪些地方会出现js阻塞？</h3>

<h5>1. js的阻塞特性：</h5>

<p>所有浏览器在下载JS的时候,会阻止一切其他活动,比如其他资源的下载,内容的呈现等等。<br>直到JS下载、解析、执行完毕后才开始继续并行下载其他资源并呈现内容。<br>为了提高用户体验,新一代浏览器都支持并行下载JS,但是JS下载仍然会阻塞其它资源的下载（例如.图片,css文件等）。</p>
<ul>
<li>由于浏览器为了防止出现JS修改DOM树,需要重新构建DOM树的情况,所以就会阻塞其他的下载和呈现。<br>嵌入JS会阻塞所有内容的呈现,而外部JS只会阻塞其后内容的显示,2种方式都会阻塞其后资源的下载。<br>也就是说外部样式不会阻塞外部脚本的加载,但会阻塞外部脚本的执行。</li>
</ul>
<h5>2. CSS怎么会阻塞加载了？</h5>

<p>CSS本来是可以并行下载的,在什么情况下会出现阻塞加载了(在测试观察中,IE6下CSS都是阻塞加载）</p>
<ul>
<li>当CSS后面跟着嵌入的JS的时候,该CSS就会出现阻塞后面资源下载的情况;</li>
<li>而当把嵌入JS放到CSS前面,就不会出现阻塞的情况了。</li>
<li>根本原因：因为浏览器会维持html中css和js的顺序,样式表必须在嵌入的JS执行前先加载、解析完。而嵌入的JS会阻塞后面的资源加载,所以就会出现上面CSS阻塞下载的情况。</li>
</ul>
<h5>3. 嵌入JS应该放在什么位置？</h5>

<p>1、放在底部,虽然放在底部照样会阻塞所有呈现,但不会阻塞资源下载。<br>2、如果嵌入JS放在head中,请把嵌入JS放在CSS头部。<br>3、使用defer（只支持IE）<br>4、不要在嵌入的JS中调用运行时间较长的函数,如果一定要用,可以用<code>setTimeout</code>来调用</p>
<h3>eval是做什么的？</h3>

<p>eval的功能是把字符串参数解析成JS代码并运行，并返回执行的结果；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">eval(&quot;2+3&quot;);&#x2F;&#x2F;执行加运算，并返回运算值。<br>eval(&quot;var age&#x3D;10&quot;);&#x2F;&#x2F;声明一个age变量<br></code></pre></td></tr></table></figure>
<p>eval的作用域在它所有的范围内容有效</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plain">functiona()&#123;<br> eval(&quot;var x&#x3D;1&quot;);&#x2F;* 等效于 var x&#x3D;1 *&#x2F;;<br><br> console.log(x);&#x2F;* 输出1 *&#x2F;<br>&#125;<br>a();<br>console.log(x);&#x2F;&#x2F;错误 x没有定<br></code></pre></td></tr></table></figure>
<p>应该避免使用eval，不安全，非常耗性能（2次，一次解析成js语句，一次执行）。<br>由JSON字符串转换为JSON对象的时候可以用eval，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">varjson&#x3D;&quot;&#123;name:&#39;Mr.CAO&#39;,age:30&#125;&quot;;<br>varjsonObj&#x3D;eval(&quot;(&quot;+json+&quot;)&quot;);<br>console.log(jsonObj);<br></code></pre></td></tr></table></figure>

<h3>JavaScript原型，原型链 ? 有什么特点？</h3>

<ul>
<li>原型对象也是普通的对象，是对象一个自带隐式的 <strong>proto</strong> 属性，原型也有可能有自己的原型，如果一个原型对象的原型不为null的话，我们就称之为原型链。</li>
<li>每个对象都会在其内部初始化一个属性，就是prototype(原型)，当我们访问一个对象的属性时，如果这个对象内部不存在这个属性，那么他就会去prototype里找这个属性，这个prototype又会有自己的prototype,于是就这样一直找下去，也就是我们平时所说的原型链的概念。</li>
<li>原型链是由一些用来继承和共享属性的对象组成的（有限的）对象链。</li>
</ul>
<h3>页面重构怎么操作？</h3>

<p>页面重构就是根据原有页面内容和结构的基础上，通过div+css写出符合web标准的页面结构。<br>具体实现要达到以下三点：</p>
<ol>
<li>结构完整，可通过标准验证</li>
<li>标签语义化，结构合理</li>
<li>充分考虑到页面在站点中的“作用和重要性”，并对其进行有针对性的优化</li>
</ol>
<p>事件、IE与火狐的事件机制有什么区别？ 如何阻止冒泡？</p>
<ol>
<li>我们在网页中的某个操作（有的操作对应多个事件）。例如：当我们点击一个按钮就会产生一个事件。是可以被 JavaScript 侦测到的行为。</li>
<li>事件处理机制：IE是事件冒泡、firefox同时支持两种事件模型，也就是：捕获型事件和冒泡型事件。；</li>
<li>ev.stopPropagation();注意旧ie的方法 ev.cancelBubble = true;</li>
</ol>
<h3>ajax 是什么?ajax 的交互模型?同步和异步的区别?如何解决跨域问题?</h3>
<h5>1. Ajax的优点是什么。</h5>

<p>1、通过异步模式，提升了用户体验<br>2、优化了浏览器和服务器之间的传输，减少不必要的数据往返，减少了带宽占用<br>3、Ajax在客户端运行，承担了一部分本来由服务器承担的工作，减少了大用户量下的服务器负载。</p>
<h5>2. Ajax的最大的特点是什么。</h5>

<p>Ajax可以实现动态不刷新（局部刷新）<br>readyState属性 状态 有5个可取值： 0=未初始化 ，1=启动 2=发送，3=接收，4=完成</p>
<h5>3. ajax的缺点</h5>

<p>1、ajax不支持浏览器back按钮。<br>2、安全问题 AJAX暴露了与服务器交互的细节。<br>3、对搜索引擎的支持比较弱。<br>4、破坏了程序的异常机制。<br>5、不容易调试。</p>
<h5>4. 解决跨域</h5>

<p>1、响应头添加Header允许访问<br>2、jsonp 只支持get请求不支持post请求<br>3、httpClient内部转发<br>4、使用接口网关——nginx、springcloud zuul   (互联网公司常规解决方案)</p>
<h3>js对象的深度克隆</h3>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs plain">function clone(Obj) &#123;<br>    var buf;<br>    if (Obj instanceof Array) &#123;<br>        buf &#x3D; []; &#x2F;&#x2F;创建一个空的数组<br>        var i &#x3D; Obj.length;<br>        while (i--) &#123;<br>            buf[i] &#x3D; clone(Obj[i]);<br>        &#125;<br>        return buf;<br>    &#125;else if (Obj instanceof Object)&#123;<br>        buf &#x3D; &#123;&#125;; &#x2F;&#x2F;创建一个空对象<br>        for (var k in Obj) &#123; &#x2F;&#x2F;为这个对象添加新的属性<br>            buf[k] &#x3D; clone(Obj[k]);<br>        &#125;<br>        return buf;<br>    &#125;else&#123;<br>        return Obj;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

</h1></h1>
        </div>
      </div>
    </div>
  </div>
</article>



    <!-- Footer -->
<footer>
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <p class="copyright text-muted">
          Theme By <a target="_blank" href="https://github.com/levblanc">Levblanc.</a>
          Inspired By <a target="_blank" href="https://github.com/klugjo/hexo-theme-clean-blog">Clean Blog.</a>
        <p class="copyright text-muted">
          Powered By <a target="_blank" href="https://hexo.io/">Hexo.</a>
        </p>
      </div>
    </div>
  </div>
</footer>


    <!-- After Footer Scripts -->

<script src="/js/highlight.pack.js"></script>

<script>
  document.addEventListener("DOMContentLoaded", function(event) {
    var codeBlocks = Array.prototype.slice.call(document.getElementsByTagName('pre'))
    codeBlocks.forEach(function(block, index) {
      hljs.highlightBlock(block);
    });
  });
</script>

  </body>
</html>

