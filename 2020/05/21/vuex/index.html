<!DOCTYPE html>
<html>
  <!-- Html Head Tag-->
  <head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content="">
  <meta name="author" content="陈sis">
  <!-- Open Graph Data -->
  <meta property="og:title" content="vuex"/>
  <meta property="og:description" content="" />
  <meta property="og:site_name" content="陈sis的博客"/>
  <meta property="og:type" content="article" />
  <meta property="og:image" content="http://yoursite.com"/>
  
    <link rel="alternate" href="/atom.xml" title="陈sis的博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  

  <!-- Site Title -->
  <title>陈sis的博客</title>

  <!-- Bootstrap CSS -->
  
<link rel="stylesheet" href="/css/bootstrap.min.css">

  <!-- Custom CSS -->
  
  
<link rel="stylesheet" href="/css/style.light.css">


  <!-- Google Analytics -->
  

<meta name="generator" content="Hexo 4.2.0"></head>

  <script type="text/javascript" src="/js/jquery.min.js"></script>
  <script type="text/javascript" src="/js/hljs.js"></script>
  <body>
    <!-- Page Header -->


<header class="site-header header-background" style="background-image: url(/img/default-banner-dark.jpg)">
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <div class="page-title with-background-image">
          <p class="title">vuex</p>
          <p class="subtitle"></p>
        </div>
        <div class="site-menu with-background-image">
          <ul>
            
              <li>
                <a href="/">
                  
                  主页
                  
                </a>
              </li>
            
              <li>
                <a href="/archives">
                  
                  档案
                  
                </a>
              </li>
            
              <li>
                <a href="http://101.200.152.80/" target="_blank" rel="noopener">
                  
                  服务器
                  
                </a>
              </li>
            
          </ul>
        </div>
      </div>
    </div>
  </div>
</header>

<article>
  <div class="container typo">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <div class="post-info text-muted">
          
            <!-- Author -->
            <span class="author info">By 陈sis</span>
          
          <!-- Date -->
          <span class="date-time info">On
            <span class="date">2020-05-21</span>
            <span class="time">10:53:43</span>
          </span>
          
        </div>
        <!-- Tags -->
        
          <div class="post-tags text-muted">
            Tags: 

<a class="tag" href="/tags/vue/">#vue</a>


          </div>
        
        <!-- Post Main Content -->
        <div class="post-content">
          <p>关于全局对象和 Vuex 之间的区别，官方写得还是比较通俗易懂的：<br>Vuex 和单纯的全局对象有以下两点不同：<br>Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。<br>你不能直接改变 store 中的状态。改变 store 中状态的唯一途径就是显式地提交 (commit) mutation。这样使得我们可以方便地跟踪每一个状态的变化，从而让我们能够实现一些工具帮助我们更好地了解我们的应用。<br>简单示例<br>// 如果在模块化构建系统中，请确保在开头调用了 Vue.use(Vuex)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs plain">const store &#x3D; new Vuex.Store(&#123;<br>  state: &#123;<br>    count: 0<br>  &#125;,<br>  mutations: &#123;<br>    increment (state) &#123;<br>      state.count++<br>    &#125;<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure>
<p>每一个 Vuex 应用的核心就是 store（仓库）。store 基本上就是一个容器，它包含着你的应用中大部分的状态 (state)。<br>注意：如果 mutations 不知道是什么，没关系，后面会专门讲解到，可以单纯的理解为只能用它里面的方法来修改 state 中的数据。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">store.commit(&#39;increment&#39;) &#x2F;* 调用 mutations 中的方法 *&#x2F;<br>console.log(store.state.count) &#x2F;&#x2F; -&gt; 1<br></code></pre></td></tr></table></figure>
<h3>State</h3>

<p>我们再回过头来看一下之前那个简单的 Store 示例代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs plain">import Vue from &#39;vue&#39;<br>import Vuex from &#39;vuex&#39;<br><br>Vue.use(Vuex)<br><br>const store &#x3D; new Vuex.Store(&#123;<br>  state: &#123;<br>    count: 0<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure>
<p>那么我们如何在 Vue 组件中展示状态呢？由于 Vuex 的状态存储是响应式的，从 store 实例中读取状态最简单的方法就是在计算属性中返回某个状态，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs plain">&#x2F;* 创建一个 Counter 组件 *&#x2F;<br>const Counter &#x3D; &#123;<br>  data() &#123; return &#123;&#125; &#125;,<br>  template: &#96;&lt;div&gt;&#123;&#123; count &#125;&#125;&lt;&#x2F;div&gt;&#96;,<br>  computed: &#123;<br>    count () &#123;<br>      return store.state.count<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>/*  每当 store.state.count 变化的时候, 都会重新求取计算属性，并刷新界面。 */</p>
<p>需要注意的是，如果你把 store.state.count 放在 data 中， store.state.count 的变化是不会主动触发界面刷新的，当然，也不能直接这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">&lt;div&gt;&#123;&#123; store.state.count &#125;&#125;&lt;&#x2F;div&gt;<br></code></pre></td></tr></table></figure>

<p>因为在模板中是无法直接访问到 store 对象的，所以这样写无疑会报错。</p>
<p>这种模式依赖于全局的管理员 store，如果模块多了，意味着每个模块或者页面只要用到了这个 state 里面的数据，都得把 store 引入进来，这样的操作确实有点难受。当然，官方肯定是不允许有这样令人抓狂的操作出现的：</p>
<p>Vuex 通过 store 选项，提供了一种机制将状态从根组件 “注入” 到每一个子组件中（需调用 Vue.use(Vuex)）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs plain">const app &#x3D; new Vue(&#123;<br>  el: &#39;#app&#39;,<br>  &#x2F;&#x2F; 把 store 对象提供给 “store” 选项，<br>  &#x2F;&#x2F; 这可以把 store 的实例注入所有的子组件<br>  store,<br>  &#x2F;&#x2F; 子组件<br>  components: &#123; Counter &#125;,<br>  template: &#39;&lt;div class&#x3D;&quot;app&quot;&gt;<br>      &lt;counter&gt;&lt;&#x2F;counter&gt;<br>    &lt;&#x2F;div&gt;&#39;<br>&#125;)<br></code></pre></td></tr></table></figure>
<p>通过在根实例中注册 store 选项，该 store 实例会注入到根组件下的所有子组件中，且子组件能通过 this.$store 访问到。让我们更新下 Counter 的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs plain">const Counter &#x3D; &#123;<br>  template: &#96;&lt;div&gt;&#123;&#123; count &#125;&#125;&lt;&#x2F;div&gt;&#96;,<br>  computed: &#123;<br>    count () &#123;<br>      return this.$store.state.count<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>Vuex 的状态固然好用，但是也不要滥用：</p>
<p>使用 Vuex 并不意味着你需要将所有的状态放入 Vuex。虽然将所有的状态放到 Vuex 会使状态变化更显式和易调试，但也会使代码变得冗长和不直观。如果有些状态严格属于单个组件，最好还是作为组件的局部状态。你应该根据你的应用开发需要进行权衡和确定。</p>
<h3>Getter</h3>

<p>有时候，我们会发现 State 中的数据，并不是我们直接想要的，而是需要经过相应的处理后，才能满足我们的需求。<br>比如在一个组件中，我们需要把 state 中的日期 date 转换成星期几来展示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plain">computed: &#123;<br>  weekDate () &#123;<br>    return moment(this.$store.state.date).format(&#39;dddd&#39;); <br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>如果只有一个组件需要这样做还好，但如果在很多组件中，都需要这么转换的话，那就得在每一个组件中都需要把这个函数复制过去。而且，一旦产品经理心情不好，不想用星期几来显示，想直接用 2018-10-30 11:12:23 这种方式来显示日期，那你就得在所有用到它的组件中去更改日期格式化的方法，岂不难受至极。就算你把它单独抽取出来作为一个公共的函数，各种导入也麻烦，最重要的是不好统一管理。</p>
<p>所以，这个时候，Vuex 又引入了一个牛逼的玩意儿，Getter。我们可以把它当成 store 中的计算属性（computed）。</p>
<p>就像计算属性一样，getter 的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算。</p>
<p>我们看看这两个例子，着重注意下里面的注释：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs plain">const store &#x3D; new Vuex.Store(&#123;<br>  state: &#123;<br>    date: new Date()<br>  &#125;,<br>  getters: &#123;<br>    &#x2F;* Getter 接受 state 作为其第一个参数 *&#x2F;<br>    weekDate: state &#x3D;&gt; &#123;<br>      return moment(state.date).format(&#39;dddd&#39;); <br>    &#125;<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plain">getters: &#123;<br>  &#x2F;* Getter 还也可以接收 getters 作为第二个参数 *&#x2F;<br>  dateLength: (state, getters) &#x3D;&gt; &#123;<br>    return getters.weekDate.length;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>不但如此，Getter 还会将 store.getters 对象暴露出去，你可以以属性的形式访问这些值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">console.log(store.getters.weekDate)<br></code></pre></td></tr></table></figure>
<p>我们可以很容易地在任何组件中使用它：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plain">computed: &#123;<br>  weekDate () &#123;<br>    return this.$store.getters.weekDate<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>现在需求又变了，每个模块要显示的 weekDate 的格式不一样，有的显示全部日期，有的需要显示星期几，怎么办？</p>
<p>好办，那就给 Getter 传参呗，但是怎么传呢？</p>
<p>因为 Getter 在通过属性访问时是作为 Vue 的响应式系统的一部分缓存其中的，所以是不能直接 store.getters.weekDate(‘MM Do YY’)，因为 weekDate 并不是一个函数，它仅仅只是一个属性而已。</p>
<p>那么既然属性不能传参，怎么办呢？那我们就想办法把这个属性变成一个函数不就行了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plain">getters: &#123;<br>  &#x2F;&#x2F; 返回一个函数，就可以传参了<br>  weekDate: (state) &#x3D;&gt; (fm) &#x3D;&gt; &#123;<br>    return moment(state.date).format(fm ? fm : &#39;dddd&#39;); <br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>使用如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">store.getters.weekDate(&#39;MM Do YY&#39;)<br></code></pre></td></tr></table></figure>

<h3>只有 mutation 能动 State</h3>

<p>更改 Vuex 的 store 中的状态的唯一方法是提交 mutation。Vuex 中的 mutation 非常类似于事件：每个 mutation 都有一个字符串的 事件类型 (type) 和 一个 回调函数 (handler)。这个回调函数就是我们实际进行状态更改的地方，并且它会接受 state 作为第一个参数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs plain">const store &#x3D; new Vuex.Store(&#123;<br>  state: &#123;<br>    count: 1<br>  &#125;,<br>  mutations: &#123;<br>    &#x2F;&#x2F; 事件类型 type 为 increment<br>    increment (state) &#123;<br>      &#x2F;&#x2F; 变更状态<br>      state.count++<br>    &#125;<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure>
<p>注意，我们不能直接 store.mutations.increment() 来调用，Vuex 规定必须使用 store.commit 来触发对应 type 的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">store.commit(&#39;increment&#39;)<br></code></pre></td></tr></table></figure>
<h3>传参</h3>

<p>我们还可以向 store.commit 传入额外的参数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plain">mutations: &#123;<br>  increment (state, n) &#123;<br>    state.count +&#x3D; n<br>  &#125;<br>&#125;<br>调用<br>store.commit(&#39;increment&#39;, 10)<br></code></pre></td></tr></table></figure>
<p>mutation 中的这个额外的参数，官方给它还取了一个高大上的名字：载荷（payload）。说实话，第一次在文档中看到这个标题「提交载荷」，真的就不想往下看了。<br>我们往往不是败给了这些生涩的概念，而是败给了自己内心的恐惧。<br>大多数情况下，载荷是一个对象，能够让我们更加易读：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plain">mutations: &#123;<br>  increment (state, payload) &#123;<br>    state.count +&#x3D; payload.amount<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>关于提交的方式，有两种：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs plain">&#x2F;&#x2F; 1、把载荷和type分开提交<br>store.commit(&#39;increment&#39;, &#123;<br>  amount: 10<br>&#125;)<br><br>&#x2F;&#x2F; 2、整个对象都作为载荷传给 mutation 函数<br>store.commit(&#123;<br>  type: &#39;increment&#39;,<br>  amount: 10<br>&#125;)<br></code></pre></td></tr></table></figure>
<p>当然，使用哪种方式没有绝对的界限，纯看自己的喜好，就我个人而言，还是比较倾向于使用第二种姿势，放在一起更实在。</p>
<h3>修改规则</h3>

<p>简单修改基础类型的状态数据倒是简单，没什么限制，但是如果修改的是对象，那就要注意了。比如这个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs plain">const store &#x3D; new Vuex.Store(&#123;<br>  state: &#123;<br>    student: &#123;<br>      name: &#39;小明&#39;,<br>      sex: &#39;女&#39;<br>    &#125;<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure>
<p>这个时候，我们如果想要给 student 添加一个年龄 age: 18 属性，怎么办呢？</p>
<p>是的，直接在 sex 下面把这个字段加上去不就行了，能这样当然最好了。但是如果我们要动态的修改呢？那就得遵循 Vue 的规则了。如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plain">mutations: &#123;<br>  addAge (state) &#123;<br>    Vue.set(state.student, &#39;age&#39;, 18)<br>    &#x2F;&#x2F; 或者：<br>    &#x2F;&#x2F; state.student &#x3D; &#123; ...state.student, age: 18 &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>以上就是给对象添加属性的两种方式，当然，对于已添加的对象，如果想修改具体值的话，直接更改就是，比如 state.student.age=20 即可。</p>
<p>至于为什么要这样，之前我们了解过，因为 store 中的状态是响应式的，当我们更改状态数据的时候，监视状态的 Vue 组件也会自动更新，所以 Vuex 中的 mutation 也需要与使用 Vue 一样遵守这些规则。</p>
<h3>使用常量</h3>

<p>就是使用常量来替代 mutation 事件的名字。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">&#x2F;* mutation-types.js *&#x2F;<br>export const SOME_MUTATION &#x3D; &#39;SOME_MUTATION&#39;<br></code></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs plain">&#x2F;* tore.js *&#x2F;<br>import Vuex from &#39;vuex&#39;<br>import &#123; SOME_MUTATION &#125; from &#39;.&#x2F;mutation-types&#39;<br><br>const store &#x3D; new Vuex.Store(&#123;<br>  state: &#123; ... &#125;,<br>  mutations: &#123;<br>    &#x2F;* 使用 ES2015 风格的计算属性命名功能来使用一个常量作为函数名 *&#x2F;<br>    [SOME_MUTATION] (state) &#123;<br>      &#x2F;* mutate state *&#x2F;<br>    &#125;<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure>

<p>可能有人会有疑问啊，这样做到底有啥用，还得多创建个类型文件，用的时候还要导入进来，不嫌麻烦吗！</p>
<p>我们看看，mutation 是怎么调用的：store.commit(‘increment’)，可以发现，这里 commit 提交的方法 increment，是以字符串的形式代入的。如果项目小，一个人开发的话倒还好，但是项目大了，编写代码的人多了，那就麻烦了，因为需要 commit 的方法一多，就会显得特别混乱，而且以字符串形式代入的话，一旦出了错，很难排查。</p>
<p>所以，对于多人合作的大项目，最好还是用常量的形式来处理 mutation，对于小项目倒是无所谓，想偷懒的随意就好。</p>
<h3>必须是同步函数</h3>

<p>一定要记住，Mutation 必须是同步函数。为什么呢？</p>
<p>前面说了，我们之所以要通过提交 mutation 的方式来改变状态数据，是因为我们想要更明确地追踪到状态的变化。如果像下面这样异步的话：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plain">mutations: &#123;<br>  someMutation (state) &#123;<br>    api.callAsyncMethod(() &#x3D;&gt; &#123;<br>      state.count++<br>    &#125;)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>我们就不知道什么时候状态会发生改变，所以也就无法追踪了，这与 Mutation 的设计初心相悖，所以强制规定它必须是同步函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">store.commit(&#39;increment&#39;)<br></code></pre></td></tr></table></figure>

<h3>Action</h3>

<p>简单介绍<br>Action 类似于 mutation，不同在于：<br>1、Action 提交的是 mutation，而不是直接变更状态。<br>2、Action 可以包含任意异步操作。</p>
<p>看一个简单的 action 示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs plain">const store &#x3D; new Vuex.Store(&#123;<br>  state: &#123;<br>    count: 0<br>  &#125;,<br>  mutations: &#123;<br>    increment (state) &#123;<br>      state.count++<br>    &#125;<br>  &#125;,<br>  actions: &#123;<br>    increment (context) &#123;<br>      context.commit(&#39;increment&#39;)<br>    &#125;<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure>
<p>可以看到，Action 函数接受一个 context 参数，注意，这个参数可不一般，它与 store 实例有着相同的方法和属性，但是他们并不是同一个实例，后面学习 Modules 的时候会介绍它们为什么不一样。</p>
<p>所以在这里可以使用 context.commit 来提交一个 mutation，或者通过 context.state 和 context.getters 来获取 state 和 getters。</p>
<p>当然，为了代码简化，我们可以使用 ES2015 的 参数解构 来直接展开，便于 commit、state 等多次调用。如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plain">actions: &#123;<br>  increment (&#123; commit &#125;) &#123;<br>    commit(&#39;increment&#39;)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3>分发 Action</h3>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">store.dispatch(&#39;increment&#39;)<br></code></pre></td></tr></table></figure>
<p>Mutation 通过 store.commit 触发，那么 Action 则通过 store.dispatch 方法触发。</p>
<p>乍一眼看上去感觉多此一举，我们直接分发 mutation 岂不更方便？实际上并非如此，还记得 mutation 必须同步执行这个限制么？Action 就不受约束！我们可以在 action 内部执行异步操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plain">actions: &#123;<br>  incrementAsync (&#123; commit &#125;) &#123;<br>    setTimeout(() &#x3D;&gt; &#123;<br>      commit(&#39;increment&#39;)<br>    &#125;, 1000)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>和 Mutation 分发的方式异曲同工，这是注意这里是 dispatch：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs plain">&#x2F;* 以载荷形式分发 *&#x2F;<br>store.dispatch(&#39;incrementAsync&#39;, &#123;<br>  amount: 10<br>&#125;)<br><br>&#x2F;* 以对象形式分发 *&#x2F;<br>store.dispatch(&#123;<br>  type: &#39;incrementAsync&#39;,<br>  amount: 10<br>&#125;)<br></code></pre></td></tr></table></figure>
<p>来看一个更加实际的购物车示例，涉及到调用异步 API 和分发多重 mutation：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs plain">actions: &#123;<br>  checkout (&#123; commit, state &#125;, products) &#123;<br>    &#x2F;&#x2F; 把当前购物车的物品备份起来<br>    const savedCartItems &#x3D; [...state.cart.added]<br>    &#x2F;&#x2F; 发出结账请求，然后乐观地清空购物车<br>    commit(types.CHECKOUT_REQUEST)<br>    &#x2F;&#x2F; 购物 API 接受一个成功回调和一个失败回调<br>    shop.buyProducts(<br>      products,<br>      &#x2F;&#x2F; 成功操作<br>      () &#x3D;&gt; commit(types.CHECKOUT_SUCCESS),<br>      &#x2F;&#x2F; 失败操作<br>      () &#x3D;&gt; commit(types.CHECKOUT_FAILURE, savedCartItems)<br>    )<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>注意示例中正在进行一系列的异步操作，并且通过提交 mutation 来记录 action 产生的副作用（即状态变更）。</p>
<h3>组合 Action</h3>

<p>Action 通常是异步的，那么如何知道 action 什么时候结束呢？更重要的是，我们如何才能组合多个 action，以处理更加复杂的异步流程？</p>
<p>首先，你需要明白 store.dispatch 可以处理被触发的 action 的处理函数返回的 Promise，并且 store.dispatch 仍旧返回 Promise：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs plain">actions: &#123;<br>  actionA (&#123; commit &#125;) &#123;<br>    return new Promise((resolve, reject) &#x3D;&gt; &#123;<br>      setTimeout(() &#x3D;&gt; &#123;<br>        commit(&#39;someMutation&#39;)<br>        resolve()<br>      &#125;, 1000)<br>    &#125;)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>调用:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">store.dispatch(&#39;actionA&#39;).then(() &#x3D;&gt; &#123;<br>  &#x2F;&#x2F; ...<br>&#125;)<br></code></pre></td></tr></table></figure>
<p>当然，也可以这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs plain">actions: &#123;<br>  &#x2F;&#x2F; ...<br>  actionB (&#123; dispatch, commit &#125;) &#123;<br>    return dispatch(&#39;actionA&#39;).then(() &#x3D;&gt; &#123;<br>      commit(&#39;someOtherMutation&#39;)<br>    &#125;)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>我们还可以利用 async / await 的方式组合 action ：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs plain">&#x2F;* 假设 getData() 和 getOtherData() 返回的是 Promise *&#x2F;<br>actions: &#123;<br>  async actionA (&#123; commit &#125;) &#123;<br>    commit(&#39;gotData&#39;, await getData())<br>  &#125;,<br>  async actionB (&#123; dispatch, commit &#125;) &#123;<br>    await dispatch(&#39;actionA&#39;) &#x2F;&#x2F; 等待 actionA 完成<br>    commit(&#39;gotOtherData&#39;, await getOtherData())<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>一个 store.dispatch 在不同模块中可以触发多个 action 函数。在这种情况下，只有当所有触发函数完成后，返回的 Promise 才会执行。</p>
<p>我们在实际项目中经常的会遇到这种情况，比如说你现在想要处理 B 事件，但是 B 事件需要一种资源才能进行，而这种资源必须通过 A 事件来获得。这个时候，我们就需要组合 Action 来处理这些事件了。</p>
<h3>mapState</h3>

<p>通过前面的学习，我们知道，从 store 实例中读取状态最简单的方法就是在计算属性中返回某个状态。</p>
<p>那么，当一个组件需要获取多个状态的时候，怎么办？是不是这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs plain">export default &#123;<br>  ...<br>  computed: &#123;<br>      a () &#123;<br>        return store.state.a<br>      &#125;,<br>      b () &#123;<br>        return store.state.b<br>      &#125;,<br>      c () &#123;<br>        return store.state.c<br>      &#125;,<br>      ...<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>当然，这样是没问题的，但是总感觉写起来很难受，看起来更难受是吧！既然这么容易我们就感受到了，Vuex 能感受不到吗，能忍得了吗？</p>
<p>绝对不能忍，所以 mapState 辅助函数被创造了出来，用来搞定这个人人为之咬牙切齿的痛点。</p>
<p>/* 在单独构建的版本中辅助函数为 Vuex.mapState */</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs plain">import &#123; mapState &#125; from &#39;vuex&#39;<br><br>export default &#123;<br>  computed: mapState(&#123;<br>    &#x2F;* 箭头函数可使代码更简练 *&#x2F;<br>    a: state &#x3D;&gt; state.a,<br>    b: state &#x3D;&gt; state.b,<br>    c: state &#x3D;&gt; state.c,<br><br>    &#x2F;* 传字符串参数 &#39;b&#39; *&#x2F;<br>    &#x2F;* 等同于 &#96;state &#x3D;&gt; state.b&#96; *&#x2F;<br>    bAlias: &#39;b&#39;,<br><br>    &#x2F;* 为了能够使用 &#96;this&#96; 获取局部状态 *&#x2F;<br>    &#x2F;* 必须使用常规函数 *&#x2F;<br>    cInfo (state) &#123;<br>      return state.c + this.info<br>    &#125;<br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure>
<p>通过上面的示例，可以了解到，我们可以直接把需要用到的状态全部存放在 mapState 里面进行统一管理，而且还可以取别名，做额外的操作等等。</p>
<p>如果所映射的计算属性名称与 state 的子节点名称相同时，我们还可以更加简化，给 mapState 传一个字符串数组：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plain">computed: mapState([<br>  &#x2F;* 映射 this.a 为 store.state.a *&#x2F;<br>  &#39;a&#39;,<br>  &#39;b&#39;,<br>  &#39;c&#39;<br>])<br></code></pre></td></tr></table></figure>
<p>因为 computed 这个计算属性接收的是一个对象，所以由上面的示例代码可以看出，mapState 函数返回的是一个对象，现在如果想要和局部的计算属性混合使用的话，可以使用 ES6 的语法这样写来大大简化：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs plain">computed: &#123;<br>  localComputed () &#123; <br>    ...<br>  &#125;,<br>  &#x2F;* 使用对象展开运算符将此对象混入到外部对象中 *&#x2F;<br>  ...mapState(&#123;<br>    <br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure>
<p>了解了 mapState 辅助函数后，接下来的几个辅助函数的用法也基本上都差不多了，我们继续往下看。</p>
<h3>mapGetters</h3>

<p>这个和 mapState 基本上没啥区别，简单看下官方的例子，就懂了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs plain">import &#123; mapGetters &#125; from &#39;vuex&#39;<br><br>export default &#123;<br>  computed: &#123;<br>    ...mapGetters([<br>      &#39;doneTodosCount&#39;,<br>      &#39;anotherGetter&#39;,<br>    ])<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>取个别名，那就用对象的形式，以下示例的意思就是把 this.doneCount 映射为 this.$store.getters.doneTodosCount。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">mapGetters(&#123;<br>  doneCount: &#39;doneTodosCount&#39;<br>&#125;)<br></code></pre></td></tr></table></figure>
<h3>mapMutations</h3>

<p>直接看示例代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs plain">import &#123; mapMutations &#125; from &#39;vuex&#39;<br><br>export default &#123;<br>  methods: &#123;<br>    ...mapMutations([<br>      &#x2F;&#x2F; 将 &#96;this.increment()&#96; 映射为 <br>      &#x2F;&#x2F; &#96;this.$store.commit(&#39;increment&#39;)&#96;<br>      &#39;increment&#39;, <br>      &#x2F;&#x2F; &#96;mapMutations&#96; 也支持载荷：<br>      &#x2F;&#x2F; 将 &#96;this.incrementBy(amount)&#96; 映射为 <br>      &#x2F;&#x2F; &#96;this.$store.commit(&#39;incrementBy&#39;, amount)&#96;<br>      &#39;incrementBy&#39; <br>    ]),<br>    ...mapMutations(&#123;<br>      &#x2F;&#x2F; 将 &#96;this.add()&#96; 映射为 <br>      &#x2F;&#x2F; &#96;this.$store.commit(&#39;increment&#39;)&#96;<br>      add: &#39;increment&#39; <br>    &#125;)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>简直不要太好用，连载荷也可以直接支持。</p>
<h3>mapActions</h3>

<p>和 mapMutations 用法一模一样，换个名字即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs plain">import &#123; mapActions &#125; from &#39;vuex&#39;<br><br>export default &#123;<br>  &#x2F;&#x2F; ...<br>  methods: &#123;<br>    ...mapActions([<br>      &#x2F;&#x2F; 将 &#96;this.increment()&#96; 映射为 <br>      &#x2F;&#x2F; &#96;this.$store. dispatch(&#39;increment&#39;)&#96;<br>      &#39;increment&#39;, <br>      &#x2F;&#x2F; &#96;mapActions&#96; 也支持载荷：<br>      &#x2F;&#x2F; 将 &#96;this.incrementBy(amount)&#96; 映射为 <br>      &#x2F;&#x2F; &#96;this.$store. dispatch(&#39;incrementBy&#39;, amount)&#96;<br>      &#39;incrementBy&#39; <br>    ]),<br>    ...mapActions(&#123;<br>      &#x2F;&#x2F; 将 &#96;this.add()&#96; 映射为 <br>      &#x2F;&#x2F; &#96;this.$store. dispatch(&#39;increment&#39;)&#96;<br>      add: &#39;increment&#39; <br>    &#125;)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>想要在组件中调用，直接 this.xxx 就完了。</p>
<h3>Module</h3>

<p>首先还是得先了解下 Module 的背景。我们知道，Vuex 使用的是单一状态树，应用的所有状态会集中到一个对象中。如果项目比较大，那么相应的状态数据肯定就会更多，这样的话，store 对象就会变得相当的臃肿，非常难管理。</p>
<p>这就好比一家公司只有老板一个人来管理一样。如果小公司倒还好，公司要是稍微大一点，那就麻烦了。这个时候，老板就会成立各大部门，并给各大部门安排一个主管，把管理的任务分派下去，然后有什么事情需要处理的话，只需要跟这几个主管沟通，由主管再把任务分配下去就行了，这就大大提高了工作效率，也减轻了老板的负担。</p>
<p>那么同样的道理，Module 其实就承担了部门管理员的角色，而 store 就是老板。理解了这一层，那么后面就好办多了，接下来，咱们就一步一步动起手来开始实践。</p>
<p>我们已经了 Module 的基本职责，那么具体如何使用呢？</p>
<p>Vuex 允许我们将 store 分割成大大小小的对象，每个对象也都拥有自己的 state、getter、mutation、action，这个对象我们把它叫做 module（模块），在模块中还可以继续嵌套子模块、子子模块 ……</p>
<p>现在在 src 里面建个文件夹，命名为 module，然后再里面新建一个 moduleA.js 文件，并编写如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs plain">export default &#123;<br>    state: &#123;<br>        text: &#39;moduleA&#39;<br>    &#125;,<br>    getters: &#123;&#125;,<br>    mutations: &#123;&#125;,<br>    actions: &#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>如上，再建一个 moduleB.js 文件，这里就不重复了。</p>
<p>然后打开 store.js 文件，导入这两个 module ：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs plain">import moduleA from &#39;.&#x2F;module&#x2F;moduleA&#39;;<br>import moduleB from &#39;.&#x2F;module&#x2F;moduleB&#39;;<br><br>export default new Vuex.Store(&#123;<br>    modules: &#123;<br>        moduleA, moduleB,<br>    &#125;,<br>    <br>&#125;<br></code></pre></td></tr></table></figure>
<p>这个时候，store 中已经注入了两个子模块 moduleA moduleB，我们可以在 App.vue 中通过 this.$store.state.moduleA.text 这种方式来直接访问模块中的 state 数据。如下修改：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plain">computed: &#123;<br>    ...mapState(&#123;<br>        name: state &#x3D;&gt; state.moduleA.text<br>    &#125;),<br>&#125;,<br></code></pre></td></tr></table></figure>

<p>由此可知，模块内部的 state 是局部的，只属于模块本身所有，所以外部必须通过对应的模块名进行访问。</p>
<p>但是注意了：</p>
<p>模块内部的 action、mutation 和 getter 默认可是注册在全局命名空间的，这样使得多个模块能够对同一 mutation 或 action 作出响应。</p>
<p>这里以 mutation 的响应为例，给 moduleA 和 moduleB 分别新增一个 mutations，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plain">mutations: &#123;<br>    setText(state) &#123;<br>        state.text &#x3D; &#39;A&#39;<br>    &#125;<br>&#125;,<br></code></pre></td></tr></table></figure>
<p>moduleB 和上面一样，把文本名称修改一下即可，这里就不重复了。然后回到 App.vue 中，修改如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs plain">&lt;script&gt;<br>    import &#123;mapState, mapMutations&#125; from &#39;vuex&#39;;<br>    export default &#123;<br>        computed: &#123;<br>            ...mapState(&#123;<br>                name: state &#x3D;&gt; (state.moduleA.text + &#39;和&#39; + state.moduleB.text)<br>            &#125;),<br>        &#125;,<br>        methods: &#123;<br>            ...mapMutations([&#39;setText&#39;]),<br>            modifyNameAction() &#123;<br>                this.setText();<br>            &#125;<br>        &#125;,<br>    &#125;<br>&lt;&#x2F;script&gt;<br></code></pre></td></tr></table></figure>
<p>运行然后点击修改，我们会发现模块 A 和 B 中的 text 值都改变了。当然，action 的用法一模一样，大家也可以试试。</p>
<p>如果模块之间的数据有交集的话，那么我们其实就可以通过这种方式，来同步更新模块之间的数据，虽然看起来非常的方便，但是用的时候可一定要谨慎，这种处理方式一旦没用好，遇到错误，排查起来还是比较有难度的。</p>
<h3>访问根节点</h3>

<p>我们已经知晓，模块内部的 state 是局部的，只属于模块本身所有。那么如果我们要想在模块中访问 store 根节点的数据 state，怎么办呢？<br>很简单，我们可以在模块内部的 getter 和 action 中，通过 rootState 这个参数来获取。接下来，我们给 modelA.js 文件添加一点代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs plain">export default &#123;<br>    getters: &#123;<br>        &#x2F;* 注意:rootState必须是第三个参数 *&#x2F;<br>        detail(state, getters, rootState) &#123;<br>            return state.text + &#39;-&#39; + rootState.name;<br>        &#125;<br>    &#125;,<br>    actions: &#123;<br>        callAction(&#123;state, rootState&#125;) &#123;<br>            alert(state.text + &#39;-&#39; + rootState.name);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>然后修改 App.vue ：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs plain">&lt;script&gt;<br>    import &#123;mapActions, mapGetters&#125; from &#39;vuex&#39;;<br>    export default &#123;<br>        computed: &#123;<br>            ...mapGetters(&#123;<br>                name: &#39;detail&#39;<br>            &#125;),<br>        &#125;,<br>        methods: &#123;<br>            ...mapActions([&#39;callAction&#39;]),<br>            modifyNameAction() &#123;<br>                this.callAction();<br>            &#125;<br>        &#125;,<br>    &#125;<br>&lt;&#x2F;script&gt;<br></code></pre></td></tr></table></figure>
<p>然后运行你会发现，根节点的数据已经被我们获取到了。这里需要注意的是在 getters 中，rootState 是以第三个参数暴露出来的，另外，还有第四个参数 rootGetters，用来获得根节点的 getters 信息，这里就不演示了，感兴趣自己可以去尝试。唯一要强调的就是千万不要弄错参数的位置了。</p>
<p>当然，action 中也能接收到 rootGetters，但是在 action 中，由于它接收过来的数据都被包在 context 对象中的，所以解包出来没有什么顺序的限制。</p>
<h3>命名空间</h3>

<p>前面我们已经知道了，模块内部的 action、mutation 和 getter 默认是注册在全局命名空间的。如果我们只想让他们在当前的模块中生效，应该怎么办呢？</p>
<p>通过添加 namespaced: true 的方式使其成为带命名空间的模块。当模块被注册后，它的所有 getter、action 及 mutation 都会自动根据模块注册的路径调整命名。</p>
<p>我们在 moduleA.js 中添加 namespaced: true。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">export default &#123;<br>    namespaced: true,<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这个时候再去运行代码，你会发现如下错误：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">[vuex] unknown getter: detail<br></code></pre></td></tr></table></figure>
<p>在全局 getter 中已经找不到 detail 的这个方法了，因为它的路劲已经改变了，不再属于全局，仅仅只属于 moduleA 了。所以，这个时候，如果我们想要访问它，必须带上路劲才行。修改 App.vue 如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs plain">&lt;script&gt;<br>import &#123;mapActions, mapGetters&#125; from &#39;vuex&#39;;<br>export default &#123;<br>    computed: &#123;<br>        ...mapGetters(&#123;<br>            name: &#39;moduleA&#x2F;detail&#39;<br>        &#125;),<br>    &#125;,<br>    methods: &#123;<br>        ...mapActions(&#123;<br>            call: &#39;moduleA&#x2F;callAction&#39;<br>        &#125;),<br>        modifyNameAction() &#123;<br>            this.call();<br>        &#125;<br>    &#125;,<br>&#125;<br>&lt;&#x2F;script&gt;<br></code></pre></td></tr></table></figure>
<p>注意，如果一个模块启用了命名空间，那么它里面的 getter 和 action 中收到的 getter，dispatch 和 commit 也都是局部化的，不需要在同一模块内额外添加空间名前缀。也就是说，更改 namespaced 属性后不需要修改模块内的任何代码。</p>
<p>那么我们如何在带命名空间的模块内访问全局内容呢？</p>
<p>通过前面的学习，我们已经了解到：</p>
<p>如果你希望使用全局 state 和 getter，rootState 和 rootGetter 会作为第三和第四参数传入 getter，也会通过 context 对象的属性传入 action。</p>
<p>现在如果想要在全局命名空间内分发 action 或提交 mutation 的话，那么我们只需要将 将 { root: true } 作为第三参数传给 dispatch 或 commit 即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs plain">export default &#123;<br>    namespaced: true,<br>    actions: &#123;<br>        callAction(&#123;state, commit, rootState&#125;) &#123;<br>            commit(&#39;setName&#39;, &#39;改变&#39;, &#123;root: true&#125;);<br>            alert(state.text + &#39;-&#39; + rootState.name);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>接下来看看如何在带命名空间的模块内注册全局 action。</p>
<p>若需要在带命名空间的模块注册全局 action，你可添加 root: true，并将这个 action 的定义放在函数 handler 中。</p>
<p>写法稍微有点变化，我们来看看，修改 moduleA.js，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs plain">export default &#123;<br>    namespaced: true,<br>    actions: &#123;<br>        callAction: &#123;<br>            root: true,<br>            handler (namespacedContext, payload) &#123;<br>                let &#123;state, commit&#125; &#x3D; namespacedContext;<br>                commit(&#39;setText&#39;);<br>                alert(state.text);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>简单解释下，这里的 namespacedContext 就相当于当前模块的上下文对象，payload 是调用的时候所传入的参数，当然也叫载荷。</p>
<p>示例就讲到这里，接下来看看带命名空间的绑定函数。</p>
<p>关于 mapState, mapGetters, mapActions 和 mapMutations 这些函数如何来绑定带命名空间的模块，上面示例代码中其实已经都写过了，这里再看看另外几种更简便的写法，先看看之前的写法。</p>
<p>这里就用官方的示例代码举例说明：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs plain">computed: &#123;<br>    ...mapState(&#123;<br>        a: state &#x3D;&gt; state.some.nested.module.a,<br>        b: state &#x3D;&gt; state.some.nested.module.b<br>    &#125;)<br>&#125;,<br>methods: &#123;<br>    ...mapActions([<br>        &#x2F;&#x2F; -&gt; this[&#39;some&#x2F;nested&#x2F;module&#x2F;foo&#39;]()<br>        &#39;some&#x2F;nested&#x2F;module&#x2F;foo&#39;, <br>        &#x2F;&#x2F; -&gt; this[&#39;some&#x2F;nested&#x2F;module&#x2F;bar&#39;]()<br>        &#39;some&#x2F;nested&#x2F;module&#x2F;bar&#39; <br>    ])<br>&#125;<br></code></pre></td></tr></table></figure>
<p>更优雅的写法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs plain">computed: &#123;<br>    ...mapState(&#39;some&#x2F;nested&#x2F;module&#39;, &#123;<br>        a: state &#x3D;&gt; state.a,<br>        b: state &#x3D;&gt; state.b<br>    &#125;)<br>&#125;,<br>methods: &#123;<br>    ...mapActions(&#39;some&#x2F;nested&#x2F;module&#39;, [<br>        &#39;foo&#39;, &#x2F;* -&gt; this.foo() *&#x2F;<br>        &#39;bar&#39; &#x2F;* -&gt; this.bar() *&#x2F;<br>    ])<br>&#125;<br></code></pre></td></tr></table></figure>
<p>将模块的空间名称字符串作为第一个参数传递给上述函数，这样所有绑定都会自动将该模块作为上下文。</p>
<p>我们还可以通过使用 createNamespacedHelpers 创建基于某个命名空间辅助函数。它返回一个对象，对象里有新的绑定在给定命名空间值上的组件绑定辅助函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs plain">import &#123; createNamespacedHelpers &#125; from &#39;vuex&#39;<br><br>const &#123; mapState, mapActions &#125; &#x3D; createNamespacedHelpers(&#39;some&#x2F;nested&#x2F;module&#39;)<br><br>export default &#123;<br>  computed: &#123;<br>    &#x2F;* 在 &#96;some&#x2F;nested&#x2F;module&#96; 中查找 *&#x2F;<br>    ...mapState(&#123;<br>      a: state &#x3D;&gt; state.a,<br>      b: state &#x3D;&gt; state.b<br>    &#125;)<br>  &#125;,<br>  methods: &#123;<br>    &#x2F;* 在 &#96;some&#x2F;nested&#x2F;module&#96; 中查找 *&#x2F;<br>    ...mapActions([<br>      &#39;foo&#39;,<br>      &#39;bar&#39;<br>    ])<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3>模块的动态注册</h3>

<p>这一章节，官网讲得比较清楚，所以直接搬过来了。</p>
<p>在 store 创建之后，可以使用 store.registerModule 方法动态的注册模块：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs plain">注册模块 &#96;myModule&#96;<br>store.registerModule(&#39;myModule&#39;, &#123;<br>  <br>&#125;)<br>注册嵌套模块 &#96;nested&#x2F;myModule&#96;<br>store.registerModule([&#39;nested&#39;, &#39;myModule&#39;], &#123;<br>  <br>&#125;)<br></code></pre></td></tr></table></figure>
<p>之后就可以通过 store.state.myModule 和 store.state.nested.myModule 访问模块的状态。</p>
<p>模块动态注册功能使得其他 Vue 插件可以通过在 store 中附加新模块的方式来使用 Vuex 管理状态。例如，vuex-router-sync 插件就是通过动态注册模块将 vue-router 和 vuex 结合在一起，实现应用的路由状态管理。</p>
<p>你也可以使用 store.unregisterModule(moduleName) 来动态卸载模块。注意，你不能使用此方法卸载静态模块（即创建 store 时声明的模块）。</p>
<p>在注册一个新 module 时，你很有可能想保留过去的 state，例如从一个服务端渲染的应用保留 state。你可以通过 preserveState 选项将其归档：store.registerModule(‘a’, module, { preserveState: true })。</p>
<h3>模块重用</h3>

<p>就一点，重用会导致模块中的数据 state 被污染，所以和 Vue 中的 data 一样，也使用一个函数来申明 state 即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plain">const MyReusableModule &#x3D; &#123;<br>  state () &#123;<br>    return &#123;<br>      foo: &#39;bar&#39;<br>    &#125;<br>  &#125;,<br>&#125;<br></code></pre></td></tr></table></figure>
        </div>
      </div>
    </div>
  </div>
</article>



    <!-- Footer -->
<footer>
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <p class="copyright text-muted">
          Theme By <a target="_blank" href="https://github.com/levblanc">Levblanc.</a>
          Inspired By <a target="_blank" href="https://github.com/klugjo/hexo-theme-clean-blog">Clean Blog.</a>
        <p class="copyright text-muted">
          Powered By <a target="_blank" href="https://hexo.io/">Hexo.</a>
        </p>
      </div>
    </div>
  </div>
</footer>


    <!-- After Footer Scripts -->

<script src="/js/highlight.pack.js"></script>

<script>
  document.addEventListener("DOMContentLoaded", function(event) {
    var codeBlocks = Array.prototype.slice.call(document.getElementsByTagName('pre'))
    codeBlocks.forEach(function(block, index) {
      hljs.highlightBlock(block);
    });
  });
</script>

  </body>
</html>

